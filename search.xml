<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/04/04/About-Me/</url>
    <content><![CDATA[<ul>
<li>A acmer, live in liaocheng,China</li>
<li>70%山东+20%四川+10%深圳=Me<br>姓名：Jozky<br>现居：聊城<br>大学：QDU<br>QQ:2830872914<br><img src="https://img-blog.csdnimg.cn/20200404170050150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS序讲解</title>
    <url>/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；<br>dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。</p>
<a id="more"></a>
<p>如图：<br><img src="https://img-blog.csdnimg.cn/20200407172327886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">dfs序就是：ABDDEEBCFHHFG<br>其实就是用dfs全部遍历一遍，不过我们不能光遍历还有动些小手脚，我们要在遍历的同时记录每个节点进栈与出栈的时间序列。</p>
<p>介绍两个基本函数：in[x],out[x]<br>dfs从根节点开始，这俩函数就分别记录每个节点x进入与离开的时间戳<br>还有num[x]，表示第x个节点的编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inline int dfs(int x,int fa,int time)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">in</span>[x]=++time;</span><br><span class="line">	num[time]=x;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=e[x].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int w=e[x][i];</span><br><span class="line">		<span class="keyword">if</span>(w==fa)<span class="built_in">continue</span>;//防止又从子节点找回去</span><br><span class="line">		dfs(w,x,time); </span><br><span class="line">	&#125;</span><br><span class="line">	out[x]=time;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">dfs(s,0,0);</span><br></pre></td></tr></table></figure>
<p>（具体情况根据，根据题目来写）<br><img src="https://img-blog.csdnimg.cn/20200407174719197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">num生成的就是一个新秩序，由每个节点进入关系而形成的<br>你仔细观察会发现：<br>序根节点的进栈时间&lt;子树的dfs&lt;根节点的出栈时间<br>这样不就成一个区间了<br>in[x]~out[x]是x为根节点的子树，划分为一个区间<br>然后什么单点修改，区间查询，莫队都可以用在树上，而且dfs序也是树链剖分的前驱知识</p>
<p>光说可能不怎么懂，我去找一些题，做完再更新例题</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 282E Sausage Maximization</title>
    <url>/2020/04/16/CodeForces-282E-Sausage-Maximization/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">传送cf题目</a><br> <a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">传送牛客网题目</a><br><del>看了半个多小时的题解才搞明白，一下题解为自己的心得</del><br>参考博客（这两个讲的很详细）：<br><a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html" target="_blank" rel="noopener">参考二</a></p>
<blockquote>
<p>题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？</p>
<a id="more"></a>
<p>比如 一组数  1 2 3 4 5 6 你可以选择前缀为1 2，前缀异或和为3 选择后缀为4 5 6，后缀异或和为7<br>（前缀异或和）与（后缀异或和）异或值为4，但此时4并不是最大情况，求出最大情况</p>
</blockquote>
<p><strong>思路：</strong><br>首先讲个小例题：</p>
<blockquote>
<p>  给一个数 a，还有一堆数，怎么在这一堆数中找出一个数 b，a 和 b 的异或值最大？</p>
</blockquote>
<p>最暴力的方法无疑是（<del>老办法</del>）  枚举，枚举每一个b，但这样肯定不行<del>（不然我写这个博客干什么）</del> ，想想计算机的本质是啥？对，二进制。我们把a与这堆数转化成二进制，把后面这堆数装进一个字典树，当然要从最高位装，比如这堆数是123456，如图<img src="https://uploadfiles.nowcoder.com/files/20200326/543071257_1585188887053_20200326000539458.jpg" alt="这堆数是123456">根据异或规则不同为一，所以我们要使a与b异或最大，就要让b尽可能与a不同，a已经给定，b已经形成字典树，我们就从字典树root开始，尽量找出于a当前位置不同的数，直到找到最低位为止，那么这样找到的b满足条件。</p>
<p><strong>回到这个题：</strong><br>首先这些n个数组成一个区间w，w的全部异或结果是定值K,所以问题可以改成在区间w中取连续一段区间m，m的异或结果为X，m的前部分就成为区间w的前缀，后半部分就是区间w的后缀。<br>我们知道相同的数异或为零，那么X与K异或，重复的那部分区间异或后为零，就相当于是我们题目所求的<br>，所以就是求什么情况下X xor K最大。<br>发现现在的情况和一开始讲的例题很像了吧，我们假设有个Y，Y与K的每一个二进制相异，我们就要让X尽可能接近Y。<br>怎么实现呢？也是建一个字典树，将f[i]放进去（f[i]=a[1] ^ a[2]  ^ a[3] ^ …^ a[i]）,那么f[i]^f[j]=a[i+1] ^ a[i+2] ^ … ^a<a href="i之前的部分为i和j共有，一异或就相当于没了">j</a>可以表示i+1到j这段区间的异或值。<br>我们枚举区间m的结尾，每次用一个f[i]去匹配一个f[k]，使得f[k]^f[i]的值在高位上尽可能去接近Y，这样就相当于选出区间[k+1,i]de异或值作为X，每次在[1,i]区间内匹配出来一个最佳区间后，不断更新答案。<br>看懂了吗？这些神奇的操作，巧妙利用字典树（工具人石锤）来匹配。<br>(太晚了就不重新打代码了，借用下<a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a>的代码)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//范围是10的12次方，我们就将每个数固定为40位</span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define LL long long</span></span><br><span class="line"><span class="comment">#define rep(i,j,k) for(int i = j; i &lt;= k; i++ )</span></span><br><span class="line"><span class="comment">#define Rrep(i,j,k) for(int i = j; i &gt;= k; i-- )</span></span><br><span class="line"><span class="comment">#define Clean(x,y) memset(x,y,sizeof(x)) </span></span><br><span class="line">int n;</span><br><span class="line">LL a[100009];</span><br><span class="line">LL temp;</span><br><span class="line">LL ans;</span><br><span class="line"> </span><br><span class="line">LL p[45];</span><br><span class="line">int aim[45];</span><br><span class="line">int Next[1000000][2];</span><br><span class="line">int len;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    Clean(Next,0);</span><br><span class="line">    len = 0;</span><br><span class="line">&#125;</span><br><span class="line">void insert(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( !Next[now][k] ) Next[now][k] = ++len;</span><br><span class="line">        now = Next[now][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL query(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    LL ans = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( ( aim[i] &amp;&amp; Next[now][1-k] ) || ( !aim[i] &amp;&amp; Next[now][k] )  )</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=p[i];</span><br><span class="line">            now = aim[i]==1?Next[now][1-k]:Next[now][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now = aim[i]==0?Next[now][1-k]:Next[now][k];</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    rep(i,1,40) p[i] = p[i-1]&lt;&lt;1;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        ans = 0;</span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(<span class="string">"%I64d"</span>,&amp;temp);</span><br><span class="line">            a[i] = temp ^ a[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,a[n]);</span><br><span class="line">        rep(i,0,39)</span><br><span class="line">            <span class="keyword">if</span> ( a[n] &amp; p[i] ) aim[i] = 0; //计算Y</span><br><span class="line">            <span class="keyword">else</span> aim[i] = 1;</span><br><span class="line">        init();</span><br><span class="line">        insert(a[0]); </span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(a[i]);</span><br><span class="line">            ans = max(ans,query(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximize The Beautiful Value </title>
    <url>/2020/04/11/Maximize-The-Beautiful-Value/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/A" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he<br>thinks it’s not beautiful so he wants to make it beautiful. To make<br>it, HH will choose exactly one number and move it forward at least k<br>steps(i.e. you can move ai to aj if k≤i−j), and then he defines the<br>beautiful value F(n) as  HH asks you to calculate max(F(n))</p>
</blockquote>
<a id="more"></a> 
<blockquote>
<p><img src="https://uploadfiles.nowcoder.com/files/20200411/543071257_1586538298107_20200411005140649.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p> The first line contains an positive integer T(1≤T≤10), represents<br>there are T test cases.   For each test case:   The first line<br>contains two positive integers n,k(1≤n≤105,1≤k&lt;n)，the length of the<br>sequence ,the least steps you need to move.   The second line contains<br>n integers a1,a2…an(1≤ai≤108) - the sequence.</p>
<p>输出描述:</p>
<p>For each test case, you should output the max F(n).</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<blockquote>
<p>In the first example, you can move the fifth number 4 for 3 steps and<br>make the sequence become [4,1,1,3,5], then the beautiful value is<br>4×1+1×2+1×3+3×4+5×5=46. You can also move the fifth number to make it<br>become [1,5,1,3,4], the beautiful value is also 46. In the second<br>example, you can move the  fifth number 5 for 2 steps and make the<br>sequence become [1,1,5,3,4] In the second example, you can move the<br>second number 1 for 1 steps and then the sequence is still [1,1,3,4,5]</p>
</blockquote>
<p>备注:</p>
<p>scanf is commended。</p>
<p> <strong>题解：</strong><br>比如：A B C D E<br>对应：1 2 3 4 5<br>此时的值为ans1=1<em>A+2<em>B+3</em>C+4<em>D+5</em>E<br>现在D移动到B前面，移动了两步<br>A D B C E<br>此时的值：ans2 = 1<em>A+2</em>D+3<em>B+4</em>C+5<em>E<br> =1</em>A+2<em>B+3</em>C+4<em>D+5</em>E-3<em>D+（B+C+D）<br>观察ans1与ans2相比有什么变化<br>发生改变就是减去这个数字的k倍，再加上被移动数字（共k个）的和<br>因为D向前移动k，说明D</em>i–&gt;D</em>(i-k)<br>BC因为D向前而被拱到后面，从B<em>i—&gt;b</em>(i+1)<br>被移动数字之和我们可以用前缀和pre实现<br>看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(w) for(int i=w;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line">	<span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//	cin&gt;&gt;a[i];</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">			ans=ans+a[i]*i;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">					pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>((k+<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			tot=max(tot,ans-a[i]*k+(pre[i<span class="number">-1</span>]-pre[i-k<span class="number">-1</span>]));</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀后缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>Music Problem</title>
    <url>/2020/04/17/Music-Problem/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/B" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Listening to the music is relax, but for obsessive(强迫症), it may be<br>unbearable. HH is an obsessive, he only start to listen to music at<br>12:00:00, and he will never stop unless the song he is listening ends</p>
<a id="more"></a> 
<p>at integral points (both minute and second are 0 ), that is, he can<br>stop listen at 13:00:00 or 14:00:00,but he can’t stop at 13:01:03 or<br>13:01:00, since 13:01:03 and 13:01：00 are not an integer hour time.<br>Now give you the length of some songs, tell HH whether it’s possible<br>to choose some songs so he can stop listen at an integral point, or<br>tell him it’s impossible. Every song can be chosen at most once.</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p> The first line contains an positive integer T(1≤T≤60), represents<br>there are T test cases.   For each test case:   The first line<br>contains an integer n(1≤n≤105), indicating there are n songs.   The<br>second line contains n integers a1,a2…an (1≤ai≤109 ), the ith integer<br>ai indicates the ith song lasts ai seconds.</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>For each test case, output one line “YES” (without quotes) if HH is<br>possible to stop listen at an integral point, and “NO” (without<br>quotes) otherwise.</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">1000</span> <span class="number">3000</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">3000</span> <span class="number">1600</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5400</span> <span class="number">1800</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<p>说明<br>In the first example it’s impossible to stop at an integral point.<br>In the second example if we choose the first and the third songs, they cost 3600 seconds in total, so HH can stop at 13:00:00<br>In the third example if we choose the first and the second songs, they cost 7200 seconds in total, so HH can stop at 14:00:00</p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你n个数，这些数自由组合能不能凑出3600的倍数</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始想到的是前缀和，后来感觉dp最直接<br>dp[x]=1表示能组成x这个数<br>dp = 0表示组不了<br>cnt是中间数组，暂时存储本轮的数值<br>因为求能不能组成3600，可以用mod，3600的倍数mod后都是0，直接求dp[0]是否等于1<br>每读取一个a，就把a与之前所求的值进行相加存在cnt里，然后再给dp[]，cnt就是工具人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">3600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    		mem(dp);</span><br><span class="line">    	mem(cnt);</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> a;</span><br><span class="line">    		<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    		a%=<span class="number">3600</span>;</span><br><span class="line">    		<span class="keyword">if</span>(!dp[<span class="number">0</span>])</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">if</span>(dp[j]&gt;<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">    				&#123;</span><br><span class="line">    					cnt[(a+j)%<span class="number">3600</span>]=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(cnt[j])dp[j]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(cnt[j]==<span class="number">1</span>)cnt[j]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">//	mem(cnt);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!dp[<span class="number">0</span>])<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个很玄学的地方我把读入n放在两个mem之前，数据就过了一半，放后面就ac了，不知道为什么<br><img src="https://img-blog.csdnimg.cn/20200416235545673.png" alt="在这里插入图片描述">看来卡时间卡的太紧了（笑哭）</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>Recordering the Cows</title>
    <url>/2020/04/01/Recordering-the-Cows/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4860/B" target="_blank" rel="noopener">牛客网传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>Farmer John’s N cows (1 &lt;= N &lt;= 100), conveniently numbered 1..N, are<br>standing in a row. Their ordering is described by an array A, where<br>A(i) is the number of the cow in position i. Farmer John wants to<br>rearrange them into a different ordering for a group photo, described<br>by an array B, where B(i) is the number of the cow that should end up<br>in position i.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>For example, suppose the cows start out ordered as follows:</p>
<p>A = 5 1 4 2 3</p>
<p>and suppose Farmer John would like them instead to be ordered like<br>this:</p>
<p>B = 2 5 3 1 4</p>
<p>To re-arrange themselves from the “A” ordering to the “B” ordering,<br>the cows perform a number of “cyclic” shifts. Each of these cyclic<br>shifts begins with a cow moving to her proper location in the “B”<br>ordering, displacing another cow, who then moves to her proper<br>location, displacing another cow, and so on, until eventually a cow<br>ends up in the position initially occupied by the first cow on the<br>cycle. For example, in the ordering above, if we start a cycle with<br>cow 5, then cow 5 would move to position 2, displacing cow 1, who<br>moves to position 4, displacing cow 2, who moves to position 1, ending<br>the cycle. The cows keep performing cyclic shifts until every cow<br>eventually ends up in her proper location in the “B” ordering. Observe<br>that each cow participates in exactly one cyclic shift, unless she<br>occupies the same position in the “A” and “B” orderings.</p>
<p>Please compute the number of different cyclic shifts, as well as the<br>length of the longest cyclic shift, as the cows rearrange themselves.</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<ul>
<li><p>Line 1: The integer N.</p>
</li>
<li><p>Lines 2..1+N: Line i+1 contains the integer A(i).</p>
</li>
<li><p>Lines 2+N..1+2N: Line 1+N+i contains the integer B(i)</p>
</li>
</ul>
</blockquote>
<p>输出描述:</p>
<blockquote>
<ul>
<li>Line 1: Two space-separated integers, the first giving the number of cyclic shifts and the second giving the number cows involved in the<br>longest such shift.  If there are no cyclic shifts, output -1 for the<br>second number.</li>
</ul>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>题意：</strong><br>比如样例：通过移动A，将A=B<br>A     5 1 4 2 3<br>B   2 5 3 1 4<br>id   1 2 3 4 5<br>首先A中5要到1的位置（id=2），然后1移动到2的位置上（id=4），2要移动到5的位置上上（id=1）就是一个环，5-&gt;1-&gt;2-&gt;5，移动次数为3（也就是环的长度），除此之外还有4-&gt;3-&gt;4,移动次数为2，问将A通过移动转化成B的过程中，最长移动次数（即最长的环）是多少？环的数量是多少？<br><strong>题解：</strong><br><strong>（第一二个代码讲述的是我做错的过程，正解在是第三个）</strong><br><del>这题是我难以忘记的痛o(╥﹏╥)o</del><br><img src="https://img-blog.csdnimg.cn/20200330140321589.png" alt="在这里插入图片描述">看完这个题第一反应是noip考过的信息传递，所以一开始就用并查集来做，father[A[id]]=B[id]（就是id相对于A的父亲节点是B），因为一定能成环，所以就找一共多少个环，并求出最长环的长度<br>然而。。。。<img src="https://img-blog.csdnimg.cn/20200330140749959.png" alt="在这里插入图片描述"><br>我调了一阵子也但还是段错误，我换了个oj测评一下，然后就就AC了。。。玄学（<del>可能这个oj数据弱</del> ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">int b[194000];</span><br><span class="line">int father[10003];</span><br><span class="line">bool f[100004];</span><br><span class="line">int maxx=0;</span><br><span class="line">void unionn(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    father[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x,int z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;//如果这个数在A中与B中位置相同，不需要交换</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;//如果这个数曾经被查询过</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;//如果这个环第一次被查询</span><br><span class="line">    z++;//z只有0和非0，来表示这个数之前是否被查询过</span><br><span class="line">    f[x]=1;</span><br><span class="line">    maxx=max(maxx,z);</span><br><span class="line">    find(father[x],z);//不断地向后查找5-&gt;1-&gt;2</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">        unionn(a[j],b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i,0))ant++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我痛定思痛，感觉是因为自身递归导致段错误，又改了一个思路，在寻找根节点并压缩路径的时候，顺便用dis来记录路径的长度，然后统计出最长的路径。<br>结果没段错误，但。。。wa了。。唉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">bool f[10034];//标记这个点所在的环是否被查询过</span><br><span class="line">int dis[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//  father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        int last=father[x];</span><br><span class="line">        father[x]=find(father[x]);</span><br><span class="line">        dis[x]+=dis[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line">void unionn(int aa,int bb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">    int x=find(aa);</span><br><span class="line">    int y=find(bb);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        father[x]=y;</span><br><span class="line">        dis[aa]=dis[bb]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);//更新最长边</span><br><span class="line">&#125;</span><br><span class="line">//int find(int x,int z)</span><br><span class="line">//&#123;</span><br><span class="line">//  <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;</span><br><span class="line">//  z++;</span><br><span class="line">//  f[x]=1;</span><br><span class="line">//  maxx=max(maxx,z);</span><br><span class="line">//  find(father[x],z);</span><br><span class="line">//&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">        <span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;//多少个环</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        unionn(a[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ant++;</span><br><span class="line">            f[father[i]]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我冷静一会后，重新思考，感觉把题越想越复杂了<br>样例：<br>A 5 1 4 2 3<br>B 2 5 3 1 4<br>f[]来标记id是否被查询过<br>我们用fa和fb来记录A和B中数的id位置，然后在union时,通过father[]来让 A中的点对应B的位置相互指向，A中id=1的5指向id=2的1，father[5]=1,依次类推<br>A    ——-&gt;5 1 4 2 3<br>fa——-&gt;2 4 5 3 1<br>B——–&gt;2 5 3 1 4<br>fb——–&gt;4 1 3 5 2<br>father—&gt;2 4 5 1 3<br>在查找时for(i-&gt;n),查询该点i后，接着查与这点i相连的点father[i]，并用f[]标记，ans记录长度，如果相连的点&gt;2(也就是这个点不是指向自己)，统计最长环长，并记录换的数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">int fa[10034];</span><br><span class="line">int fb[10034];</span><br><span class="line">int f[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">int ans;</span><br><span class="line">int id;</span><br><span class="line">int tot=0;</span><br><span class="line">int w=0;</span><br><span class="line">int find()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]==0)</span><br><span class="line">		&#123;</span><br><span class="line">			id=i;</span><br><span class="line">			ans=0;</span><br><span class="line">			<span class="keyword">while</span>(f[id]==0)</span><br><span class="line">			&#123;</span><br><span class="line">				f[id]=1;</span><br><span class="line">				ans++;</span><br><span class="line">				id=father[id];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;1)</span><br><span class="line">			&#123;</span><br><span class="line">				tot=max(ans,tot);</span><br><span class="line">				w++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(n)</span><br><span class="line">		&#123;</span><br><span class="line">					fa[a[i]]=i;	</span><br><span class="line">					fb[b[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init1()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">for</span>(n)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			father[fa[a[i]]]=fb[a[i]];</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//	father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">//void unionn(int aa,int bb)</span><br><span class="line">//&#123;</span><br><span class="line">//	<span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">//	int x=find(aa);</span><br><span class="line">//	int y=find(bb);</span><br><span class="line">//	<span class="keyword">if</span>(x!=y)</span><br><span class="line">//	&#123;</span><br><span class="line">//		father[x]=y;</span><br><span class="line">//		dis[aa]=dis[bb]+1;</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);</span><br><span class="line">//&#125;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		<span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">//		<span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">if</span>(tot==0)</span><br><span class="line">//	&#123;</span><br><span class="line">//		cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">//		<span class="built_in">return</span> 0;</span><br><span class="line">//	&#125;</span><br><span class="line">//	int ant=0;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		</span><br><span class="line">//		unionn(a[i],b[i]);</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		<span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">//		&#123;</span><br><span class="line">//			ant++;</span><br><span class="line">//			f[father[i]]=1;</span><br><span class="line">//		&#125;</span><br><span class="line">//	&#125;</span><br><span class="line">//	cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line">	init1();</span><br><span class="line">	<span class="keyword">if</span>(find()==0)cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;w&lt;&lt;<span class="string">" "</span>&lt;&lt;tot;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于做出来了。。。我太菜了o(╥﹏╥)o</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】4月6日数码</title>
    <url>/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<p>题目：<a href="https://ac.nowcoder.com/acm/problem/13221" target="_blank" rel="noopener">数码</a><br>来源：<a href="https://ac.nowcoder.com/acm/contest/5#description" target="_blank" rel="noopener">美团2017年CodeM大赛-资格赛</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x<br>的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 </p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>一行，两个整数 l 和 r (1 ≤ l ≤ r ≤ 10^9^)。</p>
</blockquote>
<p>输出描述:</p>
<p>输出9行。</p>
<blockquote>
<p>第 i 行，输出数码 i 出现的次数。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>题解：<br>先介绍一个函数：<br>solve（a，b）就是从1<del>a中数码b的倍数出现的次数<br>solve(a,b)=a/b<br>那么求[l,r]的话，就用solve(r,b)-solve(l-1,b)，大致可以理解成前缀和那种<br>num就是0</del>9，计算每个num对应的区间<br>最高位是1的话：1,10 ~ 19,100 ~ 199， 1000 ~ 1999….<br>最高位是2的话：2,20 ~ 29,200 ~ 299， 2000 ~ 2999….</p>
<p>因为我们只记录约数的最高位，像1999，约数就是1和1999，我们只记录最高位，那么就是有两个1<br>那么我们枚举以num开头的数，计算它的倍数在[l,r]中出现的次数。<br>按照几位数和最高位是几进行枚举，有多少这样的数直接统计就ok<br>solve(r,num)-solve(l-1,num)<br>枚举num的值<br>让最高位等于x时num枚举相对应的区间（从x<em>10^y-1^~(x+1)</em>10^y-1^-1）y=1.2.3….<br>有部分数会被算重复，因为有完全平方数存在，<br>再运用整除分块技巧，让复杂度降到O(根号n)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">ll minn(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;=b)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">return</span> b;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">	//	cout&lt;&lt;a;</span><br><span class="line">	 <span class="built_in">return</span> a;</span><br><span class="line">	 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll a, ll b) &#123;</span><br><span class="line">  ll res = 0;</span><br><span class="line">   ll beg;</span><br><span class="line">   ll end;</span><br><span class="line">  <span class="keyword">for</span> (ll i = 1; i &lt;= a / b; i *= 10) &#123;</span><br><span class="line">    beg = b * i;//区间开头</span><br><span class="line">    </span><br><span class="line">	 end = minn(a, beg + i - 1);//区间结尾</span><br><span class="line">	 int k;</span><br><span class="line">    <span class="keyword">for</span> (int j = beg; j &lt;= end; j = k + 1) &#123;</span><br><span class="line">      k = min(a / (a / j), end);</span><br><span class="line">      //cout&lt;&lt;a/(a/i)&lt;&lt;<span class="string">" "</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">      res += (k - j + 1) * (a / j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll l,r;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">   cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=9;i++)&#123;</span><br><span class="line">        cout&lt;&lt;solve(r,i)-solve(l-1,i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/C" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>多次查询[l,r]范围内的完全平方数个数</p>
<p>定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x</p>
</blockquote>
<a id="more"></a> 
<p>输入描述:</p>
<blockquote>
<p>第一行一个数n表示查询次数 之后n行每行两个数l,r 输出描述: 对于每个查询，输出一个数表示答案</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1000000000</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>31622<br>备注:<br>n &lt;= 100000<br>0&lt;= l &lt;= r &lt;= 1000000000</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>签到题<br>l,r直接开方，注意l开方后向上取整。<br>r1-l1+1就是答案</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000005</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">int</span> l1=<span class="built_in">sqrt</span>(l);</span><br><span class="line">		<span class="keyword">int</span> r1=<span class="built_in">sqrt</span>(r);</span><br><span class="line">		<span class="keyword">if</span>(l1*l1!=l)l1++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r1-l1+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间处理</tag>
      </tags>
  </entry>
  <entry>
    <title>序列自动机</title>
    <url>/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/</url>
    <content><![CDATA[<p>题目：<br>给你a和b两个字符串，问b是不是a的子序列？</p>
<ul>
<li>题解：<br><a href="https://ac.nowcoder.com/discuss/396686" target="_blank" rel="noopener">参考题解</a><br>注意看，子序列不是子串，两者含义不一样</li>
</ul>
<blockquote>
<p>一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S<br>通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。</p>
</blockquote>
<a id="more"></a>
<p>可以理解成：abc是abcd的子串，abc是adbewc的子序列，而非子串<br>求子串可以用kmp<br>那求子序列就用今天要讲的序列自动机<br>字符串A：abcdefgh<br>字符串B：aez<br>当a匹配过后，再去枚举后面的bcd没有意义，因为我们要找的是A中是否要aez三个字符，并且是这样的顺序，无须是连着的。如果我们能在a之后直接跳到a后面的一个e，再跳到e后面第一个z，等到子串B遍历完，或者在a中找不到了，我们就可以结束啦。<br>注意：我们在往后跳找字母时，比如a后面有很多个e，那么我们选第一个，因为如果第一个不行的话，那第二个第三个也白瞎，我们选的越往前其实选择空间就越大<br>仔细想想怎么能实现跳跃查找这个呢：<br>开个数组next[i][j]表示主串第i个字母之后的第一个‘a’+j的坐标，<br>next的维护只需要从后向前扫描主串，到第i位时维护一个数组last[j]，j表示对应的‘a’~‘z’，last反映的是最靠前的字母j在哪里，然后把值赋给next就ok了<br>这样查找时顺着走就可以了<br>每次匹配B复杂度是O（|B|），<br>总复杂度O(26|A|+|B|)，因为A要用26个字母都循环一遍所以是26|A|<br>可以通过下图理解<br><img src="https://img-blog.csdnimg.cn/20200402131626533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6 + 10;</span><br><span class="line">int n, t, next[maxn][30];</span><br><span class="line">char s[maxn], str[maxn];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	scanf(<span class="string">"%s"</span>, s+1);</span><br><span class="line">	int len = strlen(s+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=len; i; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=0; j&lt;26; j++) </span><br><span class="line">		&#123;</span><br><span class="line">		next[i-1][j] = next[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		next[i-1][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		scanf(<span class="string">"%s"</span>, str);</span><br><span class="line">		int lenc = strlen(str), f = 0;</span><br><span class="line">		int now=0;</span><br><span class="line">		<span class="keyword">for</span>(int i=0; i&lt;lenc; i++)&#123;</span><br><span class="line">			now = next[now][str[i]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(!now) &#123;</span><br><span class="line">				f = 1;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f) puts(<span class="string">"No"</span>);</span><br><span class="line">		<span class="keyword">else</span> puts(<span class="string">"Yes"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(模板)</title>
    <url>/2020/04/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>@[TOC]<br>昨天做蓝桥杯的题，最后一题最小生成树，但好久没用一下子生疏了。。。<br>最小生成树两种方法：<br>Prim和Kruskal</p>
<h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2><p>prim:该算法的时间复杂度为O(n2)。与图中边数无关，该算法适合于稠密图。</p>
<p>kruskal:需要对图的边进行访问，所以克鲁斯卡尔算法的时间复杂度只和边又关系，可以证明其时间复杂度为O（eloge）。适合稀疏图。</p>
<a id="more"></a>
<p> <strong>模板：</strong></p>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,u,v,total;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start,to;<span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">&#125;bian[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//并查集部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x]==x) <span class="keyword">return</span> x; </span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">return</span> find(f[x]);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span><span class="comment">//结构体快排时用到的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span><span class="comment">//最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=find(bian[i].start);</span><br><span class="line">        v=find(bian[i].to);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;<span class="comment">//判断在不在同一个并查集里面，在就下一个循环</span></span><br><span class="line">            ans+=bian[i].val;<span class="comment">//不在，就加上</span></span><br><span class="line">            f[u]=v;<span class="comment">//连接两个并查集</span></span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span>(total==n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//当形成了最小生成树后，退出（之后做的也没用了）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;bian[i].start,&amp;bian[i].to,&amp;bian[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(bian+<span class="number">1</span>,bian+m+<span class="number">1</span>,cmp);<span class="comment">//快排边长</span></span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;<span class="comment">//快读，不理解的同学用cin代替即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 123456789</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//注意是无向图，开两倍数组</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn],cnt,n,m,tot,now=<span class="number">1</span>,ans;</span><br><span class="line"><span class="comment">//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1-&gt;3,2-&gt;3)</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//链式前向星加边</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v=v;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read(),v=read(),w=read();</span><br><span class="line">        add(u,v,w),add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先把dis数组附为极大值</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意重边，所以要用到min</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[<span class="number">1</span>];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[e[i].v]=min(dis[e[i].v],e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)<span class="comment">//最小生成树边数等于点数-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        re <span class="keyword">int</span> minn=inf;<span class="comment">//把minn置为极大值</span></span><br><span class="line">        vis[now]=<span class="number">1</span>;<span class="comment">//标记点已经走过</span></span><br><span class="line">        <span class="comment">//枚举每一个没有使用的点</span></span><br><span class="line">        <span class="comment">//找出最小值作为新边</span></span><br><span class="line">        <span class="comment">//注意这里不是枚举now点的所有连边，而是1~n</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="comment">//枚举now的所有连边，更新dis数组</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            re <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;e[i].w&amp;&amp;!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=e[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,prim());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>小H和游戏</title>
    <url>/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/D" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit<br>IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<pre><code>小H正在玩一个战略类游戏，她可以操纵己方的飞机对敌国的N座城市(编号为1~N)进行轰炸
敌国的城市形成了一棵树，小H会依次进行Q次轰炸，每次会选择一个城市A进行轰炸，和这座城市距离不超过2的城市都会受损(这里距离的定义是两点最短路径上的边数)，轰炸结束后，小H还想知道当前城市A受损的次数
作为游戏的开发者之一，你有义务回答小H的问题 </code></pre></blockquote>
<a id="more"></a> 
<p>  输入描述:</p>
<blockquote>
<p>第1行，两个整数N(1≤N≤750000)、Q(1≤Q≤750000) 第2<del>N行，每行两个整数表示树上的一条边<br>第N+1</del>N+Q行，每行一个整数，表示小H这次轰炸的城市 </p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p> 输出Q行，每行一个整数表示这一次轰炸的城市在此次轰炸后共计受损几次</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始以为一个城市被轰炸后还在。。。发现并不是<br>我们来分析一个点被轰炸，哪些点会受到牵连<br><img src="https://img-blog.csdnimg.cn/20200417122447514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中点1被轰炸，1的父亲的父亲，儿子的儿子还有兄弟（父亲的儿子）这些点会受损，同理这些点被轰炸，1也会被受损。</p>
<p>fa[]表示父子关系<br>我们可以用二维数组表示dp[i][j]来表示i节点攻击范围<br>j = 1 为结点i被轰炸的次数<br>j = 2 结点i的子结点被轰炸的次数<br>j = 3 结点i的子结点的子结点被轰炸的次数<br>而每个节点的父亲节点只有一个，我们可以用fa[x]来实现，而儿子节点可以有多个我们通过二维数组来实现。</p>
<p>总结图中节点x被轰炸的情况;<br>1.本身被轰炸 dp[x][1]<br>2.子节点被轰炸 dp[x][2]<br>3.子节点的子节点被轰炸 dp[x][3]<br>4.父亲节点被轰炸 dp[fa[x]][1]<br>5.父亲的父亲节点被轰炸 dp [ fa [ fa [ x ] ] ] [ 1 ]<br>6.兄弟节点被轰炸 dp[fa [ x ] ] [ 2 ] - dp [x ] <a href="第一个dp求出来的还包含x本身，去掉x的情况就是x的兄弟情况"> 1 </a></p>
<p>维护好这些，这样我们就可轻松进行查询<br>当x被轰炸时,就让上面6种情况++,注意第六种情况和第一种情况可以合并，所以这两个合成一个 dp[fa [ x ] ] [ 2 ]++就行。<br>最后输出距离x距离为0，1,2的点<br>距离为0即本身 dp[x][1]<br>距离为1 dp[fa[x]][2]<br>距离为2 dp [ fa [ fa [ x ] ] ]  [ 3 ]<br>加起来就是x的答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">750003</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,fa[maxn],dp[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:edge[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=f)</span><br><span class="line">        dfs(v,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> u,v,x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dp[fa[x]][<span class="number">2</span>]++;<span class="comment">//父亲的儿子，情况1和6</span></span><br><span class="line">    dp[fa[x]][<span class="number">1</span>]++;<span class="comment">//父亲本身 情况4</span></span><br><span class="line">    dp [ fa [ fa [ x ] ] ] [ <span class="number">1</span> ] ++;<span class="comment">//父亲的父亲 情况5</span></span><br><span class="line">    dp [ x ] [ <span class="number">2</span> ] ++;<span class="comment">//儿子 情况2</span></span><br><span class="line">    dp [ x ] [ <span class="number">3</span> ] ++;<span class="comment">//儿子的儿子 情况3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[x][<span class="number">1</span>]+dp[fa[x]][<span class="number">2</span>]+dp[fa[fa[x]]][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2008]仪仗队</title>
    <url>/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20313" target="_blank" rel="noopener">牛客网</a><br>题目描述</p>
<blockquote>
<p>作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *<br>N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200409214206553.png" alt="在这里插入图片描述"><br>  <a id="more"></a><br>现在，C君希望你告诉他队伍整齐时能看到的学生人数。<br>输入描述:</p>
<p>共一个数N。</p>
<p>输出描述:</p>
<p>共一个数，即C君应看到的学生人数。</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>题解：<br>无限接近裸的欧拉函数<br>可以自己画图看看<br><img src="https://img-blog.csdnimg.cn/20200409214430241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我来解释下我这个图，我把n=4和5画在了一起，紫色区域是4<em>4区域，红色区域（也是整个区域）是5</em>5，左上角围成一个三角形区域，我们暂时不考虑对角线上的情况（因为对角线只能看见一个，后面的都被挡住了）。<br>左下角坐标是（0,0），我们发现能看的坐标（x，y），x与y为互质，如果不是互质，就一定会被挡住，（比如（2,4）会被（1,2）挡住，而1与2互质，（1,2）就不会被挡住）<br>我们用ans记录三角区域的情况数<br>就是ans=每行的情况加一起<br>那每行有多少种，可以用欧拉函数求<br>欧拉函数的ϕ(x)表示小于x的且与x互质的数有多少个<br>ϕ(3)=2（与3互质的有1和2，一共有两个）<br>特别注意ϕ(1)=1<br>公式法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="comment">// 直接求3</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Euler</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">  	 <span class="keyword">long</span> <span class="keyword">long</span> res = n;</span><br><span class="line">	 <span class="keyword">for</span>( <span class="keyword">long</span> <span class="keyword">long</span> i =<span class="number">2</span> ;i*i&lt;=n;i++)&#123;</span><br><span class="line">	 	<span class="keyword">if</span>( n %i == <span class="number">0</span> )&#123;</span><br><span class="line">			n/=i;</span><br><span class="line">			res = res - res/i;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="keyword">while</span>( n % i==<span class="number">0</span>)</span><br><span class="line">		 n/=i;</span><br><span class="line">	 &#125;</span><br><span class="line">     <span class="keyword">if</span>( n &gt; <span class="number">1</span> )</span><br><span class="line">	     res = res - res/n;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += Euler(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>筛法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(!phi[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    get_phi(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += phi[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>记录下欧拉函数的模板：<br>筛法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特性 :</span></span><br><span class="line"><span class="comment">1.若a为质数,phi[a]=a-1;</span></span><br><span class="line"><span class="comment">2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a</span></span><br><span class="line"><span class="comment">3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> m[n],phi[n],p[n],nump;</span><br><span class="line"><span class="comment">//m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m[i])<span class="comment">//i为素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[++nump]=i;<span class="comment">//将i加入素数数组p中</span></span><br><span class="line">            phi[i]=i<span class="number">-1</span>;<span class="comment">//因为i是素数,由特性得知    </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nump&amp;&amp;p[j]*i&lt;n;j++)  <span class="comment">//用当前已的到的素数数组p筛,筛去p[j]*i</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[p[j]*i]=<span class="number">1</span>;<span class="comment">//可以确定i*p[j]不是素数 </span></span><br><span class="line">            <span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="comment">//看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 </span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[p[j]*i]=phi[i]*p[j]; <span class="comment">//特性2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[p[j]*i]=phi[i]*(p[j]<span class="number">-1</span>); <span class="comment">//互质,特性3其,p[j]-1就是phi[p[j]]   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eular</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n/=i,ret*=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,ret*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ret*=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N + <span class="number">0.5</span>), ans = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(N % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(N &gt; <span class="number">1</span>) ans = ans / N * (N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>使用一段时间牛客网的心得</title>
    <url>/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（<del>心痛</del> ）<br>牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉<br>一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。<br>等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200414000658411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414000643124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>背包等着我<del>~</del></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列</title>
    <url>/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18203" target="_blank" rel="noopener">牛客网题目</a><br>题目描述</p>
<blockquote>
<p>给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示</p>
<p>接下来一行N个整数，表示给出的序列</p>
<p>保证序列内的数互不相同</p>
</blockquote>
<a id="more"></a>
<p>输出描述:</p>
<blockquote>
<p>对于每组数据，输出一个整数表示答案，对10^9^ + 7 取模 每组数据之间以换行分割</p>
</blockquote>
<p> 示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span> </span><br><span class="line"><span class="number">100</span> <span class="number">1020</span> <span class="number">2050</span> <span class="number">102</span> <span class="number">12</span> <span class="number">235</span> <span class="number">4</span> <span class="number">57</span> <span class="number">32135</span> <span class="number">54354</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">81000</span></span><br><span class="line"><span class="number">521918013</span></span><br></pre></td></tr></table></figure>

<p>说明：<br>第一组数据解释<br>所有长度为3的子序列为 (5,3,1) (5,3,4) (3,1,4) (5,1,4)<br>最终答案为3∗4∗3∗4=1443<br><img src="https://img-blog.csdnimg.cn/20200409222358794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">题解：<br>对于子序列一个数a，a会以三种形式存在<br>1.最大值<br>2.最小值<br>3.中间值<br>我们现将序列从小到大排序（从0开始），并不影响结果，但是有利于计算<br> a在长度为 k 的子序列中出现的次数为 C^k−1^<del>n−1</del>(因为如果它出现在子序列中，那么总数还有 n−1 个 数字，序列的长度还有 k−1 个)<br>对于第一种情况，a作为最大值的下表为i，a之前的i个数都比a小，所选出的子序列一定有以下标i为结尾的，我们需要从前i个中选出k-1个，组成长度为k的子序列，个数为C^k-1^<del>i</del>(组合数）<br>同理：ai 是最小值的情况的方法数为 C^k−1^<del>n−i−1</del><br>pi=C^k−1^<del>n−1</del>−C^k−1^<del>i</del>−C^k−1^<del>n−i−1</del> 对于 ai这个数来说，它对答案的贡献为 a^pi^<del>i</del><br>最终的答案为 ：ans=∏^n−1^<del>i=0</del>a^pi^<del>i</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function">LL <span class="title">Pow</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL c[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % (MOD<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a, a+n);</span><br><span class="line">        LL tmp = c[n<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL b = tmp-c[i][k<span class="number">-1</span>]-c[n-i<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">            b = (b%(MOD<span class="number">-1</span>)+(MOD<span class="number">-1</span>))%(MOD<span class="number">-1</span>);</span><br><span class="line">            ans = ans*Pow(a[i], b)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为那个是指数，比如说 a^b^%p，可以用费马小定理 a^(b%(p-1))^ % p</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>欧拉函数</tag>
        <tag>数论</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>水题(water)（非详细解答）</title>
    <url>/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5203/E" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述<br><img src="https://img-blog.csdnimg.cn/20200417185530435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a> 
<blockquote>
<p>其中，f(1)=1;f(2)=1;Z皇后的方案数：即在Z×Z的棋盘上放置Z个皇后，使其互不攻击的方案数。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>输入数据共一行，两个正整数x,m，意义如“题目描述”。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一个正整数k，表示输出结尾0 的个数或者放置皇后的方案数</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">375</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14200</span></span><br></pre></td></tr></table></figure>

<p>说明<br><img src="https://img-blog.csdnimg.cn/20200417185538216.png" alt="在这里插入图片描述"><br>题解：<br>看了一阵子没明白，也是从其他人那学完之后，自己总结着再写<br>这个题内含三个小题：<br>1.判断是否存在k使得f(k)=xf(k)=x<br>2.n!在m进制下末尾零的个数<br>3.Z皇后方案数<br>解答：（非详细）<br>1.F函数其实就是斐波那契数列</p>
<p>斐波那契数列平方和的性质：（就是题目中所给公式）<br><img src="https://img-blog.csdnimg.cn/20200417185913695.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fi[<span class="number">1</span>] = <span class="number">1</span>, fi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;; ++i) &#123;</span><br><span class="line">    fi[i] = fi[i - <span class="number">1</span>] + fi[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (fi[i] &gt; <span class="number">1e18</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2.求n!在m进制的末尾0个数</p>
<p>首先一个结论：n!的质因子p的个数等于：1~n中p的倍数(n/p)加上(n/p)!中质因子p的个数</p>
<p>然后：<br>写出<br>将数W转化成m进制的末尾0的个数<br>的暴力代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(W%m==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	W/m;</span><br><span class="line">&#125;<span class="comment">//tot计数</span></span><br></pre></td></tr></table></figure>
<p>可以得到 W=a * m^tot^（n是m^tot^的倍数）</p>
<p>末尾几个0，tot就是几（tot是记录末尾0<br>的数量）</p>
<p>我们看 n ! 最多可以分解出多少个m<br>质因数 pi<br>设m=p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^<br>W = n!<br> n！= a  *  m ^tot^<br>n！=a * （p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^）^tot^</p>
<p>n!=a * p<del>1</del>^b1^ <em>p<del>2</del>^b2^ *….</em>p<del>k</del>^bk^</p>
<p>b<del>k</del>=a<del>k</del> *tot</p>
<p>求出！x最多可以分解出多少个p<del>i</del></p>
<p>tot=min(b<del>k</del>/a<del>k</del>)<br>枚举k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll prime[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=n/m;</span><br><span class="line">        n/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="comment">//n!的质因子p的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ans_solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1e18</span>+<span class="number">3</span>;</span><br><span class="line">	M=m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; prime[i] &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (M % prime[i] == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			++ans1[prime[i]];</span><br><span class="line">			M /= prime[i];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">		&#123;</span><br><span class="line">            ans2[prime[i]]=getsum(x,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">        ans=min(ans,ans2[prime[i]]/ans1[prime[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.求z皇后方案数<br>z=x%min(13,m)+1<br>根据式子就能得到z的范围在1~13，范围不大直接打表就可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dabiao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  z[<span class="number">1</span>]=<span class="number">1</span>;z[<span class="number">2</span>]=<span class="number">0</span>;z[<span class="number">3</span>]=<span class="number">0</span>;z[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">      z[<span class="number">5</span>]=<span class="number">10</span>;z[<span class="number">6</span>]=<span class="number">4</span>;z[<span class="number">7</span>]=<span class="number">40</span>;z[<span class="number">8</span>]=<span class="number">92</span>;</span><br><span class="line">      z[<span class="number">9</span>]=<span class="number">352</span>;z[<span class="number">10</span>]=<span class="number">724</span>;z[<span class="number">11</span>]=<span class="number">2680</span>;</span><br><span class="line">	  z[<span class="number">12</span>]=<span class="number">14200</span>;z[<span class="number">13</span>]=<span class="number">73712</span>;</span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; z[x%min(<span class="number">13</span>*<span class="number">1l</span>l,k)+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈LCA</title>
    <url>/2020/04/12/%E6%B5%85%E8%B0%88LCA/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="LCA介绍"><a href="#LCA介绍" class="headerlink" title="LCA介绍"></a>LCA介绍</h2><p>lca是啥？最近公共祖先<br>就是：两个点在这棵树上距离最近的公共祖先节点<br>LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）<br>来看一个经典图<br><img src="https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p>LCA（4,5）=2<br>LCA（4,3）=1<br>LCA（2,1）=1</p>
<h2 id="解决方法概括："><a href="#解决方法概括：" class="headerlink" title="解决方法概括："></a>解决方法概括：</h2><p>常用四种方法 ：</p>
<ol>
<li>用倍增法求解，预处理复杂度是 O(nlogn) ,每次询问的复杂度是 O(logn), 属于在线解法。</li>
<li>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)，每次询问的复杂度为 O(1)，也是在线算法。</li>
<li>采用Tarjan算法求解，复杂度 O(α(n)+Q)，属于离线算法。</li>
<li>利用树链剖分求解，复杂度预处理O(n)，单次查询 O(logn) ，属于在线算法。</li>
</ol>
<h2 id="倍增法："><a href="#倍增法：" class="headerlink" title="倍增法："></a>倍增法：</h2>]]></content>
      <categories>
        <category>算法讲解</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>清明追思家国永念</title>
    <url>/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/</url>
    <content><![CDATA[<p>我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行<img src="https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p>本来想睡觉，企鹅群不小心看见一些发言气醒了。</p>
<p>4月4日默哀是形式主义?</p>
<p>你知道什么是形式主义吗?这种公共活动都是形式主义?死去的同胞、牺牲的医护都配不上，那谁还配得上这样的国礼?这算哪门子形式?</p>
<p>你可以说，我觉得宣传口的工作不够到位;你也可以说，我觉得现在才发布通知过于仓促;你还可以说，禁止的范围有待商榷。</p>
<p>无动于衷不是罪过，没有感同身受不是罪过，做不到泪流满面不是罪过，私下继续娱乐活动也不是罪过。你可以不爱听歌功颂德的文本，可以用自己的方式怀缅，可以用其他途径玩得.昏天黑地。</p>
<p>娱乐至死的时代，只有无聊才让人如临大敌，都懂。</p>
<p>做了不代表尊重，没做也不代表不尊重。</p>
<p>没有卫兵站在你家里用枪抵着你的后脑勺让你哭天抢地，没有条子叔叔把看电视打游戏听音乐的人逮起来，也没有人让你排着长队对着什么东西跪地哀嚎。事实上，没有人强迫你。只是有一点，自身的态度和对外界的要求要-致。若是不以流程怀念，就不要对着默哀的人喊你们是一群被形式主义迫害的粉红，缄默到底。若是以流程怀缅，也不必逼迫他人做超出公报内容的事，真挚只能自发。</p>
<p>你可以不立正，可以不起床。但是在鸣笛的那几分钟里，你必须清楚，你还活着，没有失去年长的亲人、远方的朋友是因为谁。你也得清楚，这样的祭奠，那些人配得上。<br>———转载<br><img src="https://img-blog.csdnimg.cn/20200404230406288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200404230410721.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客每日一题3.31 城市网络</title>
    <url>/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13331" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<blockquote>
<p>题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。<br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v<br>），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行，两个正整数 n , q (2 ≤ n ≤ 10^5^ , 1 ≤ q ≤ 10^5^)。 第二行，n 个正整数 a_i (1 ≤<br>a_i ≤ 10^5) 描述每个城市售卖的珠宝的价值。 接下来 n-1 行，每行描述一条道路 x , y (1 ≤ x,y ≤<br>n)，表示有一条连接 x 和 y 的道路。 接下来 q 行，每行描述一次行程 u , v , c (1 ≤ u,v ≤ n , 1 ≤ c<br>≤ 10^5^)。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>对于每次行程输出一行，为所购买次数。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">3 5 1 2 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 2 1</span><br><span class="line">4 2 2</span><br><span class="line">4 2 3</span><br><span class="line">5 1 5</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>题解:<br>毋庸置疑就是用倍增来做<br>那什么是倍增呢？<br>（先挖个坑，有空做个倍增的讲解）<br>递推式fa[i][j] = fa[fa[i][j-1]][j - 1],只要倍增得到fa[i][0]就行，因为有了这个后面都可以推出<br>fa[i][j] 代表i节点往上走2^j的距离，且比当前大的点<br>每次查询时，在所有需要问的点加一条新点，连在u的下方，新点的权值就是询问的初始权值，从这个新点往上倍增就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">const int maxn=2e5+2;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int fa[maxn][23];</span><br><span class="line">int n,q;</span><br><span class="line">int to[maxn];</span><br><span class="line">vector&lt;int&gt; W[2*maxn];</span><br><span class="line">void dfs(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">	int pos=f;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i=21;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[pos][i]&amp;&amp;a[fa[pos][i]]&lt;=a[u])</span><br><span class="line">		pos=fa[pos][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[pos]&gt;a[u])fa[u][0]=f;</span><br><span class="line">	<span class="keyword">else</span> fa[u][0]=fa[pos][0];</span><br><span class="line">	<span class="keyword">for</span>(int i=1;fa[fa[u][i-1]][i-1];i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[u][i]=fa[fa[u][i-1]][i-1];</span><br><span class="line">	&#125;</span><br><span class="line">		dis[u]=dis[f]+1;</span><br><span class="line">	<span class="keyword">for</span>(int v=0;v&lt;W[u].size();v++)</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(W[u][v]==f)<span class="built_in">continue</span>;</span><br><span class="line">		dfs(W[u][v],u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int a;</span><br><span class="line">	  int b;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        W[a].push_back(b);</span><br><span class="line">        W[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i =1; i &lt;= q ; ++i)&#123;//增加新点</span><br><span class="line">        int aa,b,c;</span><br><span class="line">        scanf(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;b,&amp;c);</span><br><span class="line">        W[n+i].push_back(aa);</span><br><span class="line">        W[aa].push_back(i+n);</span><br><span class="line">        a[n+i] = c;</span><br><span class="line">        to[n+i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">   int sum = 0; </span><br><span class="line">   int pos;</span><br><span class="line">    <span class="keyword">for</span>(int i = n+1; i &lt;= n+q; ++i)&#123;</span><br><span class="line">       pos=i;</span><br><span class="line">      sum=0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 21; j &gt;= 0; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[fa[pos][j]] &gt;= dis[to[i]]) &#123;</span><br><span class="line">                sum += (1 &lt;&lt; j);</span><br><span class="line">				pos= fa[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 32768K  其他语言 65536K<br> 64bit IO Format:%lld</p>
<p><a href="https://ac.nowcoder.com/acm/problem/50528" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">洛谷</a><br> <strong>题目描述</strong><br>给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：</p>
</blockquote>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200329120250163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>你的任务是找出窗体在各个位置时的最大值和最小值。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第1行：两个整数N和K； 第2行：N个整数，表示数组的N个元素(≤2×10^9^)；</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>第一行为滑动窗口从左向右移动到每个位置时的最小值，每个数之间用一个空格分开；<br>第二行为滑动窗口从左向右移动到每个位置时的最大值，每个数之间用一个空格分开。</p>
</blockquote>
<p>示例1<br>输入<br>8 3<br>1 3 -1 -3 5 3 6 7<br>输出<br>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7<br>备注:<br>对于20%的数据，K≤N≤1000；<br>对于50%的数据，K≤N≤10^5^<br>对于100%的数据，K≤N≤10^6^<br><strong>题解：</strong><br>老题了。。<br>（<del>想起来我当年逝去的OI梦</del> ）</p>
<p>赶紧从洛谷找到以前的代码<br>就是单调队列的模板题<br><del>手写就完事了</del> </p>
<p>构造一个单调队列，<br>我们来模拟下过程：<br>（以求最小为例）<br>head指向头，tail指向尾<br>a[]是我们一开始存放的数<br>mi存放的是最小值的坐标（即 i ）<br>i是指向数组a当前位置<br>m=3<br>例如 1 3 -1<br>坐标 1 2  3<br>1和3顺利存入mi中（存的是坐标）mi={1,2}；<br>读入-1时与前面的进行比较，-1&lt;3然后tail–，-1&lt;1,tail–,直到整个区间都比完（也就是tail大于head时），或者是出现比-1还小的数x，tail就在x的位置停下来。然后将-1的坐标存入到mi[++tail]中,说明从tail之后没有比-1还小的了.<br>m=3<br>例如1 2 4 5 4<br>如果读入的数没有比之前小的，就依次读入mi中，mi=[1,2,3],head=1;当i=4时,就超出m的范围时（mi[head]+m&lt;=i），就将区间向后移动（head++，头向后移动，整个区间也跟着移动），随着输出（将多的输出来）<br>然后一直循环就可以了。<br>head指的是mi，mi反应的是当前最小值在a中的坐标<br>也可以写两个数组来一个表示单调队列，一个表示对应的在原列表里的序号，我这就用了一个。<br>（话说线段树也可以做）<br><del>讲的我自己也有点乱，明白但是讲不大出来，结合者代码看吧</del> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+3;</span><br><span class="line">int a[maxn];</span><br><span class="line">int ma[maxn];</span><br><span class="line">int mi[maxn]; </span><br><span class="line">void min(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">	int head=1;</span><br><span class="line">	int tail=0;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;mi[head]+m&lt;=i)</span><br><span class="line">		head++;//向后移动head</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&lt;a[mi[tail]])</span><br><span class="line">		tail--;//向前移动tail</span><br><span class="line">		</span><br><span class="line">		tail++;</span><br><span class="line">		mi[tail]=i;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[mi[head]]&lt;&lt;<span class="string">" "</span>;//如果元素超出就输出当前区域最小</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void max(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">	int head=1;</span><br><span class="line">	int tail=0;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;ma[head]+m&lt;=i)head++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&gt;a[ma[tail]])tail--;</span><br><span class="line">		tail++;</span><br><span class="line">		ma[tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[ma[head]]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(n)cin&gt;&gt;a[i];</span><br><span class="line">	min(n,m);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	max(n,m);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客算法周周练1</title>
    <url>/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="A-Maximize-The-Beautiful-Value"><a href="#A-Maximize-The-Beautiful-Value" class="headerlink" title="A Maximize The Beautiful Value"></a>A Maximize The Beautiful Value</h2><p><a href="http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/">站内题解</a></p>
<h2 id="B-身体训练"><a href="#B-身体训练" class="headerlink" title="B 身体训练"></a>B 身体训练</h2><p><a href="http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/">站内题解</a></p>
<a id="more"></a>
<h2 id="C-Borrow-Classroom"><a href="#C-Borrow-Classroom" class="headerlink" title="C Borrow Classroom"></a>C Borrow Classroom</h2><p>待定。。。</p>
<h2 id="D-景区路线规划"><a href="#D-景区路线规划" class="headerlink" title="D 景区路线规划"></a>D 景区路线规划</h2><p>待定。。。</p>
<h2 id="E-幸运数字Ⅱ"><a href="#E-幸运数字Ⅱ" class="headerlink" title="E 幸运数字Ⅱ"></a>E 幸运数字Ⅱ</h2><p><a href="http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/">站内题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>牛客算法周周练2</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/">站内题解</a></p>
<h2 id="B-Music-Problem"><a href="#B-Music-Problem" class="headerlink" title="B Music Problem"></a>B Music Problem</h2><p><a href="http://jozky.top/2020/04/17/Music-Problem/">站内题解</a></p>
<h2 id="C-完全平方数"><a href="#C-完全平方数" class="headerlink" title="C 完全平方数"></a>C 完全平方数</h2><p><a href="http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/">站内题解</a></p>
<h2 id="D-小H和游戏"><a href="#D-小H和游戏" class="headerlink" title="D 小H和游戏"></a>D 小H和游戏</h2><p><a href="http://jozky.top/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/">站内题解</a></p>
<h2 id="E-水题-water"><a href="#E-水题-water" class="headerlink" title="E 水题(water)"></a>E 水题(water)</h2><p><a href="http://jozky.top/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/">站内题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>牛客网 【每日一题】4月10日 二分图染色(弱化版)</title>
    <url>/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/13229" target="_blank" rel="noopener">题目传送</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述 </p>
<blockquote>
<p>给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。<br>计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>二分图单边的顶点数目n(n ≤ 10^7)</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数,即所求的答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>

<h2 id="题意-amp-amp-题解：："><a href="#题意-amp-amp-题解：：" class="headerlink" title="题意&amp;&amp;题解：："></a>题意&amp;&amp;题解：：</h2><p>完全二分图:是一种特殊的二分图，可以把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连。<br>我们可以把左右各有n个点的二分图的题转化成n*n的棋盘问题。（离散上学过）<br>题目：让染三个颜色，红蓝绿，但是绿色并没有什么要求，我们可以最后再随便放。所以我们先考虑红和蓝。<br>红和蓝都是不能共享端点，同步到棋盘上（行和列分别表示二分图两个集合），也就是棋盘上行和列只能有一个红或蓝</p>
<p>现在的题目就是：<br>在n*n的棋盘上，放任意红和蓝棋子，任一行和列不能有相同颜色的棋子，有多少种放的方法？<br>F<del>n</del>表示棋盘大小为 n * n时的答案<br>先只考虑一个颜色： F<del>n</del>=<img src="https://img-blog.csdnimg.cn/20200416162741561.png" alt="在这里插入图片描述">)种方案(先在n行里选若干行，然后每一行选若干列，行没有顺序区分，就是选两行，选第一行和第三行与选第一行和第二行没差，所以选行用组合；而列不一样，因为行列只能放一个，我们可以先放在一行上，然后分散到其他行，所以选列的时候要考虑顺序问题，要用的是排列而不是组合)<br>如图：<br><img src="https://img-blog.csdnimg.cn/20200416164224892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如我们选两行（C^2^ <del>n</del> ），然后每行放一个，我们先考虑都放在一行上，看图中最上面两行（黄色和绿色），都是选的第一个格和第二个格，但是分散开不一样，（图中4 * 4的表格）说明我们要考虑顺序，所以选列是A^2^<del>n</del>，将所以情况加起来就是选一个颜色的方案</p>
<p>选两个颜色：从上面我们能得到一个颜色是F<del>n</del>，两个就是F<del>n</del>* F<del>n</del>，非也，因为这样会出现一个格子放两个棋子，我们还要将这种情况删去。需要容斥。<br>我们用g<del>i</del>表示最少有i个点放了两个棋子（颜色不一样）的方案数。那么除去i 行和i 列（i个点所在），我们在剩下n-i行与列里就不会有重复的，g<del>i</del> = f ^2^<del>n-i</del> 。被除去的 i 行与 i列选法和之前一样是 C^i^<del>n</del>A^i^<del>n</del> ，最后得到容斥公式：<br><img src="https://img-blog.csdnimg.cn/20200416170156368.png" alt="在这里插入图片描述"><br>（这一部分好好理解）</p>
<p>C^k^<del>n</del>A^k^<del>n</del>都可以求好，但是Fn提前求会超时，说明上面的公式不能用，我们要换一个想法来求<br>我们来考虑F<del>n</del>能不能递推出来，从F<del>n-1</del>推出F<del>n</del><br>考虑n-1到n的过程：<br>一共增加了2n-1个格子（n^2^-(n-1)^2^）,n-1之前的格子都已经放好了，我们只需要考虑多出的这些格子该怎么放。<br>如果只放一个棋子，就有2n-1个方案，如果都不放，一个方案，一共是2n种方案，也就是2n<em>F<del>n-1</del>，（F<del>n-1</del>是之前n-1行列已经放好的方案数）<br>但是有限制条件，每一行不能有相同颜色，每放一个棋子，意味着这一行这一列都不能放了，就会出现n-1种重复情况（因为是从n-1的扩展来的），我们之前n-1行列的棋子都平移靠边，因为之前都是不同行同列，所以靠边后，正好占了一行一列，也就是我们在新增部分可以放的棋子，实际上是F<del>n-2</del>而非F<del>n-1</del>（这里可以看看图），那一共（n-1）F<del>n-2</del>次重复情况，可以选n-1行，而且每一列也可以进行相同操作,总的方案数就是2×(n−1) ^2^ ∗F(n−2)<br>借鉴邓老师的图：<br><img src="https://img-blog.csdnimg.cn/2020041617195483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还要考虑放两个的情况;<br>即最后一行和列分别放一个，这样不重复嘛<br>方案就是：（n-1）^2^</em>F(n-2)<br><img src="https://img-blog.csdnimg.cn/20200416172115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：得到公式<br>F[n]=2<em>n</em>F[n-1]-(n-1)^2^F[n-2]<br>（<del>我真的是把我所能理解都写出来了</del> ）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000004</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N],s[N],F[N];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[m] % mod * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        g[i] = <span class="number">1l</span>l * g[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        </span><br><span class="line">         ll ans1 = <span class="number">1</span>;</span><br><span class="line">   		 <span class="keyword">for</span>(;y;y &gt;&gt;= <span class="number">1</span>,x = x * x % mod)</span><br><span class="line">   		 &#123;</span><br><span class="line">   		 	        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans1 = ans1 * x % mod;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    s[n] = ans1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        s[i] = <span class="number">1l</span>l * s[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;F[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">        F[i] = (<span class="number">2l</span>l * i * F[i - <span class="number">1</span>] - <span class="number">1l</span>l * F[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod * (i - <span class="number">1</span>) % mod) % mod;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">     ll k ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">       k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) k = <span class="number">-1</span>;</span><br><span class="line">        ans += k * C(n,i) * A(n,i) % mod * F[n - i] % mod * F[n - i] % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans + mod) % mod);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>数论</tag>
        <tag>组合</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>树学</title>
    <url>/2020/04/14/%E6%A0%91%E5%AD%A6/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/201400" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:&gt; %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep<del>root</del>为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep<del>i</del>=dep<del>fa</del> <del>i</del>+1,整棵树的价值W=<img src="https://img-blog.csdnimg.cn/20200414204932422.png" alt="在这里插入图片描述"> ，即所有点的深度和</p>
<a id="more"></a>
<p>牛妹希望这棵树的W最小，请你告诉她，选择哪个点可以使W最小<br>输入描述:<br>第一行，一个数，n<br>接下来n-1行，每行两个数x,y，代表x-y是树上的一条边<br>输出描述:<br>一行，一个数，最小的W<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>备注:<br>对于30%30%的数据，1&lt;= n&lt;=1000<br>对于100%100%的数据，1&lt;=n &lt;=10^6^</p>
<h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>树形dp+换根<br>用到的几个函数：<br>dep[i]：节点i的深度<br>ant[i]：i的子树的个数（含本身）<br>f[x]：以x为根的每个节点深度的和<br><img src="https://img-blog.csdnimg.cn/20200414211409638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图一为以u为根节点<br>图二为以v为根节点<br>从u转到v 之后，图二中黄色区域（u和子树1和子树2）根节点都加1（因为成为别人的子节点），绿色区域（v和根节点2）根节点减1（因为成为别人的根节点）<br>那转换成公式是什么样的？<br>f[v]=（f[u]-ant[v]）+(n-ant[v]);<br>怎么理解呢？<br>第一个括号里，是将图二的绿色区域根节点减一，因为黄色区域一共ant[v]个节点，这个区域内每个节点都减1，所以整个区域f[u]要减ant[v].<br>第二个括号就是黄色区域每个节点都加一，那整个区域就加这个区域的节点数，这个区域的节点数=整个区域-绿色区域，所以就是n-ant[v]<br>我们从1开始dfs，求出每个节点的深度，即dep[]<br>然后再dfs求出每个点子树数量,再dfs换成其他根，利用公式求出f来</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//链式前项星 </span></span><br><span class="line">ll head[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//无向边，所以乘2</span></span><br><span class="line">ll dep[maxn];<span class="comment">//节点的深度 </span></span><br><span class="line">ll ant[maxn];<span class="comment">//节点x的子树数量（包含本身） </span></span><br><span class="line">ll f[maxn];<span class="comment">//以i为根的时候每个点深度的和 </span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll minn=<span class="number">1e7</span>;</span><br><span class="line">	ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].v=v;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		forr(n)f[<span class="number">1</span>]+=dep[i];<span class="comment">//在dfs1求完每个点深度后，接着求出以1为根的时候每个点深度的和  </span></span><br><span class="line">		forr(n)ant[i]=<span class="number">1</span>;<span class="comment">//每个节点的子树一开始都是本身 </span></span><br><span class="line">&#125;	</span><br><span class="line">ll v=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v=edge[i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">		dfs1(v,now);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//以1为根节点开始，计算出每个节点的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		v=edge[i].v;</span><br><span class="line"> 		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> 		dfs2(v,now);</span><br><span class="line"> 		ant[now]+=ant[v]; </span><br><span class="line">	 &#125;</span><br><span class="line">&#125;<span class="comment">//求出x节点的子树数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		v=edge[i].v;</span><br><span class="line"> 		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> 		f[v]=f[now]-ant[v]+(n-ant[v]); </span><br><span class="line"> 		dfs3(v,now);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1开始换成其他根，并求出其他根的f值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;	</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	init(n);<span class="comment">//初始化 </span></span><br><span class="line">	dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	dfs3(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		minn=min(minn,f[i]);</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;minn;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看会发现dfs1与dfs2结构相似，完全可以和在一起写<br>或者用vector写更简洁</p>
<h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p>我看有很多大佬都用重心的性质来做<br>树的重心有一个这样的性质：在树中所有点到某点的距离和 当中，到树的重心的距离和是最小的，如果有多个重心，那他们距离和一样。<br>树中所有点到重心的距离和最小，不就是我们要求的那个值吗。<br>先用dfs树形dp求出重心，再求出重心与每个点的距离进行累加求和</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ant[maxn],root[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">ll res;</span><br><span class="line">ll point=maxn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ant[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(u,v);</span><br><span class="line">            </span><br><span class="line">            ant[v]+=(ant[u]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            maxx=max(ant[u],maxx);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxx=max(n-ant[v]<span class="number">-1</span>,maxx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(maxx&lt;point)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">        point=maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxx==point)</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res+=dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">            dfs2(u,v,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关树的重心其他性质，有空专门讲讲</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dfs</tag>
        <tag>树上dp</tag>
        <tag>换根</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>幸运数字Ⅱ </title>
    <url>/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/E" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。<br>定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r</p>
<ul>
<li>1) + next(r)。 输入描述:</li>
</ul>
<p>两个整数l和r (1 &lt;= l &lt;= r &lt;= 1000,000,000)。</p>
</blockquote>
<a id="more"></a> 

<p>输出描述:</p>
<blockquote>
<p>一个数字表示答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>

<p>示例2<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>题意：<br>打表出奇迹<br>你可以提前打好表，记录在数组里<br>或者现打表，有两个方法<br>一个是用vector，<br>或者自身递归查找，存在pre中<br>打完表后，直接从l开始对比数到r<br>直接if判断然后sum加有点慢<br>你可以看每两个pre之间的数最后都做一样相加，比如47~74之间（不含47）的数都算作74，那有多少个数？就是74-47+1，然后直接乘74，加起来就ok了<br>注意注意！！！不要忘了longlong，可坑死我了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll pre[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1e10</span>+<span class="number">2</span>)<span class="keyword">return</span> ; </span><br><span class="line">	pre[cnt++]=n;</span><br><span class="line">	dfs(n*<span class="number">10</span>+<span class="number">4</span>);</span><br><span class="line">	dfs(n*<span class="number">10</span>+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(ll x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if(n-1e9&gt;0)return ;</span></span><br><span class="line"><span class="comment">	q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">	dfs((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">	dfs((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">	q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dfs(0);</span></span><br><span class="line"><span class="comment">sort(q.begin(),q.end());</span></span><br><span class="line"><span class="comment">q.push_back(4444444444); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll r,l;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;l,&amp;r);</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;pre[cnt-1]&lt;&lt;endl;</span></span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	ll ant=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=l;i&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	if(i&gt;pre[ant])ant++;</span></span><br><span class="line">	<span class="comment">//	sum+=pre[ant];</span></span><br><span class="line">		<span class="keyword">while</span>(i&gt;pre[ant])ant++;</span><br><span class="line">		sum+=pre[ant]*(min(r,pre[ant])-i+<span class="number">1</span>);</span><br><span class="line">		i=pre[ant]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月26日 合并回文子串</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>题号：NC13230<br>名称：合并回文子串<br>来源：美团2017年CodeM大赛-初赛A轮</strong><br><a href="https://ac.nowcoder.com/acm/problem/13230" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<p><strong>题目描述</strong></p>
<blockquote>
<p>输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。<br>我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。<br>需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>第一行一个整数T(T ≤ 50)。 接下来2T行，每两行两个字符串分别代表A,B(|A|,|B| ≤ 50)，A,B的字符集为全体小写字母。</p>
</blockquote>
<p>输出描述:</p>
<p>对于每组数据输出一行一个整数表示价值最大的C的价值。<br>示例1</p>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">a</span><br><span class="line">aaaabcaa</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>思路：区间dp问题</strong><br>dp[i][j][m][n]表示A中下标i到j-1以及B中下标m到n-1的串，能否组成回文串<br>(dp值为零则表示不构成回文串，不为零则表示构成)<br>首先：字符本身是回文串<br>其次，分为四种情况<br>a[i]==a[j-1]        dp[i][j][m][n]+=c[i+1][j-1][m][n];<br>因为dp我们只考虑是否为0或非0，所以dp之间可以+=也可以|=,都不影响<br>（当A的第i为和第j-1位相同时，那么dp[i][j]是否为回文串就取决于比它小一层的dp[i+1][j-1]，这样一次往里推，就可以推到以一种情况）<br>b[m]==b[n-1]    dp[i][j][m][n]+=c[i][j][m+1][n-1];<br>(和上一个思路相同)</p>
<p>a[i]==b[n-1]        dp[i][j][m][n]+=c[i+1][j][m][n-1];<br>（当A的i与B的n-1相同时，那么dp[i][][][n]是否为回文串就取决于A的后一位i+1和B的前一位n-1的情况）<br>a[m]==b[j-1]    dp[i][j][m][n]+=c[i][j-1][m+1][n];<br><strong>代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">int t;</span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int c[maxn][maxn][maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	char ch=getchar();</span><br><span class="line">	int j;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		int ans=0;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		int len1=strlen(a),len2=strlen(b);</span><br><span class="line">		<span class="keyword">for</span>(int tj=0;tj&lt;=len1;tj++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(int tn=0;tn&lt;=len2;tn++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(int i=0;i+tj&lt;=len1;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(int m=0;m+tn&lt;=len2;m++)</span><br><span class="line">					&#123;</span><br><span class="line">						j=i+tj;</span><br><span class="line">						n=m+tn;</span><br><span class="line">						<span class="keyword">if</span>(tj+tn&lt;=1)c[i][j][m][n]=1;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							c[i][j][m][n]=0;</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=2&amp;&amp;a[i]==a[j-1])c[i][j][m][n]|=c[i+1][j-1][m][n];                                               </span><br><span class="line">							<span class="keyword">if</span>(tn&gt;=2&amp;&amp;b[m]==b[n-1])c[i][j][m][n]|=c[i][j][m+1][n-1];</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[i]==b[n-1])c[i][j][m][n]|=c[i+1][j][m][n-1];</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[m]==b[j-1])c[i][j][m][n]|=c[i][j-1][m+1][n];</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span>(c[i][j][m][n])ans=max(ans,tj+tn);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另外</strong><br>tj和tn从0开始，不断讨论A中i到i+tj和B中m到tn的回文字符串</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】4月1日题目 Rinne Loves Edges </title>
    <url>/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22598" target="_blank" rel="noopener">牛客网</a></p>
<ol>
<li>题目：</li>
</ol>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<blockquote>
<p>题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m<br>条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为<br>1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1<br>了！作为回报，她会让你的排名上升一定的数量。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<blockquote>
<p>第一行三个整数 N,M,S，意义如「题目描述」所述。</p>
<p>接下来 M 行，每行三个整数 u,v,w 代表点 u 到点 v 之间有一条长度为 w 的无向边。</p>
</blockquote>
<p>输出描述:</p>
<p>一个整数表示答案。</p>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 1 </span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>需要使得点 2,3,4 不能到达点 1，显然只能删除所有的边，答案为 3</p>
<p>示例2<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明</p>
<blockquote>
<p>需要使得点 4 不能到达点 1，显然删除边 2↔3是最优的。</p>
</blockquote>
<p>备注:</p>
<blockquote>
<p>2≤S≤N≤10^5^,M=N−1保证答案在 C++ long long 范围内</p>
</blockquote>
<ol start="2">
<li>题解：</li>
</ol>
<p>仔细观察题中给的数据m=n-1，其实就是给你一个树，而被删除度为1的点就是这个树的叶子节点，给你的s就是这个树的根<br>那一切就很清楚了：给你一个树和根节点，让你通过删边使得根节点与叶子节点不相连，问你怎么删值最小<br>这个是树形dp问题，我们要做的就是在搜索树的过程中不断处理数据<br>凡是dp问题，都有状态转移，就是一个大问题可以小问题<br>s为根节点时，要删去一些边让s与每个叶子节点不连通，其实就是让x为根节点的子树删去一些边，使得s和x的子树上每个叶子节点不连通。<br>两种情况：一个就是删去x与他儿子y的边<br>另一个就是看以y为子树的根节点的最小情况。<br>我们取较小值<br>    f[x]+=min(f[y],edge[i].w);<br>    edge[i].w是指当前节点x与其子节点y的距离<br>    具体看代码吧</p>
<ol start="3">
<li>代码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+3;</span><br><span class="line">int f[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int u,v,w,next;</span><br><span class="line">&#125;edge[maxn*2];</span><br><span class="line">int root[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">int cnt=0;</span><br><span class="line">	int n,m,s;</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int fa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=s&amp;&amp;root[x]==1)f[x]=-1;//如果这个是叶子节点，就断绝与父亲的关系 </span><br><span class="line">	//根节点s也有可能度为1，所以要除s之外</span><br><span class="line">	int now;//当前点x的子节点</span><br><span class="line">	//关系(fa--&gt;x--&gt;now)</span><br><span class="line">	<span class="keyword">for</span>(int i=head[x];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		now=edge[i].v;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(now==fa)<span class="built_in">continue</span>;//因为是无向图，我们要防止返回到父亲节点</span><br><span class="line">		</span><br><span class="line">		dfs(now,x);//继续向下</span><br><span class="line">		<span class="keyword">if</span>(f[now]==-1)f[x]+=edge[i].w;//这个我们已经给断绝关系了，只加当前边的权值</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		f[x]+=min(f[now],edge[i].w);//考虑两个方面</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	int u,v,w;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		addt(u,v,w);</span><br><span class="line">		addt(v,u,w);//链式前向星</span><br><span class="line">		root[u]++;</span><br><span class="line">		root[v]++;</span><br><span class="line">	 &#125; </span><br><span class="line">	 dfs(s,0);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[s]);</span><br><span class="line">	 <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛60--斩杀线计算大师</title>
    <url>/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4853/D" target="_blank" rel="noopener">题目传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。<br>数据保证一定存在解。如果存在多组解，输出任意一组。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>一行四个整数分别表示a,b,c,k</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一行输出三个整数分别表示x,y,z</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3 4 5 20</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure>

<p>备注:<br>1 ≤ a , b , c ≤ 1e5<br>0 ≤ k ≤ 1e12</p>
<ul>
<li>题意：</li>
</ul>
<p>就是多少个a+多少个b+多少个c=k<br>问你这个“多少个”分别是什么</p>
<p> <strong>题解</strong></p>
<ol>
<li>方法一</li>
</ol>
<p>把题目改成公式形式就是<br>ax+by+cz=k<br>没错，其实就是exgcd，只不过exgcd是ax+by=k<br>你把咱们这个式子再变变形<br>就能得到：<br>a x + b y = k - c * z<br>而这个z我们可以枚举<br>那就是a x + b y = k - c * i<br>题目说了肯定有解，那放心枚举i就完事了<br>把后面这部分-c<em>i当做整体M<br>ax+by=M<br>然后就是exgcd的步骤<br>用exgcd求出x0,y0<br>a</em>x0+b<em>y0=GCD(a,b)<br>两边同时除以gcd（a，b）<br>(gcd(a,b)我们用w代替)<br>两边除以w，再乘c<br>a</em>x0+b<em>y0-gcd(a,b)+b</em>y*c/gcd(a,b)=c</p>
<p>如果w=1<br>x = x0 + b *  t<br>y = y0 - a *  t<br>且对任一正数t，皆成立<br>根据这个我们就可以求出方程所有解<br>t = b / w<br>x= ( x % t + t ) % t<br><del>有空专门整理一下exgcd原理和博客</del> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod =1e9+3;</span><br><span class="line">ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x=1;</span><br><span class="line">		y=0;</span><br><span class="line">		<span class="built_in">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll d;</span><br><span class="line">	d=exgcd(b,a%b,y,x);</span><br><span class="line">	y=y<span class="_">-a</span>/b*x;</span><br><span class="line">	<span class="built_in">return</span> d;</span><br><span class="line">&#125;//exgcd模板 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,b,c,k,x,y;</span><br><span class="line">	scanf(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(ll i=0;i&lt;k/c;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll ans=(k-i*c);//去掉c*i的剩余部分</span><br><span class="line">		ll w = exgcd(a,b,x,y);</span><br><span class="line">		<span class="keyword">if</span>(ans%w)<span class="built_in">continue</span>;</span><br><span class="line">		</span><br><span class="line">		x= x * ans / w;</span><br><span class="line">		y= y * ans / w;</span><br><span class="line">		</span><br><span class="line">		x=( x % ( b / w ) + ( b / w ) ) % ( b / w );</span><br><span class="line">		y= ( ans - x * a ) / b;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=0&amp;&amp;y&gt;=0)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二</li>
</ol>
<p>公式还有个变形方式：<br>k-ax-by=cz<br>(k-ax-by)/c=z<br>也就是( k - a x - b y ) % c = = 0<br> ( k - a i - b j ) % c = = 0<br> 枚举i和j就ok了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(j)</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">if</span>( k - a i - b j ) % c = = 0</span><br><span class="line">	 &#123;</span><br><span class="line">	 cout&lt;&lt;;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>曾经noip好像考过ecgcd裸题感兴趣可以做做</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网2020愚人节比赛</title>
    <url>/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="牛客2020年愚人节比赛2020-4-1-21-32-11"><a href="#牛客2020年愚人节比赛2020-4-1-21-32-11" class="headerlink" title="牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 "></a>牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 </h2><p><del>欢乐的一晚上</del><br><a href="https://ac.nowcoder.com/acm/contest/4863#question" target="_blank" rel="noopener">题目链接</a><br>其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感<br><img src="https://img-blog.csdnimg.cn/20200401211211311.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211308221.png" alt="在这里插入图片描述">不知道这是哪位哥的，心疼一下</p>
<a id="more"></a>
<p><strong>题解</strong><br>注：一下题解没必要较劲，欢乐局而已<br>对不对无所谓，换了最重要奥<br>A题rand36：<br>我试了好几个数，最后3过了，以为答案3，结果发现答案是随机的，看命了有人一下就过。。。<br>B寻宝游戏：<br>要找的宝贝就在宝藏图上，输出题目中图的地址就ac了<br>C老铁安排上：<br>看图是什么手机？老年机，所以是九字输入法，字母按照九字输入法的对应数字<br>D神奇的字母<br>输出题目中的样例<br>“一个字符，表示神奇的字母（范围从’a’到’z’，保证小写）。”<br>即可<br>E return1；<br>不会（笑哭）貌似场上唯一一个没人做出来的题<br>F 抬头，答案在天上<br>天上就是指你浏览器的上面，也就是网址，按照顺序对应相应的数字<br>G抬头在地上<br>就是看字地下的标点符号，你会发现有个标点符号是超链接，输出超链接地址即可<br>H园<br>问你能套多少园，可没说不能套娃哦<del>，n是几就能套几个<br>I牛客搜索题<br>这里面最扯的题（个人感觉<img src="https://img-blog.csdnimg.cn/20200401212525727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">）<br>J签到题<br>不会（笑哭）<br>K四万像素五角星<br>有个大佬手打出来了。。。<br>L positive-integer<br>经过证明<br>n=1时，输出1；<br>其他输出0<br>证明过程嘛。。。（</del>多尝试几次就OK了，不怕失败，都wa了多少次了）~~<br>好像官方出题解了，看官方题解吧<br><a href="https://ac.nowcoder.com/discuss/396514?type=101&order=0&pos=5&page=1" target="_blank" rel="noopener">题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>欢乐局</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月27日 数学考试</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p> 题号 NC15553<br> 名称 数学考试<br> 来源 2018年长沙理工大学第十三届程序设计竞赛<br>链接：<a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15553</a><br>来源：牛客网<br><a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">试题传送门</a><br>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述<br>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br>他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br>即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行一个整数T（T&lt;=10）,代表有T组数据 接下来一行两个整数n,k,(1&lt;=n&lt;=200,000),(1&lt;=k,2k &lt;= n)<br>接下来一行n个整数a1,a2,…,an，（-100,000&lt;=ai&lt;=100,000）</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数，qwb能获得的最大分数</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">8 2</span><br><span class="line">-1 0 2 -1 -1 2 3 -1</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong><em>题解：</em></strong><br>题意就是求不想交的前缀与后缀和的最大值<br>第一反应是线段树（<del>毕竟是有关区间查询</del> ） ，不过仔细想想也不能这么麻烦（<del>打线段树不累吗？</del> ） ，不过也有大佬用线段树做的。<br>根据题意知道前缀与后缀长度一样，依据朴素的原则单纯打暴力肯定不行，需要优化优化，怎么优化呢？</p>
<p>我们先求出所有前缀和q[]<br>然后按照给定前后缀的长度k，求出每个k长区间的和<br>比如 -1 0 2 -1 -1 2 3 -1   k=2；<br>每个k长区间的和为：w[]-1 2 1 -2 1 5 2<br>我们所要求的最大值max=dp1+dp2<br>dp1是前缀和最大值<br>dp2是后缀和最大值<br>那其实就是在w中取一个dp1再取一个dp2，使他们和最大<br>但注意前缀与后缀不能相交和相连<br>方法一：<br>稍微处理下,可以先选后缀，然后前缀的范围就是去除已选的后缀，在里面取最大的前缀<br>maxx=(q[i]-q[i-k])+max(q[1],q[2],q[3]…..q[i-k-1])<br>(q[i]-q[i-k])后缀和<br>max(q[1],q[2],q[3]…..q[i-k-1])最大的前缀<br>然后求出maxx的最大值情况<br>诶，这不就是线性dp吗！wok做完才注意到<br>方法二：<br>求出前缀和所能取到的最大值（从头开始），放入数组w1<br>求出后缀和所能取到的最大值（从尾开始），放入w2中<br>然后再一个循环，求出w1[i]与w2[i+1]（即当前位i的前缀和与排在i之后的最大后缀和之和）的最大值<br>代码一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">	  	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	  	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		cin&gt;&gt;cnt;</span><br><span class="line">	  		q[i]=q[i-1]+cnt; </span><br><span class="line">		&#125;</span><br><span class="line">		memset(w1,-128,sizeof(w1));</span><br><span class="line">			memset(w2,-128,sizeof(w2));</span><br><span class="line">		cnt=-1e10;</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		w[i]=q[i]-q[i-k];</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line">				<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(w[i]+w1[i-k]&gt;cnt)cnt=w[i]+w1[i-k];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">	  	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	  	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		cin&gt;&gt;cnt;</span><br><span class="line">	  		q[i]=q[i-1]+cnt; </span><br><span class="line">		&#125;</span><br><span class="line">		memset(w1,-128,sizeof(w1));</span><br><span class="line">			memset(w2,-128,sizeof(w2));</span><br><span class="line">		cnt=-1e10;</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		w[i]=q[i]-q[i-k];</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">			w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=n-k+1;i&gt;=k+1;i--)</span><br><span class="line">			w2[i]=w2[i+1]&gt;w[i+k-1]?w2[i+1]:w[i+k-1];</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(w2[i+1]+w1[i]&gt;cnt)cnt=w2[i+1]+w1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对了还有变形的问题：<br><del>（等晚上有空再想吧）</del> </p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>前缀后缀和</tag>
        <tag>dp</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网 【每日一题】4月15日 Treepath</title>
    <url>/2020/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8815%E6%97%A5-Treepath/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14248" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一棵n个点的树，问其中有多少条长度为偶数的路径。路径的长度为经过的边的条数。x到y与y到x被视为同一条路径。路径的起点与终点不能相同。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行一个数n表示点的个数； 接下来n-1行，每行两个整数x，y表示边； 保证输入数据形成一棵树； 1&lt;=n&lt;=100000</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一行一个整数表示答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>求长度为偶数的路径<br>偶数层的点到偶数层的点长度是偶数<br>奇数层到奇数层的点的路径长度也是偶数<br>奇数层的点到偶数层的点路径长度就算奇数<br>所以需要统计多少个奇数层多少点偶数层多少点<br>我们发现如果层数奇偶性一样，路径长度就是偶数<br>为什么呢？引用邓老师的讲解</p>
<blockquote>
<p>我们可以考虑先让两个点里深度深的那个往上走，走到和另外一个点一样的高度，这个显然是偶数步完成的，之后两个点一起往上走直到汇合，走到步数是一样的，所以最终加起来也是偶数。</p>
</blockquote>
<p>然后我们会用到数组dp[][]<br>dp[i][0/1]表示以i为根的子树，与根节点i的距离<br>因为距离长度只有偶数奇数两种情况，所以我们把偶数设为0，奇数设为1，这样好统计<br>u是v的父亲，<br>也就是一个来自v的子树的点，到u点的路径会比到v的路径长度 长1<br>这样我们有：<br>dp[u][0]+=dp[v][1]<br>以u为根的子树，与u的距离长度为偶数的情况一个本身，另一个来自dp[v][i].因为以v为根节点，与v的距离为奇数，那到u的距离就要加1，也就是偶数<br>dp[u][1]+=dp[v][0]<br>同理</p>
<p>sum + = dp [ u ] [ 0 ] * dp [ v ] [ 1 ] + dp [ u] [ 1 ] * dp [ v ] [ 0 ]<br>已有dp[u][0]条以u为端点长度为偶数的路径，与dp[v][1]条以v为端点长度为奇数的路径合并可以得到 dp [ u ] [ 0 ] * dp [ v ] [ 1 ]   条长度为偶数的路径<br>同理dp[u][i]*dp[v][0]也是一样</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll dp[maxn][<span class="number">3</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> v : edge[u]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">	</span><br><span class="line">			sum+=dp[u][<span class="number">0</span>]*dp[v][<span class="number">1</span>]+dp[u][<span class="number">1</span>]*dp[v][<span class="number">0</span>];</span><br><span class="line">			dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];</span><br><span class="line">			dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		edge[a].push_back(b);</span><br><span class="line">		edge[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月13号 Accumulation Degree</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/51180" target="_blank" rel="noopener">本题目传送</a></p>
<p>题目树学是这个题的简易版，也涉及换根问题，可以先看看这个<br><a href="https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92" target="_blank" rel="noopener">树学</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit<br>IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Trees are an important component of the natural landscape because of<br>their prevention of erosion and the provision of a specific<br>ather-sheltered ecosystem in and under their foliage. Trees have also</p>
<a id="more"></a>
<p>been found to play an important role in producing oxygen and reducing<br>carbon dioxide in the atmosphere, as well as moderating ground<br>temperatures. They are also significant elements in landscaping and<br>agriculture, both for their aesthetic appeal and their orchard crops<br>(such as apples). Wood from trees is a common building material.</p>
<p>Trees also play an intimate role in many of the world’s mythologies.<br>Many scholars are interested in finding peculiar properties about<br>trees, such as the center of a tree, tree counting, tree coloring.<br>A(x) is one of such properties.</p>
</blockquote>
<p>A(x) (accumulation degree of node x) is defined as follows:</p>
<ol>
<li>Each edge of the tree has an positive capacity.</li>
<li>The nodes with degree of one in the tree are named terminals.</li>
<li>The flow of each edge can’t exceed its capacity.</li>
<li>A(x) is the maximal flow that node x can flow to other terminal nodes.</li>
</ol>
<p>Since it may be hard to understand the definition, an example is showed below:<br><img src="https://img-blog.csdnimg.cn/20200415184510424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="样例分析："><a href="#样例分析：" class="headerlink" title="样例分析："></a>样例分析：</h2><p>A(1)=11+5+8=24<br>Details:<br>1-&gt;2    11<br>1-&gt;4-&gt;3    5<br>1-&gt;4-&gt;5    8(since 1-&gt;4 has capacity of 13)</p>
<hr>
<p>A(2)=5+6=11<br>Details:<br>2-&gt;1-&gt;4-&gt;3    5<br>2-&gt;1-&gt;4-&gt;5    6</p>
<hr>
<p>A(3)=5<br>Details:    3-&gt;4-&gt;5    5</p>
<hr>
<p>A(4)=11+5+10=26<br>Details:    4-&gt;1-&gt;2    11<br>4-&gt;3    5<br>4-&gt;5    10</p>
<hr>
<p>A(5)=10<br>Details:    5-&gt;4-&gt;1-&gt;2    10</p>
<hr>
<p>The accumulation degree of a tree is the maximal accumulation degree among its nodes. Here your task is to find the accumulation degree of the given trees.</p>
<p>输入描述:<br>The first line of the input is an integer T which indicates the number of test cases. The first line of each test case is a positive integer n. Each of the following n - 1 lines contains three integers x, y, z separated by spaces, representing there is an edge between node x and node y, and the capacity of the edge is z. Nodes are numbered from 1 to n.<br>All the elements are nonnegative integers no more than 200000. You may assume that the test data are all tree metrics.<br>输出描述:<br>For each test case, output the result on a single line.<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>看看样例分析应该就明白了<br>每个节点都有流量，求出最大流量是多少？</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>flow【i】表示i点的流量：<br>一个点的流量是怎么来的？如果j（j是i的子节点）的流量小于i与j边的容量，flow【i】=flow[j]，如果大于两点之间的容量，flow[i]=i与j的流量<br>i与j的流量就是i与j的边权，我们用edge[i][j]表示。<br>可以得到公式：flow[i]=∑min(flow[j],edge[i][j])<br>因为i有可能有很多子节点，所以加在一起<br>考虑完i之后，我们来考虑换根<br>如图：<img src="https://img-blog.csdnimg.cn/20200415185955370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们将根从x换成y<br>题一中（以x为根）<br>x的流量来自于y，子树2，子树3<br>y的流量来自于子树1<br>图二中（以y为根）<br>x的流量来自子树2，子树3<br>y的流量来自子树1，x</p>
<p>我们发现换根后，x的流量就没有了y的部分，其他都还在，此时x的流量就是原本的减去从y流向x的部分，new[x]=flow[ x ] - min ( flow[ y ] , edge[ x ] [ y ] ),这个new表示x新的流量</p>
<p>我们再看y，y的流量多了从x流来的部分，y的流量就是flow[y]+min(new[x],edge[x][y])，，因为换根x的流量发生改变（上一段所讲），那流向y的是现在x的流量，而不是换跟前的flow[x].</p>
<p>换根前后，图二中绿色区域没有发生改变，也就是父节点改变影响不到子节点</p>
<p>还要注意叶子节点，如果x从根变成叶子节点（x的儿子只有y，当y成为根节点之后，x没有了儿子），x的流量不是上面的公式，而是变成了edge[x][y]，因为没有子节点的流量流向x，只有x与y的边权值，也就是上面讲的式子使用条件是min（x，y），x和y不能为0。</p>
<p>先求出x为根的流量，然后依次换根求出最大值</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt = <span class="number">0</span>, d[maxn], deg[maxn], f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	  cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].x = x;</span><br><span class="line">    edge[cnt].y = y;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg[y] == <span class="number">1</span>)&#123;<span class="comment">//如果y只有一个子节点，y的流量只能是root与y的边权值 </span></span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(y, root);</span><br><span class="line">            ans += min(d[y], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[root] = ans </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//先求出节点x的流量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg[x] == <span class="number">1</span>)&#123;</span><br><span class="line">            f[y] = d[y] + edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[y] = d[y] + min(f[x] - min(d[y], edge[i].w), edge[i].w);<span class="comment">//核心公式 </span></span><br><span class="line">        &#125;</span><br><span class="line">        dp(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//从x不断换根 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">       <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();<span class="comment">//初始化 </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">         </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            addedge(x, y, w);<span class="comment">//添边 </span></span><br><span class="line">            addedge(y, x, w);<span class="comment">//添边 </span></span><br><span class="line">                deg[x]++;<span class="comment">//deg用于判断这个点有几个子节点 </span></span><br><span class="line"> 			    deg[y]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        dfs(s, <span class="number">0</span>);<span class="comment">//求x的流量 </span></span><br><span class="line">        f[s] = d[s];</span><br><span class="line">        dp(s, <span class="number">0</span>);<span class="comment">//不断换根 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ans = max(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>树上dp</tag>
        <tag>换根</tag>
        <tag>二次扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月14日题目精讲 Xorto</title>
    <url>/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14247" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；<br>第二行n个整数表示数组； 1&lt;=n&lt;=1000,0&lt;=数组元素&lt;100000。</p>
</blockquote>
<a id="more"></a>
<p>输出描述:<br>一行一个整数表示答案。<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>说明<br>([1,1],[2,2]),([1,1],[3,3]),([1,1],[2,3]),([1,2],[3,3]),([2,2],[3,3])</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>枚举？TLE√<br>暴力肯定过不了，我们可以先考虑只枚举一个区间[x,y]，这个区间可以通过前缀异或和得到。pre来存前缀<br>我们用[x,y]表示右边的区间，题目要求左右区间异或和为0，也就是问[x,y]左边有多少和它值一样的区间。<br>我们可以用a[i]来存，a[i]表示左边异或和为i区间个数，数组a反应的数量，i反映的是值。<br>先将区间[k,i]存进a中，再用a[ ]来查看左边有多少区间异或和值与右区间[i+1 , j]值相同。<br>因为a存的是数量，所以直接用ans+=a [ pre[i] ^ [j] ]</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]^x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) a[pre[i]^pre[k]]++;<span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) ans += a[pre[i]^pre[j]];<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>关于异或的题我最近做了个<br>CF282E    Sausage Maximization<br><a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">牛客网题目链接</a><br>异或的题，解法挺新颖，不过不知道为什么牛客网这里不能 提交？<br>原题是cf的<a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">cf题目链接</a><br><a href="https://blog.nowcoder.net/n/2369369adcb44ebcbaf9be0a1894aa4a" target="_blank" rel="noopener">我自己写的题解</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月2日 月月查华华的手机</title>
    <url>/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23053" target="_blank" rel="noopener">牛客网链接</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。<br>月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。<br>现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行输入一个字符串A表示华华的昵称。 第二行输入一个正整数N表示华华的推荐好友的个数。<br>接下来N行，每行输入一个字符串BiB_iBi​表示某个推荐好友的昵称。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出N行，对于第i个推荐好友，如果华华可能向她搭讪，输出Yes，否则输出No。 注意大写，同时也要注意输出效率对算法效率的影响。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">noiauwfaurainairtqltqlmomomo</span><br><span class="line">8</span><br><span class="line">rain</span><br><span class="line">air</span><br><span class="line">tql</span><br><span class="line">ntt</span><br><span class="line">xiaobai</span><br><span class="line">oiiiooo</span><br><span class="line">orzcnzcnznb</span><br><span class="line">ooooo</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<p>备注:<br><img src="https://img-blog.csdnimg.cn/20200402104928886.png" alt="在这里插入图片描述"><br><strong><em>题解：</em></strong><br>字符串问题<br>有两个解决方法，字典树和序列自动机都能做（我想到的）<br>这里就不讲字典树了<br>序列自动机：<br>序列自动机就是用一个数组next[i][j]来记录数组a第i位的字符j在i后第一次出现的坐标。<br>设串长为n,字符集大小为a，预处理时间复杂度为O(n*a)<br><a href="https://jozky.gitee.io/2020/04/02/序列自动机/" target="_blank" rel="noopener" title="序列自动机详细讲解">https://jozky.gitee.io/2020/04/02/序列自动机/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=n;i;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int j=1;j&lt;=a;j++) next[i-1][j]=next[i][j];</span><br><span class="line">	next[i-1][s[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt; </span></span><br><span class="line"><span class="comment">#define forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">#define fore(n) for(int j=1;j&lt;=n;j++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int ma=1000004;</span><br><span class="line">char a[ma];</span><br><span class="line">int len;</span><br><span class="line">int w=0;</span><br><span class="line">int m;	</span><br><span class="line">bool f=1;</span><br><span class="line">int next[ma][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;(a+1);</span><br><span class="line">	int len=strlen(a+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=len;i&gt;=1;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=0;j&lt;=25;j++) next[i-1][j]=next[i][j];</span><br><span class="line">		next[i-1][a[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	char ch=getchar();</span><br><span class="line">	forr(m)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;(a+1);</span><br><span class="line">		len=strlen(a+1);</span><br><span class="line">		 w=0;</span><br><span class="line">		f=1;</span><br><span class="line">		fore(len)</span><br><span class="line">		&#123;</span><br><span class="line">			w=next[w][a[j]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(w==0)</span><br><span class="line">			&#123;</span><br><span class="line">				f=0;</span><br><span class="line">				cout&lt;&lt;<span class="string">"N0"</span>&lt;&lt;endl;</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f!=0)cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月16日 逆序对</title>
    <url>/2020/04/19/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8816%E6%97%A5-%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14731" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>求所有长度为n的01串中满足如下条件的二元组个数： 设第i位和第j位分别位ai和aj（i&lt;j），则ai=1,aj=0。<br>答案对1e9+7取模。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:<br>输入一个n。<br>输出描述:<br>输出答案对1e9+7取模<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>说明<br><img src="https://img-blog.csdnimg.cn/2020041911312348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注:<br> n &lt;= 10^18^</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>就是一个求逆序对<br>我们看如果1后面有5个0，就能构成5个逆序对<br>也就是我们考虑任意两个位置，只要前面是1，后面是0，无论其他位置是什么数，都能构成一个逆序对。而这样的情况有多少种，就说明有多少逆序对<br>接下来我们就要用到组合排列<br>在n个位置任选两个位置的方案数C^2^<del>n</del> ,<br>其他n-2个位置就是放0和1，随便放，那就是n-2个2相乘，就是2^n-2^,所以总逆序对是C^2^<del>n*</del> 2^n-2^</p>
<p>C^2^<del>n*</del> 2^n-2^=n<em>(n-1)/2 *2^n-2^= n *(n-1)</em>2^n-3^</p>
<p>因为n可以很大，所以要用到快速幂<br>n=1要特判一下<br>我提交后一直卡在95%，原来当n=2时程序就死循环了，所以n=2也要特判</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line">		a=a*a%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;( ( ( n%mod )* ( ( n<span class="number">-1</span> ) % mod ) %mod )*(poww(<span class="number">2l</span>l,n<span class="number">-3</span>)%mod))%mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆序对</tag>
        <tag>排列组合</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月7号题目精讲 树</title>
    <url>/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13611" target="_blank" rel="noopener">树</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K<br>其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边；</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数表示方案数（mod 1e9+7）。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">39</span><br></pre></td></tr></table></figure>

<p>备注:</p>
<p>对于30%的数据，n≤10, k≤3；<br>对于100%的数据，n,k≤300。<br><strong>题解：</strong><br><del>shy爹有棵树</del><br>这个题也可以这么想，把相同颜色当成一个整体，连通块，问构成连通块的方案<br>我们用dp来计数<br>dp[i][j]表示i个点用了j个颜色的方案<br>那么转移方程就是<br>dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(k-(j-1))<br>dp[i][j]=第i个点和第i-1个点颜色相同或者第i-1个点所用的颜色与之前不同，之前用了（j-1）个颜色，这个点可用的颜色种类就是k-（j-1）<br>（可以理解成前者在一个连通块，后者不在一个连通块内）<br>因为数据给的肯定是棵树，那树的形状并不会影响结果，所以。。。也可以不输入那（n-1）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=303;</span><br><span class="line">ll mod =1e9+7;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line">int n,k;</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=1;j&lt;=k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==1&amp;&amp;j==1)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-(j-1)))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=(sum+dp[n][i])%mod;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有第二个办法：<br>一下为转载：<br>题目意思是用k个点把一个有n个节点的树染色,然后的地方必须联通,求有多少方案数?<br>下面给大家介绍两种做法..<br><img src="https://img-blog.csdnimg.cn/20200407185522399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">切边表示染色用的颜色个数,比如我要用3种颜色染色,那么我就只要考虑切2条边,比如切2-4,和3和7这是一种方案。若将树分割为 i个连通块，则需要删去 i−1条边，故方案数为 C^i-1^ n−1然后考虑染色,假如我现在切的是i条边,要从k种颜色中选出i中颜色染色，而且是有顺序的，故方案数为A(k,i+1).<br>综上，总的方案数为：<br><img src="https://img-blog.csdnimg.cn/20200407190618154.png" alt="在这里插入图片描述">可以线性求逆元，枚举 i 实现。</p>
<p>时间复杂度：O(n)<br>代码如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">const ll maxn=310;</span><br><span class="line">ll n,k,ans,inv[maxn],f[maxn];</span><br><span class="line">ll C(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[y]%mod*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll A(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    inv[0]=f[0]=inv[1]=f[1]=1;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=((mod-mod/i)*inv[mod%i])%mod,f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=(inv[i]*inv[i-1])%mod,f[i]=(f[i]*f[i-1])%mod;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=k&amp;&amp;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+(C(n-1,i-1)*A(k,i)%mod))%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.nowcoder.net/n/c76751c0215344ff99357aaee5235851" target="_blank" rel="noopener">转载地址</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>dp</tag>
        <tag>树上dp</tag>
        <tag>连通块</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】Shortest Path 4月3日题目精讲 DFS </title>
    <url>/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/</url>
    <content><![CDATA[<p>题号 NC13886<br><a href="https://ac.nowcoder.com/acm/problem/13886" target="_blank" rel="noopener">Shortest Path</a><br><a href="https://ac.nowcoder.com/acm/contest/10#description" target="_blank" rel="noopener">西南交通大学第十三届ACM决赛</a><br>题意：<br>一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？<br><strong>题解：</strong><br>如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式</p>
<a id="more"></a>
<p><img src="https://uploadfiles.nowcoder.com/files/20200404/543071257_1585932178570_20200404003717820.png" alt="在这里插入图片描述"><br>改变后路径更小，也就是说两两一组的点都不会覆盖其他点<br>那么每个点与其他点配对就有两者选择，一个与兄弟节点配对（中间跨过父亲点），另一个就是与父亲节点相连，这样选择肯定是最优的<br>如果这个节点所在的自树里有偶数个节点，那么他们内部配对就可以了（好像有什么怪怪的）<br>如果有奇数个节点，还有把父亲节点拉进来一起配对（这样才能组成偶数个）<br>来上代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx=1e4+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int head[maxx];</span><br><span class="line">int cnt=0;</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	ll w,v,u,next;</span><br><span class="line">&#125;edge[maxx*2];</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++cnt].u=u;</span><br><span class="line">	edge[cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll u,ll f,ll w)</span><br><span class="line">&#123;</span><br><span class="line">	ll sum=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=head[u];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].v!=f)sum+=dfs(edge[i].v,u,edge[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum%2)ans+=w;</span><br><span class="line">	<span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=T;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		memset(head,0,sizeof(head));</span><br><span class="line">		cnt=0;</span><br><span class="line">		ans=0;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=1;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			addt(x,y,z);</span><br><span class="line">			addt(y,x,z); </span><br><span class="line">		&#125;</span><br><span class="line">		dfs(1,0,0);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">//树上dfs</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>树上dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月8日题目精讲 黑白树</title>
    <url>/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13249" target="_blank" rel="noopener">试题链接</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。<br>你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<blockquote>
<p>第一行一个整数n (1 ≤ n ≤ 10^5^) 接下来n-1行，每行一个整数，依次为2号点到n号点父亲的编号。 最后一行n个整数为k[i]<br>(1 ≤ k[i] ≤ 10^5^)</p>
<p>样例解释:<br> 对节点3操作，导致节点2与节点3变黑 对节点4操作，导致节点4变黑 对节点1操作，导致节点1变黑</p>
</blockquote>
<p>输出描述:</p>
<p>一个数表示最少操作次数</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>题解：<br>一开始以为是红黑树的姐妹黑白树。。<br>求出最少的操作，用dfs</p>
<p>我们要不断更新染色的最远距离，还要把子节点的染色范围更新的父亲节点<br>比如1-&gt;2-&gt;3-.&gt;4-&gt;5-&gt;6-&gt;7<br>f[2]=5,f[3]=2<br>2节点就可以直接染色到6<br>操作完2之后，如果3就已经被染色了，如果3能染色的范围比fa[ 2 ]-1（因为2已经染色了本身，所以减一）还大，那染色范围可以更远<br>如果fa[3]&lt;fa[2]-1，就把f3的最远距离更新到fa[2]-1<br>总结就是fa[fa]=max（ fa [ fa ] , fa [ son ] - 1 ）<br>fa=0说明这个点无法被处理到<br>因为染色都是从下向上的。如果一个节点没办法被它子树的节点染色，那这个节点的父亲节点也没办法将它染色，他只能自己染色了</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100004</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;w[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w[x].size();j++)</span><br><span class="line">	&#123;</span><br><span class="line">		dfs(w[x][j]);</span><br><span class="line">		fa[x]=max( fa[ w[x][j] ]<span class="number">-1</span> , fa[x] );</span><br><span class="line">		a[x]=max( a[ w[x][j] ]<span class="number">-1</span> , a[x] );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		fa[x]=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	forr(n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		w[m].push_back(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】合集</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C"><a href="#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C" class="headerlink" title="2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C"></a>2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/">题解</a></p>
<h2 id="2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮"><a href="#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮"></a>2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">题解</a></p>
<a id="more"></a>
<h2 id="2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛"><a href="#2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛" class="headerlink" title="2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛"></a>2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/">题解</a></p>
<h2 id="2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5"><a href="#2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5" class="headerlink" title="2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5"></a>2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5</h2><p><a href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">题解</a></p>
<h2 id="2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛"><a href="#2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛" class="headerlink" title="2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛"></a>2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛</h2><p><a href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/">题解</a></p>
<h2 id="2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11"><a href="#2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11" class="headerlink" title="2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11"></a>2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/">题解</a></p>
<h2 id="2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12"><a href="#2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12" class="headerlink" title="2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12"></a>2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12</h2><p><a href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/">题解</a></p>
<h2 id="2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛"><a href="#2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛" class="headerlink" title="2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛"></a>2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛</h2><p><a href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/">题解</a></p>
<h2 id="2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛"><a href="#2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛" class="headerlink" title="2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛"></a>2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/">题解</a></p>
<h2 id="2020年4月7日-NC13611-树-牛客练习赛1"><a href="#2020年4月7日-NC13611-树-牛客练习赛1" class="headerlink" title="2020年4月7日 NC13611 树 牛客练习赛1"></a>2020年4月7日 NC13611 树 牛客练习赛1</h2><p><a href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/">题解</a></p>
<h2 id="2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮"><a href="#2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮" class="headerlink" title="2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮"></a>2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮</h2><p><a href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/">题解</a></p>
<h2 id="2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05"><a href="#2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05" class="headerlink" title="2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05"></a>2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05</h2><p><a href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/">题解</a></p>
<h2 id="2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮"><a href="#2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮"></a>2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/16/牛客网-【每日一题】4月10日-二分图染色-弱化版/">题解</a></p>
<h2 id="2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54"><a href="#2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54" class="headerlink" title="2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54"></a>2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54</h2><p><a href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/">题解</a></p>
<h2 id="2020年4月14日-NC14247-Xorto-Wannafly挑战赛1"><a href="#2020年4月14日-NC14247-Xorto-Wannafly挑战赛1" class="headerlink" title="2020年4月14日 NC14247 Xorto Wannafly挑战赛1"></a>2020年4月14日 NC14247 Xorto Wannafly挑战赛1</h2><h2 id="2020年4月15日-NC14248-Treepath-Wannafly挑战赛1"><a href="#2020年4月15日-NC14248-Treepath-Wannafly挑战赛1" class="headerlink" title="2020年4月15日 NC14248 Treepath Wannafly挑战赛1"></a>2020年4月15日 NC14248 Treepath Wannafly挑战赛1</h2><h2 id="2020年4月16日-NC14731-逆序对-Wannafly挑战赛6"><a href="#2020年4月16日-NC14731-逆序对-Wannafly挑战赛6" class="headerlink" title="2020年4月16日 NC14731 逆序对 Wannafly挑战赛6"></a>2020年4月16日 NC14731 逆序对 Wannafly挑战赛6</h2><h2 id="未完再续。。。"><a href="#未完再续。。。" class="headerlink" title="未完再续。。。"></a>未完再续。。。</h2>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>身体训练 </title>
    <url>/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/B" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v<br>米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v</p>
<a id="more"></a> 
<p>米/秒。每个人最初的最高速度为c[i] 米/秒，每轮衰减d[i]<br>米/秒，也就是说，如果i是第j个跑的，那么他的速度就是c[i]-(j-1)*d[i] 米/秒。<br>n个人初始以随机的顺序排列，每种顺序的概率完全相等，跑完一轮（每个人都追到排头一次，序列恢复原样）的期望需要的时间是多少？</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行整数n（&lt;=1000）, 实数v(&lt;=100) , 实数u(&lt;=10) 第二行n个实数每个人的速度c<a href="<=50000">i</a><br>第三行n个实数值每个人衰减量d<a href="<=10">i</a></p>
<p>输入数据保证每个人的速度不会衰减到&lt;=v</p>
</blockquote>
<p>输出描述:</p>
<p>答案保留3位小数。</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">37.618</span> <span class="number">0.422</span></span><br><span class="line"></span><br><span class="line"><span class="number">72.865</span> <span class="number">126.767</span> <span class="number">202.680</span> <span class="number">106.102</span> <span class="number">99.516</span> <span class="number">134.418</span> <span class="number">167.952</span> <span class="number">173.646</span> <span class="number">120.210</span> <span class="number">136.571</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.941</span> <span class="number">3.664</span> <span class="number">7.363</span> <span class="number">4.161</span> <span class="number">0.246</span> <span class="number">8.046</span> <span class="number">5.521</span> <span class="number">7.473</span> <span class="number">7.178</span> <span class="number">5.649</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0.815</span></span><br></pre></td></tr></table></figure>
<p>题解：<br>因为除了最后一个人，其他人速率相同，那么就可以把大家都看做静止的，最后一个人的速度就是V（原本）-V（其他人的速度），可以理解成相对速度<br>题目问跑完一轮，说明每个人在每个位置都会经历一遍。虽然每个快递员位置未定，在每个位置上概率都是1/n,但是无论是什么位置，快递员要跑的相对路长是一定的，都是u<em>n。<br>（相对路长就是在相对时间内跑的距离，大家都是静止的，一共n个人，最后一名前面有n-1个人，他要从最后跑到比排头还远u，跨过了n个间隙，距离是u</em>n）<br>如果i是第j个跑的，那么他的速度就是c[i]-(j-1)<em>d[i] 米/秒。v是其他人的速度<br>相对速度就是c[i]-(j-1)</em>d[i]-v<br>距离有了速度有了，相除就可以求时间<br>可以求出每个快递员跑过每个位置所需要的的时间，累加起来就可以<br>啥是期望？数学期望(mean)是试验中每次可能结果的概率乘以其结果的总和<br>所以最后再乘以概率 1/n</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> c[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> v,u,sum=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v&gt;&gt;u;</span><br><span class="line">	forr(n)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">	forr(n)<span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum+=u/( c[i] - v - ( j<span class="number">-1</span> ) * d[i] );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.3f"</span>,sum);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>相反数</title>
    <url>/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="https://ac.nowcoder.com/acm/contest/5203/A" target="_blank" rel="noopener">传送</a></p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一个数加上他的相反数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况</p>
<a id="more"></a> 
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>&amp;&amp;f==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">  	f=<span class="number">1</span>;</span><br><span class="line">	sum2=sum2*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum+sum2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月9日题目精讲 Running Median</title>
    <url>/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://ac.nowcoder.com/acm/problem/50940" target="_blank" rel="noopener">–&gt;链接&lt;—</a></p>
<blockquote>
<p>时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit<br> IO Format:%lld</p>
</blockquote>
<p>题目描述 </p>
<blockquote>
<p>For this problem, you will write a program that reads in a sequence of<br>32-bit signed integers. After each odd-indexed value is read, output<br>the median (middle value) of the elements received so far.</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>The first line of input contains a single integerP(1≤P≤1000), which is the number of data sets that follow. The<br>first line of each data set contains the data set number, followed by<br>a space, followed by an odd decimal integer (1≤M≤9999), giving the total number of signed integers to be<br>processed. The remaining line(s) in the dataset consists of the<br>values, 10 per line, separated by a single space. The last line in the<br>dataset may contain less than 10 values.</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>For each data set the first line of output contains the data set<br>number, a single space and the number of medians output (which should<br>be one-half the number of input values plus one). The output medians<br>will be on the following lines, 10 per line separated by a single<br>space. The last line may have less than 10 elements, but at least 1<br>element. There should be no blank lines in the output.</p>
</blockquote>
<p>示例1<br>输入<br>3<br>1 9<br>1 2 3 4 5 6 7 8 9<br>2 9<br>9 8 7 6 5 4 3 2 1<br>3 23<br>23 41 13 22 -3 24 -31 -11 -8 -7<br>3 5 103 211 -311 -45 -67 -73 -81 -99<br>-33 24 56<br>输出<br>1 5<br>1 2 3 4 5<br>2 5<br>9 8 7 6 5<br>3 12<br>23 23 22 22 13 3 5 5 3 -3<br>-7 -3</p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你m个数，一次输入，每当输入的个数为奇数时，输出按大小排列最中间的数<br>比如1 5 6 7 8<br>一开始输入1，输出1<br>然后输入1 5，不输出<br>输入1 5 6，输出5<br>输入1 5 6 7，不输出<br>输入1 5 6 7 8，输出6</p>
<h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>可以用堆来做<br>w1为大堆，w1用于存放小值<br>w2为小堆，w2存放大值<br>比如上面那个例子1 5 6 7 8<br>奇数位存在w1，偶数存在w2<br>如果w1.top()&gt;w2.top(),就是w1的最大比w2的最小值大，就将这两个值互换，始终保证，w1的值比w2的任意一个都小，这样无论数据怎么读入，w1的最大值始终都是最中间的数<br>看下面模拟：<br>第一轮：<br>w1:1<br>w2：0<br>二：<br>w1:1<br>w2:5<br>三：<br>w1:1 6<br>w2:5<br>6&gt;5<br>w1:1 5<br>w2:6<br>四<br>w1:1 5<br>w2: 7 6<br>五<br>w1:1 5 8<br>w2: 7 6<br>8&gt;6<br>w1:1 5 6<br>w2; 7 8<br>这样每奇数轮，w1的top位就是答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;w1;<span class="comment">//默认为大堆，从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;w2;<span class="comment">//默认为小堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">  <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p,m,x;</span><br><span class="line">    <span class="keyword">int</span> minn,maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;m;</span><br><span class="line">        case1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p,m/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)w1.push(x);</span><br><span class="line">            <span class="keyword">else</span> w2.push(x);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                minn=w1.top();</span><br><span class="line">                maxx=w2.top();</span><br><span class="line">                <span class="keyword">if</span>(minn&gt;maxx)</span><br><span class="line">                &#123;</span><br><span class="line">                    w1.pop();</span><br><span class="line">                    w2.pop();</span><br><span class="line">                    w1.push(maxx);</span><br><span class="line">                    w2.push(minn);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(case1!=<span class="number">0</span>&amp;&amp;case1%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                case1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==m)<span class="built_in">cout</span>&lt;&lt;w1.top();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,w1.top());</span><br><span class="line">                case1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(!w1.empty())w1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!w2.empty())w2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（这个题的格式我一开始一直没注意。。。）</p>
<h2 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h2><p>我看很多人都是这么做的，但是只能过50%的数据。。包括我自己<br>我看了清楚姐姐的代码稍微改一下：<br>我们在读入一个数后，直接与w1.top比较，小于就存进去，大了就存w2里<br>当w1的数量多了，就把堆顶拿出给w2（小根堆）<br>w2多了就给大根堆<br>这样维护出来其实和上面的方法差不多<br>因为总数是奇数，两个堆数量一定不一样，多的那方，堆顶就是答案<br>代码：<br>清楚阿姨（<del>狗头</del> ）代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//小根堆 ，存较大的一半的数</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">//大根堆 ，存较小的一半的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty()) q2.pop();  <span class="comment">//优先队列没有clear函数，要一个一个弹出</span></span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m ,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m, (n+<span class="number">1</span>)/ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &lt;= q1.top()) q1.push(x); <span class="comment">//如果当前值比大根堆堆顶小，说明在小的这二分之一，塞进大根堆</span></span><br><span class="line">            <span class="keyword">else</span>  q2.push(x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> num1= q1.size();</span><br><span class="line">            <span class="keyword">int</span> num2= q2.size();</span><br><span class="line">            <span class="keyword">if</span> (num1 - num2 &gt; <span class="number">1</span>)   <span class="comment">//大根堆里面元素多了，把堆顶拿出来塞近小根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.top());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(num2 - num1 &gt;<span class="number">1</span>) <span class="comment">//小根堆里面元素多了，把堆顶拿出来塞近大根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.top());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//目前的元素个数是奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                num1 = q1.size();</span><br><span class="line">                num2 = q2.size();</span><br><span class="line">                <span class="keyword">if</span>(num1 &gt; num2) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q1.top()); <span class="comment">//中位数在大根堆</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, q2.top());           <span class="comment">//中位数在小根堆</span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">19</span> &amp;&amp; i!=n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月25日 tokitsukaze and Soldier</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/</url>
    <content><![CDATA[<p>@<a href="牛客网【每日一题】3月25">TOC</a></p>
<p> 题号：NC50439<br>名称： tokitsukaze and Soldier<br>来源：练习赛50-C<br>链接: <a href="https://ac.nowcoder.com/acm/problem/50439" target="_blank" rel="noopener">牛客网</a>.</p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。<br>第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。<br>但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)<br>tokitsukaze想知道，团的战力最大为多少。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<p>第一行包含一个正整数n(1≤n≤10^5)。<br>接下来n行，每行包括2个正整数v,s(1≤v≤10^9,1≤s≤n)。</p>
<p>输出描述:</p>
<p>输出一个正整数，表示团的最大战力。</p>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>示例2<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">100 1</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>

<p><strong><em>思路</em></strong><br>所求的最大战斗力由v和s这两个因素限制。<br>结构体数组a存放v和s，然后对其排序，先按照s从大到小，如果s相同再排v，也是从大到小（先要保证足够的人数，后面好进行取舍）。<br>定义一个从小到大的优先队列q，ans相互跟随q，（q每次添加一个战力值，同时用ans加上战力值；ans删去，q也弹出），战力值的先后加入由s的排序决定，当q的元素数量大于当前s的值时（s是由大到小的排序的），就将多出的部分pop出（q是从小到大排序，所以弹出的总是其中最小值），再用ans减去，这样ans的值即为在人数限定在s内的最佳情况（因为弹出的是最小值，相对于前s个数的和，所以之后也不用再考虑被弹出的数），记录ans的最大值<br><del>我刚开始提交是70多分，想了一阵子才发现是数组开小了（笑哭）</del> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v,s;	</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.s!=b.s)<span class="keyword">return</span> a.s&gt;b.s;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.v&gt;a.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i].v&gt;&gt;a[i].s;</span><br><span class="line">	&#125;</span><br><span class="line">	sort (a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//	int tot=0;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> minn=maxn;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.push(a[i].v);</span><br><span class="line">		ans+=a[i].v;</span><br><span class="line">		<span class="keyword">while</span>(q.size()&gt;a[i].s)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			ans-=q.top();</span><br><span class="line"><span class="comment">//			printf("q.size=%d,a[i].s=%d,ans=%d\n",q.size(),a[i].s,ans);</span></span><br><span class="line">			q.pop();</span><br><span class="line"><span class="comment">//			tot--;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;maxx)maxx=ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;maxx;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code></code></pre>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
</search>
