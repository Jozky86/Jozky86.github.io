<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>About Me</title>
    <url>/2020/04/04/About-Me/</url>
    <content><![CDATA[<ul>
<li>A acmer, live in liaocheng,China</li>
<li>70%山东+20%四川+10%深圳=Me<br>姓名：Jozky<br>现居：聊城<br>大学：QDU<br>QQ:2830872914<br><img src="https://img-blog.csdnimg.cn/20200404170050150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
]]></content>
      <categories>
        <category>介绍</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeForces 282E Sausage Maximization</title>
    <url>/2020/04/16/CodeForces-282E-Sausage-Maximization/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">传送cf题目</a><br> <a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">传送牛客网题目</a><br><del>看了半个多小时的题解才搞明白，一下题解为自己的心得</del><br>参考博客（这两个讲的很详细）：<br><a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html" target="_blank" rel="noopener">参考二</a></p>
<blockquote>
<p>题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？</p>
<a id="more"></a>
<p>比如 一组数  1 2 3 4 5 6 你可以选择前缀为1 2，前缀异或和为3 选择后缀为4 5 6，后缀异或和为7<br>（前缀异或和）与（后缀异或和）异或值为4，但此时4并不是最大情况，求出最大情况</p>
</blockquote>
<p><strong>思路：</strong><br>首先讲个小例题：</p>
<blockquote>
<p>  给一个数 a，还有一堆数，怎么在这一堆数中找出一个数 b，a 和 b 的异或值最大？</p>
</blockquote>
<p>最暴力的方法无疑是（<del>老办法</del>）  枚举，枚举每一个b，但这样肯定不行<del>（不然我写这个博客干什么）</del> ，想想计算机的本质是啥？对，二进制。我们把a与这堆数转化成二进制，把后面这堆数装进一个字典树，当然要从最高位装，比如这堆数是123456，如图<img src="https://uploadfiles.nowcoder.com/files/20200326/543071257_1585188887053_20200326000539458.jpg" alt="这堆数是123456">根据异或规则不同为一，所以我们要使a与b异或最大，就要让b尽可能与a不同，a已经给定，b已经形成字典树，我们就从字典树root开始，尽量找出于a当前位置不同的数，直到找到最低位为止，那么这样找到的b满足条件。</p>
<p><strong>回到这个题：</strong><br>首先这些n个数组成一个区间w，w的全部异或结果是定值K,所以问题可以改成在区间w中取连续一段区间m，m的异或结果为X，m的前部分就成为区间w的前缀，后半部分就是区间w的后缀。<br>我们知道相同的数异或为零，那么X与K异或，重复的那部分区间异或后为零，就相当于是我们题目所求的<br>，所以就是求什么情况下X xor K最大。<br>发现现在的情况和一开始讲的例题很像了吧，我们假设有个Y，Y与K的每一个二进制相异，我们就要让X尽可能接近Y。<br>怎么实现呢？也是建一个字典树，将f[i]放进去（f[i]=a[1] ^ a[2]  ^ a[3] ^ …^ a[i]）,那么f[i]^f[j]=a[i+1] ^ a[i+2] ^ … ^a<a href="i之前的部分为i和j共有，一异或就相当于没了">j</a>可以表示i+1到j这段区间的异或值。<br>我们枚举区间m的结尾，每次用一个f[i]去匹配一个f[k]，使得f[k]^f[i]的值在高位上尽可能去接近Y，这样就相当于选出区间[k+1,i]de异或值作为X，每次在[1,i]区间内匹配出来一个最佳区间后，不断更新答案。<br>看懂了吗？这些神奇的操作，巧妙利用字典树（工具人石锤）来匹配。<br>(太晚了就不重新打代码了，借用下<a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a>的代码)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//范围是10的12次方，我们就将每个数固定为40位</span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define LL long long</span></span><br><span class="line"><span class="comment">#define rep(i,j,k) for(int i = j; i &lt;= k; i++ )</span></span><br><span class="line"><span class="comment">#define Rrep(i,j,k) for(int i = j; i &gt;= k; i-- )</span></span><br><span class="line"><span class="comment">#define Clean(x,y) memset(x,y,sizeof(x)) </span></span><br><span class="line">int n;</span><br><span class="line">LL a[100009];</span><br><span class="line">LL temp;</span><br><span class="line">LL ans;</span><br><span class="line"> </span><br><span class="line">LL p[45];</span><br><span class="line">int aim[45];</span><br><span class="line">int Next[1000000][2];</span><br><span class="line">int len;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    Clean(Next,0);</span><br><span class="line">    len = 0;</span><br><span class="line">&#125;</span><br><span class="line">void insert(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( !Next[now][k] ) Next[now][k] = ++len;</span><br><span class="line">        now = Next[now][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL query(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    LL ans = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( ( aim[i] &amp;&amp; Next[now][1-k] ) || ( !aim[i] &amp;&amp; Next[now][k] )  )</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=p[i];</span><br><span class="line">            now = aim[i]==1?Next[now][1-k]:Next[now][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now = aim[i]==0?Next[now][1-k]:Next[now][k];</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    rep(i,1,40) p[i] = p[i-1]&lt;&lt;1;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        ans = 0;</span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(<span class="string">"%I64d"</span>,&amp;temp);</span><br><span class="line">            a[i] = temp ^ a[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,a[n]);</span><br><span class="line">        rep(i,0,39)</span><br><span class="line">            <span class="keyword">if</span> ( a[n] &amp; p[i] ) aim[i] = 0; //计算Y</span><br><span class="line">            <span class="keyword">else</span> aim[i] = 1;</span><br><span class="line">        init();</span><br><span class="line">        insert(a[0]); </span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(a[i]);</span><br><span class="line">            ans = max(ans,query(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字典树</tag>
        <tag>前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS序讲解</title>
    <url>/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；<br>dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。</p>
<a id="more"></a>
<p>如图：<br><img src="https://img-blog.csdnimg.cn/20200407172327886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">dfs序就是：ABDDEEBCFHHFG<br>其实就是用dfs全部遍历一遍，不过我们不能光遍历还有动些小手脚，我们要在遍历的同时记录每个节点进栈与出栈的时间序列。</p>
<p>介绍两个基本函数：in[x],out[x]<br>dfs从根节点开始，这俩函数就分别记录每个节点x进入与离开的时间戳<br>还有num[x]，表示第x个节点的编号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">inline int dfs(int x,int fa,int time)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">in</span>[x]=++time;</span><br><span class="line">	num[time]=x;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=e[x].size();i++)</span><br><span class="line">	&#123;</span><br><span class="line">		int w=e[x][i];</span><br><span class="line">		<span class="keyword">if</span>(w==fa)<span class="built_in">continue</span>;//防止又从子节点找回去</span><br><span class="line">		dfs(w,x,time); </span><br><span class="line">	&#125;</span><br><span class="line">	out[x]=time;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">dfs(s,0,0);</span><br></pre></td></tr></table></figure>
<p>（具体情况根据，根据题目来写）<br><img src="https://img-blog.csdnimg.cn/20200407174719197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">num生成的就是一个新秩序，由每个节点进入关系而形成的<br>你仔细观察会发现：<br>序根节点的进栈时间&lt;子树的dfs&lt;根节点的出栈时间<br>这样不就成一个区间了<br>in[x]~out[x]是x为根节点的子树，划分为一个区间<br>然后什么单点修改，区间查询，莫队都可以用在树上，而且dfs序也是树链剖分的前驱知识</p>
<p>光说可能不怎么懂，我去找一些题，做完再更新例题</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title>C Looooops POJ - 2115</title>
    <url>/2020/07/05/C-Looooops-POJ-2115/</url>
    <content><![CDATA[<p><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">C Looooops POJ - 2115</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>A Compiler Mystery: We are given a C-language style for loop of type</p>
<figure class="highlight cpp"><figcaption><span>for (variable </span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">statement; </span><br></pre></td></tr></table></figure>

<p>I.e., a loop which starts by setting variable to value A and while<br>variable is not equal to B, repeats statement followed by increasing<br>the variable by C. We want to know how many times does the statement<br>get executed for particular values of A, B and C, assuming that all<br>arithmetics is calculated in a k-bit unsigned integer type (with<br>values 0 &lt;= x &lt; 2k) modulo 2k.</p>
</blockquote>
<a id="more"></a> 
<p><strong>Input</strong></p>
<blockquote>
<p>The input consists of several instances. Each instance is described by<br>a single line with four integers A, B, C, k separated by a single<br>space. The integer k (1 &lt;= k &lt;= 32) is the number of bits of the<br>control variable of the loop and A, B, C (0 &lt;= A, B, C &lt; 2k) are the<br>parameters of the loop.</p>
<p>The input is finished by a line containing four zeros.</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>The output consists of several lines corresponding to the instances on<br>the input. The i-th line contains either the number of executions of<br>the statement in the i-th instance (a single integer number) or the<br>word FOREVER if the loop does not terminate.</p>
</blockquote>
<p><strong>Sample Input</strong><br>3 3 2 16<br>3 7 2 16<br>7 3 2 16<br>3 4 2 16<br>0 0 0 0<br><strong>Sample Output</strong><br>0<br>2<br>32766<br>FOREVER</p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>初始值为A，每次可以增加C，值要mod2^k^,问mod后的值如果等于B，增加了几次C，如果无法等于B输出FOREVER</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>看一下我的推导：<br><img src="https://uploadfiles.nowcoder.com/files/20200705/543071257_1593953536536_202007052049339.png" alt="在这里插入图片描述"><br>你会发现其实就是扩展欧几里得的模板题，并求出最小正整数解<br>我们可以用 (x0 % b1 + b1 ) % b1得到它的最小正整数解了<br>此处x0= x * c / gcd(a,b)<br>详细证明看下面博客<br><a href="https://blog.csdn.net/qq_35975367/article/details/107072070" target="_blank" rel="noopener">扩展欧几里得讲解</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll A,B,C,K;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;K)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(A==<span class="number">0</span>&amp;&amp;B==<span class="number">0</span>&amp;&amp;C==<span class="number">0</span>&amp;&amp;K==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		ll x,y;</span><br><span class="line">		ll a=C;</span><br><span class="line">		ll b=(ll)<span class="number">1</span>&lt;&lt;K;</span><br><span class="line">		ll c=B-A;</span><br><span class="line">		ll gcd=exgcd(a,b,x,y);</span><br><span class="line">		<span class="keyword">if</span>(c%gcd!=<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"FOREVER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			 x=(x*(c/gcd))%b;</span><br><span class="line">             x=(x%(b/gcd)+b/gcd)%(b/gcd);</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>模板题</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>HAPPY2020暑假训练前复习</title>
    <url>/2020/07/03/HAPPY2020%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E5%89%8D%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="A-计蒜客-T1381"><a href="#A-计蒜客-T1381" class="headerlink" title="A.计蒜客 - T1381"></a>A.计蒜客 - T1381</h2><p>输出hello world<br>万恶之源</p>
<h2 id="B-51Nod-2060"><a href="#B-51Nod-2060" class="headerlink" title="B.51Nod - 2060"></a>B.51Nod - 2060</h2><p>全排列输出<br>不要用STL的next_permutation,会超时</p>
<a id="more"></a> 
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">14</span>;</span><br><span class="line"><span class="keyword">int</span> dt[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth==n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="keyword">if</span>(i==n)<span class="keyword">break</span>;</span><br><span class="line">        	<span class="keyword">if</span>(i==<span class="number">0</span>)<span class="built_in">cout</span>&lt;&lt;dt[i];</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">" "</span>&lt;&lt;dt[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            dt[depth]=i;</span><br><span class="line">            </span><br><span class="line">            dfs(depth+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-HDU-1715"><a href="#C-HDU-1715" class="headerlink" title="C HDU - 1715"></a>C HDU - 1715</h2><p>求斐波那契数列（不过比较大到1000）<br>用数组来存每一位，模拟进制运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>][<span class="number">605</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">0</span>] = f[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	f[<span class="number">1</span>][<span class="number">1</span>] = f[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt;= <span class="number">1000</span>;i ++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= len;j ++)</span><br><span class="line">		&#123;</span><br><span class="line">			f[i][j] += f[i<span class="number">-1</span>][j] + f[i<span class="number">-2</span>][j];</span><br><span class="line">			<span class="keyword">if</span>(f[i][j] &gt;= <span class="number">10</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				f[i][j+<span class="number">1</span>] += f[i][j] / <span class="number">10</span>;</span><br><span class="line">				f[i][j] %= <span class="number">10</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(f[i][len+<span class="number">1</span>]) len ++;</span><br><span class="line">		f[i][<span class="number">0</span>] = len;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, t;</span><br><span class="line">	init();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t --)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = f[n][<span class="number">0</span>];i &gt;= <span class="number">1</span>;i --)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d"</span>, f[n][i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q,i,j,temp=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    	  <span class="keyword">char</span> a[<span class="number">10010</span>]=<span class="string">"1"</span>,b[<span class="number">10010</span>]=<span class="string">"1"</span>,c[<span class="number">10010</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">	        <span class="keyword">int</span> len=max(<span class="built_in">strlen</span>(a),<span class="built_in">strlen</span>(b));</span><br><span class="line">	        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;len;j++)&#123;   <span class="comment">//模拟加法</span></span><br><span class="line">	            temp=<span class="number">0</span>;</span><br><span class="line">	            <span class="keyword">if</span>(a[j]&gt;=<span class="string">'0'</span>)&#123;    <span class="comment">//短的数不加</span></span><br><span class="line">	                temp+=a[j]-<span class="string">'0'</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span>(b[j]&gt;=<span class="string">'0'</span>)&#123;</span><br><span class="line">	                temp+=b[j]-<span class="string">'0'</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">if</span>(temp&gt;=<span class="number">10</span>)&#123;      <span class="comment">//判断进位</span></span><br><span class="line">	                <span class="keyword">if</span>(c[j]&gt;=<span class="string">'0'</span>)&#123;</span><br><span class="line">	                    c[j]+=temp<span class="number">-10</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">else</span>&#123;</span><br><span class="line">	                    c[j]+=temp<span class="number">-10</span>+<span class="string">'0'</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	                c[j+<span class="number">1</span>]=<span class="number">1</span>+<span class="string">'0'</span>;</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="keyword">else</span>&#123;</span><br><span class="line">	                <span class="keyword">if</span>(c[j]&gt;=<span class="string">'0'</span>)&#123;</span><br><span class="line">	                    <span class="keyword">if</span>(temp==<span class="number">9</span>)&#123;   <span class="comment">//若前位进位了,而且加上的数字是9,那么还要进位!!!</span></span><br><span class="line">	                        c[j]=<span class="string">'0'</span>;</span><br><span class="line">	                        c[j+<span class="number">1</span>]=<span class="string">'1'</span>;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                    <span class="keyword">else</span>&#123;</span><br><span class="line">	                        c[j]+=temp;</span><br><span class="line">	                    &#125;</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="keyword">else</span>&#123;</span><br><span class="line">	                    c[j]+=temp+<span class="string">'0'</span>;</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="built_in">strcpy</span>(a, b);</span><br><span class="line">	        <span class="built_in">strcpy</span>(b, c);</span><br><span class="line">	        <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span>(c));</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(b);</span><br><span class="line">	    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;  <span class="comment">//倒着输出</span></span><br><span class="line">	        <span class="built_in">printf</span>(<span class="string">"%c"</span>,b[i]);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-POJ-2251"><a href="#D-POJ-2251" class="headerlink" title="D POJ - 2251"></a>D POJ - 2251</h2><p>三维迷宫BFS搜就完事了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">32</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x;</span><br><span class="line">	<span class="keyword">int</span> y;</span><br><span class="line">	<span class="keyword">int</span> z;</span><br><span class="line">	<span class="keyword">int</span> step;</span><br><span class="line">&#125; start,fin; </span><br><span class="line"><span class="keyword">char</span> a[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dy[]=&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dz[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,r,c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(q.size()) q.pop();</span><br><span class="line">	<span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">	q.push(start);</span><br><span class="line">	vis[start.x][start.y][start.z]=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">while</span>(!q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		node temp=q.front();</span><br><span class="line">		q.pop();	</span><br><span class="line">		<span class="keyword">if</span>(temp.x==fin.x &amp;&amp; temp.y==fin.y &amp;&amp; temp.z==fin.z)</span><br><span class="line">		&#123;</span><br><span class="line">			flag=<span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Escaped in %d minute(s).\n"</span>,temp.step);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			node next;</span><br><span class="line">			next.x=temp.x+dx[i];</span><br><span class="line">			next.y=temp.y+dy[i];</span><br><span class="line">			next.z=temp.z+dz[i];</span><br><span class="line">			<span class="keyword">if</span>( next.x&gt;=<span class="number">0</span>&amp;&amp;next.x&lt;l &amp;&amp; next.y&gt;=<span class="number">0</span>&amp;&amp;next.y&lt;r &amp;&amp; next.z&gt;=<span class="number">0</span>&amp;&amp;next.z&lt;c </span><br><span class="line">			&amp;&amp;!vis[next.x][next.y][next.z] &amp;&amp; a[next.x][next.y][next.z]!=<span class="string">'#'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[next.x][next.y][next.z]=<span class="literal">true</span>;</span><br><span class="line">				next.step=temp.step+<span class="number">1</span>;</span><br><span class="line">				q.push(next); </span><br><span class="line">			&#125;		</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;c)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(l==<span class="number">0</span>&amp;&amp;r==<span class="number">0</span>&amp;&amp;c==<span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;l;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;c;k++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cin</span>&gt;&gt;a[i][j][k];</span><br><span class="line">					<span class="keyword">if</span>(a[i][j][k]==<span class="string">'S'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						start.x=i;</span><br><span class="line">						start.y=j;</span><br><span class="line">						start.z=k;</span><br><span class="line">						start.step=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(a[i][j][k]==<span class="string">'E'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						fin.x=i;</span><br><span class="line">						fin.y=j;</span><br><span class="line">						fin.z=k;</span><br><span class="line">						fin.step=<span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">		flag=<span class="number">0</span>;</span><br><span class="line">		bfs();	</span><br><span class="line">		<span class="keyword">if</span>(!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">"Trapped!"</span>&lt;&lt;<span class="built_in">endl</span>;	</span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-计蒜客-T2028"><a href="#E-计蒜客-T2028" class="headerlink" title="E 计蒜客 - T2028"></a>E 计蒜客 - T2028</h2><p>跳石头，经典二分题目， noip原题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[<span class="number">50004</span>];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> d,n,m;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n+<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(a[i]-a[now]&lt;x)tot++;</span><br><span class="line">		<span class="keyword">else</span> now=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tot&gt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;d&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125; </span><br><span class="line">	a[n+<span class="number">1</span>]=d;</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> r=d;</span><br><span class="line">	<span class="keyword">int</span> ans;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(judge(mid))&#123;</span><br><span class="line">			l=mid+<span class="number">1</span>;</span><br><span class="line">			ans=mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-HDU-1702"><a href="#F-HDU-1702" class="headerlink" title="F HDU - 1702"></a>F HDU - 1702</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cnd</span><span class="params">(<span class="keyword">int</span> sum,<span class="keyword">bool</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f==<span class="number">1</span>)</span><br><span class="line">	&#123;<span class="comment">//先进先出 </span></span><br><span class="line">		<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line">		<span class="built_in">string</span> a;</span><br><span class="line">		<span class="keyword">int</span> b;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">			<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'I'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">				q.push(b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(q.empty())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"None"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;q.front()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					q.pop();</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">		<span class="built_in">string</span> a;</span><br><span class="line">		<span class="keyword">int</span> b;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">			<span class="keyword">if</span>(a[<span class="number">0</span>]==<span class="string">'I'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cin</span>&gt;&gt;b;</span><br><span class="line">				s.push(b);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(s.empty())</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;<span class="string">"None"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">					s.pop();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;s;</span><br><span class="line"><span class="comment">//		cout&lt;&lt;s[0]&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">bool</span> f;</span><br><span class="line">		<span class="keyword">if</span>(s[<span class="number">2</span>]==<span class="string">'F'</span>)f=<span class="number">1</span>;<span class="comment">//先进先出 </span></span><br><span class="line">		<span class="keyword">else</span> f=<span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		cnd(a,f); </span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="G-POJ-1011"><a href="#G-POJ-1011" class="headerlink" title="G POJ - 1011"></a>G POJ - 1011</h2><p><a href="https://blog.csdn.net/qq_35975367/article/details/107050103" target="_blank" rel="noopener">详细题解</a></p>
<h2 id="H-POJ-3494"><a href="#H-POJ-3494" class="headerlink" title="H POJ - 3494"></a>H POJ - 3494</h2><p>求最大全1子矩阵的面积<br><a href="https://blog.csdn.net/qq_35975367/article/details/107015009" target="_blank" rel="noopener">题解</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2007</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> h[MAXN],s[MAXN],L[MAXN],R[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">0</span> &amp;&amp; h[s[t<span class="number">-1</span>]] &gt;= h[i])t--;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>) L[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> L[i] = s[t<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">		s[t++] = i;</span><br><span class="line">    &#125;<span class="comment">//找最左边 </span></span><br><span class="line">    t = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//最右边 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">0</span> &amp;&amp; h[s[t<span class="number">-1</span>]] &gt;= h[i])</span><br><span class="line">            t--;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>) R[i] = m<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> R[i] = s[t<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        s[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;  ++i)</span><br><span class="line">        ret = max(ret,h[i]*(R[i]-L[i]+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n,&amp;m))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">                <span class="keyword">if</span>(num==<span class="number">1</span>)h[j]++;</span><br><span class="line">                <span class="keyword">else</span> h[j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res,solve());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 5</span></span><br><span class="line"><span class="comment">0 1 1 0 1</span></span><br><span class="line"><span class="comment">0 1 1 1 1</span></span><br><span class="line"><span class="comment">0 0 1 1 0</span></span><br><span class="line"><span class="comment">0 0 1 1 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[<span class="number">2333</span>][<span class="number">2333</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[<span class="number">2333</span>][<span class="number">2333</span>],sta[<span class="number">2333</span>],L[<span class="number">2333</span>],R[<span class="number">2333</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//h[i][j]:第i行第j列元素往上最长的连续1长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//维护单调非递减栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> row)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>,tmp;</span><br><span class="line"></span><br><span class="line">h[row][m+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m + <span class="number">1</span>;j ++) </span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line">tmp = sta[top];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(h[row][tmp] &lt;= h[row][j]) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//以j作为延伸点，确定边界，保证单调性。 </span></span><br><span class="line"></span><br><span class="line">R[tmp] = j;</span><br><span class="line"></span><br><span class="line">-- top;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">L[j] = tmp;</span><br><span class="line"></span><br><span class="line">sta[++top] = j;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) </span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[row][j] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = R[j] - L[j] - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ans = max(ans,h[row][j] * len);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m) != EOF) </span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) </span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;<span class="built_in">map</span>[i][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j ++) </span><br><span class="line"></span><br><span class="line">		&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line"></span><br><span class="line">			&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>[i][j] == <span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">				&#123;</span><br><span class="line"></span><br><span class="line">h[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">map</span>[++i][j] == <span class="number">1</span>) h[i][j] = h[i<span class="number">-1</span>][j] + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">-- i;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) init(i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>比赛</category>
        <category>一起开心</category>
      </categories>
      <tags>
        <tag>一起开心</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA总结</title>
    <url>/2020/04/20/LCA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>@[TOC]<br><strong>我们通过这个题<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">洛谷P3379 【模板】最近公共祖先来讲LCA</a></strong></p>
<h2 id="LCA介绍"><a href="#LCA介绍" class="headerlink" title="LCA介绍"></a>LCA介绍</h2><p>lca是啥？最近公共祖先<br>就是：两个点在这棵树上距离最近的公共祖先节点<br>LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）<br>来看一个经典图<br><img src="https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p>LCA（4,5）=2<br>LCA（4,3）=1<br>LCA（2,1）=1</p>
<h2 id="解决方法概括："><a href="#解决方法概括：" class="headerlink" title="解决方法概括："></a>解决方法概括：</h2><p>常用四种方法 ：</p>
<ol>
<li>用倍增法求解，预处理复杂度是 O(nlogn) ,每次询问的复杂度是 O(logn), 属于在线解法。</li>
<li>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)，每次询问的复杂度为 O(1)，也是在线算法。</li>
<li>采用Tarjan算法求解，复杂度 O(α(n)+Q)，属于离线算法。</li>
<li>利用树链剖分求解，复杂度预处理O(n)，单次查询 O(logn) ，属于在线算法。</li>
</ol>
<h2 id="倍增法："><a href="#倍增法：" class="headerlink" title="倍增法："></a>倍增法：</h2><p>倍增：将两个点调到一个高度之后不断同时向上调到两点重合，即为两点的最近公共祖先<br>所用到的函数： grand[x][i] ,这个数组表示标号为x节点向上跳2^i步的节点<br>例如grand[5][0]=2（上图）, 节点5向上跳2^0^次（1次）到达节点2<br>grand[5][0]就是x的父节点<br>grand[x][1]就是x的父亲节点的父亲节点,就是grand[grand[x][0]][0]<br>这样就能得到一个递推式grand [ x ] [ i ] = grand [ grand [ x ] [ i-1 ] ] [ i-1 ]<br>先让x与y处于同一层，然后一起往上跳<br>跳多少呢？<br>比如dep[u]&gt;dep[v]<br>u要向上爬h=dep[u]-dep[v]，才能和v相同深度<br>将h进行二进制拆分，比如<br>h=(15)<del>10</del>=(1111)<del>2</del><br>h=(5)<del>10</del>=(101)<del>2</del><br>从低位开始i=0，如果是这一位是1，就grand[u][i]<br>任何调动次数都可以用2的指数幂之和来表示O（log n）<br>h = 5 = 2^2^ + 2^0^<br>h = 15 = 2^3^ + 2^2^ + 2^1^ + 2^0^<br>dep[]表示节点的深度<br>一开始跳log<del>2</del>^dep[x]-dep[y]^，log我们可以打表预处理。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当两点汇合时，就可以返回了<br>查询m组，总的复杂度应该是O(m log n)<br>输入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> to, nxt;</span><br><span class="line">	edge() &#123;&#125;</span><br><span class="line">	edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn) &#123;to = tt, nxt = nn;&#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[maxn], k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[k] = edge(v, head[u]);</span><br><span class="line">	head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">25</span>], dep[maxn], lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fath)</span><span class="comment">//初始化深度及祖祖辈辈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dep[now] = dep[fath] + <span class="number">1</span>;</span><br><span class="line">	fa[now][<span class="number">0</span>] = fath;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[now]; i++)</span><br><span class="line">		fa[now][i] = fa[fa[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];<span class="comment">//前文的递推式</span></span><br><span class="line">		</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = e[i].nxt)</span><br><span class="line">		<span class="keyword">if</span>(e[i].to != fath) dfs(e[i].to, now);<span class="comment">//继续往下遍历</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);<span class="comment">//保证x的深度更大，跳x</span></span><br><span class="line">	<span class="keyword">while</span>(dep[x] &gt; dep[y]) x = fa[x][lg[dep[x] - dep[y]]];</span><br><span class="line">	<span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;<span class="comment">//特判</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = lg[dep[x]]; i &gt;= <span class="number">0</span>; i--)<span class="comment">//倍增一起往上跳</span></span><br><span class="line">		<span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">	n = read(), m = read(), root = read();</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">int</span> u, v;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		u = read(), v = read();</span><br><span class="line">		add(u, v);</span><br><span class="line">		add(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	dfs(root, <span class="number">0</span>);</span><br><span class="line">	lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//	for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//		lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);//log打表，后面那一坨是特判一下i是否进位了</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		u = read(), v = read();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(u, v));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><p>倍增是在线算法<br>Tarjan是离线算法<br><img src="https://img-blog.csdnimg.cn/20200413143549700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Tarjan主要用到和并查集差不多的方法<br>比如查询7和5<br>我们从根节点出发，1-&gt;2-&gt;4-&gt;7，发现另一点5还没被查询，然后回溯，再遍历，7-&gt;4-&gt;8-&gt;4-&gt;2-&gt;5,遍历到点5，我们发现另外一个点7已经访问过，就到此结束。在这过程中我们用fa[]来表示父节点，就和并查集一样，回溯时，7-&gt;4 , fa[7]=4 ；8-&gt;4 , fa[8]=4； 4-&gt;2,fa[4]=2； 5-&gt;2,fa[5]=2。<br>这样当发现另外一个点已经标记了，那么这个点的祖先一定是两个点的lca（可以通过路径压缩）<br>在访问一个点时，我们会将与这点相关的一同询问，所以tarjan是强制离线<br>lca用于存结果，每个询问都存了两次（因为还要查询另外一个点是否已经访问过），最后输出时 i * 2<br>每组答案lca[i*2]（i-&gt;m）<br>大概时间复杂度为O(n+m）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root, lca[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn) &#123;to = tt, nxt = nn;&#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>], qe[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[maxn], k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[k] = edge(v, head[u]);</span><br><span class="line">    head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> qhead[maxn], qk = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qadd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qe[qk] = edge(v, qhead[u]);</span><br><span class="line">    qhead[u] = qk++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x? x : fa[x] = get(fa[x]);&#125;<span class="comment">//记得路径压缩！！</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> v;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)<span class="comment">//先深优遍历下去</span></span><br><span class="line">    &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;<span class="comment">//vis过了，就说明是父亲</span></span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[v] = u;<span class="comment">//回溯时记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = qhead[u]; ~i; i = qe[i].nxt)<span class="comment">//开始扫一遍关于u的所有询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        v = qe[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="comment">//另一个点访问过了，可以得出答案了</span></span><br><span class="line">        &#123;</span><br><span class="line">            lca[i] = get(v);</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) lca[i - <span class="number">1</span>] = lca[i];<span class="comment">//这里特殊处理是因为每个询问存了两次</span></span><br><span class="line">            <span class="keyword">else</span> lca[i + <span class="number">1</span>] = lca[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(qhead, <span class="number">-1</span>, <span class="keyword">sizeof</span> qhead);</span><br><span class="line">    n = read(), m = read(), root = read();</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">        fa[i] = i;<span class="comment">//顺便初始化fa</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fa[n] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();<span class="comment">//存储询问</span></span><br><span class="line">        qadd(u, v);</span><br><span class="line">        qadd(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tarjan(root);<span class="comment">//开始遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca[i &lt;&lt; <span class="number">1</span>]);<span class="comment">//每个询问都存了两次，所以要*2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>m较小时用倍增，较大时用Tarjan</strong></p>
<h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>欧拉序的定义<br>树在dfs过程中的节点访问顺序称为欧拉序.<br>那有人会问：dfs序和欧拉序啥区别？</p>
<p>dfs序：是指将一棵树被dfs时所经过的节点顺序（不绕回原点）。<br>欧拉序：就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序。</p>
<p><img src="https://img-blog.csdnimg.cn/20200420152716218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欧拉序与dfs序不同地方在于，欧拉序中每个节点可以出现多次，比如进入一次退出一次，又比如每次回溯时记录一次。</p>
<p>因此两个点的LCA，就是在该序列上两个点第一次出现的区间内深度最小的那个点<br>比如求D和E的LCA，D和E第一次出现的区间是DDCBE。这里面深度最小的就是点B，所以LCA（D，E）=B<br>这样就转化为区间RMQ问题，所以可以用ST表。<br>具体怎么做呢？<br>先求出欧拉序和每个节点的深度，同时用start[]记录每个节点第一次出现的位置<br>LCA ( T , u , v ) = RMQ ( B , start ( u ) , start ( v ) )<br> 然后直接用ST表求RMQ就行<br> <a href="https://editor.csdn.net/md/?articleId=105636769" target="_blank" rel="noopener">ST表详解</a> </p>
<p> 所用到数组：</p>
<blockquote>
<p> a.欧拉序：图的遍历（几种存储结构写法不太一样）</p>
<p>cnt:序列长度（每个元素一进一出共两次，记得最大初始化为2*MAXN）<br>oula[]:欧拉序列，记录编号   dfs前记录一次，dfs后（回溯）再记录一次<br>depth[]:每个编号的深度（也可以记录每个下标的深度，见注释）</p>
<p>start[]:每个编号第一次出现的序列下标</p>
<p>b.ST表  </p>
<p>minl[i][j]    记得第一层初始化为depth[]</p>
<p>pos[][]最值下标，第一层初始化为i</p>
<p>注意这里i是欧拉序列的下标，最终要的是编号（这里经常下标搞混！！）</p>
<p>欧拉序列下标=start【编号】</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[N]; </span><br><span class="line"><span class="keyword">int</span> oula[N&lt;&lt;<span class="number">1</span>],depth[N],start[N];<span class="comment">//N*2</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> minl[N&lt;&lt;<span class="number">1</span>][<span class="number">19</span>],pos[N&lt;&lt;<span class="number">1</span>][<span class="number">19</span>],len[N&lt;&lt;<span class="number">1</span>],vis[N],tmp; <span class="comment">//开20以上就TLE，自闭</span></span><br><span class="line"><span class="comment">//struct node&#123;int deep,order;&#125;minl[N][19];</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,m,s,x,y;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'*'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch=getchar()));</span><br><span class="line">    <span class="keyword">int</span> num=ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch=getchar()))num=num*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">    oula[++cnt]=now;<span class="comment">//入 </span></span><br><span class="line">    <span class="comment">//depth[cnt]=deep;</span></span><br><span class="line">    <span class="keyword">if</span>(depth[now]==<span class="number">0</span>)depth[now]=deep;</span><br><span class="line">    <span class="keyword">if</span>(start[now]==<span class="number">0</span>)start[now]=cnt;</span><br><span class="line">    <span class="keyword">int</span> z=G[now].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;z;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[now][i]!=fa)&#123;</span><br><span class="line">            dfs(G[now][i],now,deep+<span class="number">1</span>);</span><br><span class="line">            oula[++cnt]=now;<span class="comment">//出 </span></span><br><span class="line">            <span class="comment">//depth[cnt]=deep;</span></span><br><span class="line">            <span class="comment">//index[now]=cnt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">S_table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*N;++i) len[i]=(<span class="number">1</span>&lt;&lt;(tmp+<span class="number">1</span>))==i?++tmp:tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) minl[i][<span class="number">0</span>]= depth[oula[i]],pos[i][<span class="number">0</span>]=i;<span class="comment">//depth[i]</span></span><br><span class="line">    <span class="comment">//int l = log2((double)cnt);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=cnt;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) ) - <span class="number">1</span> &lt;=cnt;++i)&#123;</span><br><span class="line">            <span class="comment">//minl[i][j] = min(minl[i][j-1], minl[i + (1 &lt;&lt; (j-1) )][j-1]);</span></span><br><span class="line">          <span class="keyword">if</span>(minl[i][j<span class="number">-1</span>]&lt;minl[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>])minl[i][j]=minl[i][j<span class="number">-1</span>],pos[i][j]=pos[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> minl[i][j]=minl[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) )][j<span class="number">-1</span>],pos[i][j]=pos[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) )][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">    <span class="keyword">int</span> k=len[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//int k = log2((double)(r-l+1));</span></span><br><span class="line">    <span class="keyword">int</span> mid=r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(minl[l][k]&lt;=minl[mid][k])<span class="keyword">return</span> pos[l][k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> pos[mid][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();m=read();s=read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      x=read();y=read();</span><br><span class="line">      G[x].push_back(y);</span><br><span class="line">      G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dfs(s,<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//求欧拉序列</span></span><br><span class="line">    S_table();<span class="comment">//初始化st表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,oula[rmq(start[x],start[y])]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="树剖解法："><a href="#树剖解法：" class="headerlink" title="树剖解法："></a>树剖解法：</h2><p>树剖比Tarjan慢，但比倍增快</p>
<p>树剖详讲</p>
<p>树剖是把一棵树按子树大小分为链。树剖基本操作中有一个是求x到y的路径的边权和，或者是所有边权进行修改。我们可以用树剖的思路来写LCA。直接看点x和y是否在一条链上，不在则深度较大者跳到链头的父亲节点处，也就是跳出这条链；在则深度较浅者为LCA。<br>树剖一跳就是一条链，对于n极大的情况就相当于是倍增的再一优化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;//都是树剖模板操作，就不做多解释了。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn)</span><br><span class="line">    &#123;</span><br><span class="line">        to = tt, nxt = nn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[k] = edge(v, head[u]);</span><br><span class="line">    head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn], dep[maxn], size[maxn], son[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_getson</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[v] = u;</span><br><span class="line">        dfs_getson(v);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span>(size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> top[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_rewrite</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs_rewrite(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != fa[u] &amp;&amp; v != son[u]) dfs_rewrite(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])<span class="comment">//不同则跳</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &gt; dep[top[y]]) swap(x, y);</span><br><span class="line">        y = fa[top[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);<span class="comment">//输出深度较小者</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    n = read(), m = read(), root = read();</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//树剖初始化</span></span><br><span class="line">    dfs_getson(root);</span><br><span class="line">    dfs_rewrite(root, root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	u = read(), v = read();</span><br><span class="line">        ask(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增</tag>
        <tag>欧拉序</tag>
        <tag>ST表</tag>
        <tag>Tarjan</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>Maximize The Beautiful Value </title>
    <url>/2020/04/11/Maximize-The-Beautiful-Value/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/A" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he<br>thinks it’s not beautiful so he wants to make it beautiful. To make<br>it, HH will choose exactly one number and move it forward at least k<br>steps(i.e. you can move ai to aj if k≤i−j), and then he defines the<br>beautiful value F(n) as  HH asks you to calculate max(F(n))</p>
</blockquote>
<a id="more"></a> 
<blockquote>
<p><img src="https://uploadfiles.nowcoder.com/files/20200411/543071257_1586538298107_20200411005140649.png" alt="在这里插入图片描述"></p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p> The first line contains an positive integer T(1≤T≤10), represents<br>there are T test cases.   For each test case:   The first line<br>contains two positive integers n,k(1≤n≤105,1≤k&lt;n)，the length of the<br>sequence ,the least steps you need to move.   The second line contains<br>n integers a1,a2…an(1≤ai≤108) - the sequence.</p>
<p>输出描述:</p>
<p>For each test case, you should output the max F(n).</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure>

<p>说明</p>
<blockquote>
<p>In the first example, you can move the fifth number 4 for 3 steps and<br>make the sequence become [4,1,1,3,5], then the beautiful value is<br>4×1+1×2+1×3+3×4+5×5=46. You can also move the fifth number to make it<br>become [1,5,1,3,4], the beautiful value is also 46. In the second<br>example, you can move the  fifth number 5 for 2 steps and make the<br>sequence become [1,1,5,3,4] In the second example, you can move the<br>second number 1 for 1 steps and then the sequence is still [1,1,3,4,5]</p>
</blockquote>
<p>备注:</p>
<p>scanf is commended。</p>
<p> <strong>题解：</strong><br>比如：A B C D E<br>对应：1 2 3 4 5<br>此时的值为ans1=1<em>A+2<em>B+3</em>C+4<em>D+5</em>E<br>现在D移动到B前面，移动了两步<br>A D B C E<br>此时的值：ans2 = 1<em>A+2</em>D+3<em>B+4</em>C+5<em>E<br> =1</em>A+2<em>B+3</em>C+4<em>D+5</em>E-3<em>D+（B+C+D）<br>观察ans1与ans2相比有什么变化<br>发生改变就是减去这个数字的k倍，再加上被移动数字（共k个）的和<br>因为D向前移动k，说明D</em>i–&gt;D</em>(i-k)<br>BC因为D向前而被拱到后面，从B<em>i—&gt;b</em>(i+1)<br>被移动数字之和我们可以用前缀和pre实现<br>看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(w) for(int i=w;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line">	<span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		ans=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="comment">//	cin&gt;&gt;a[i];</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">			ans=ans+a[i]*i;</span><br><span class="line">	</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">					pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>((k+<span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			tot=max(tot,ans-a[i]*k+(pre[i<span class="number">-1</span>]-pre[i-k<span class="number">-1</span>]));</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀后缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2504 又见GCD</title>
    <url>/2020/07/03/HDU-2504-%E5%8F%88%E8%A7%81GCD/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">HDU 2504</a><br>@[toc]</p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>有三个正整数a,b,c(0&lt;a,b,c&lt;10^6)，其中c不等于b。若a和c的最大公约数为b，现已知a和b，求满足条件的最小的c。</p>
</blockquote>
<a id="more"></a> 
<p><strong>Input</strong></p>
<blockquote>
<p>第一行输入一个n，表示有n组测试数据，接下来的n行，每行输入两个正整数a,b。</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>输出对应的c，每组测试数据占一行。</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">12</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>



<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>单纯的暴力就能过。。。。<br>也可以加点小优化，gcd(a,c)=b,那么gcd(a/b,c/b)=1,所以枚举 i ,使得 i 满足gcd（a/b,i）=1<br>反正怎么都能过</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b==<span class="number">0</span>?a:gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">while</span>(n--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=b+<span class="number">1</span>;;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(gcd(a,i)==b)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>gcd</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj 1061 青蛙的约会</title>
    <url>/2020/07/03/Poj-1061-%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A/</url>
    <content><![CDATA[<blockquote>
<p>Time Limit: 1000MS        Memory Limit: 10000K Total Submissions: 143491        Accepted: 33018 Description</p>
</blockquote>
<p>@[toc]<br><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">题目传送</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>两只青蛙在网上相识了，它们聊得很开心，于是觉得很有必要见一面。它们很高兴地发现它们住在同一条纬度线上，于是它们约定各自朝西跳，直到碰面为止。可是它们出发之前忘记了一件很重要的事情，既没有问清楚对方的特征，也没有约定见面的具体位置。</p>
<a id="more"></a> 
<p>不过青蛙们都是很乐观的，它们觉得只要一直朝着某个方向跳下去，总能碰到对方的。但是除非这两只青蛙在同一时间跳到同一点上，不然是永远都不可能碰面的。为了帮助这两只乐观的青蛙，你被要求写一个程序来判断这两只青蛙是否能够碰面，会在什么时候碰面。<br>我们把这两只青蛙分别叫做青蛙A和青蛙B，并且规定纬度线上东经0度处为原点，由东往西为正方向，单位长度1米，这样我们就得到了一条首尾相接的数轴。设青蛙A的出发点坐标是x，青蛙B的出发点坐标是y。青蛙A一次能跳m米，青蛙B一次能跳n米，两只青蛙跳一次所花费的时间相同。纬度线总长L米。现在要你求出它们跳了几次以后才会碰面。</p>
</blockquote>
<p><strong>Input</strong></p>
<blockquote>
<p>输入只包括一行5个整数x，y，m，n，L，其中x≠y &lt; 2000000000，0 &lt; m、n &lt; 2000000000，0 &lt; L &lt;<br>2100000000。</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>输出碰面所需要的跳跃次数，如果永远不可能碰面则输出一行”Impossible”</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><p>我们先整合题意：<br>A初始为x，一次跳m<br>B初始为y，一次跳n<br>环形长度为L的线<br>我们可以根据题目列出公式：<br>（x+m * t）%L=(y+n * t)%L<br>也可以写成：<br>（x+m * t）+k * L=y+n * t<br>我们整理一下：<br>（m-n）* t+L * k=y -x<br>这就是我们要解的式子，看着熟悉吗？<br>是不是想起了这个形式：a * x+b * y=c<br>我们来看看对应关系：<br>a=m-n<br>b=L<br>c=y-x<br> （x , y ）= (t , k )<br> 我们可以用扩展欧几里得来求出特解，然后根据特解求出最小正整数解<br> 注意，要让a取正值</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">9973</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll r=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> r;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll x,y,m,n,l;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;m&gt;&gt;n&gt;&gt;l;</span><br><span class="line">	<span class="keyword">int</span> a=m-n;</span><br><span class="line">	<span class="keyword">int</span> b=l;</span><br><span class="line">	<span class="keyword">int</span> c=y-x;</span><br><span class="line">	<span class="keyword">if</span>(m&lt;n) </span><br><span class="line">	&#123;</span><br><span class="line">		a=-a;<span class="comment">//a取正值 </span></span><br><span class="line">		c=-c;</span><br><span class="line">	&#125;<span class="comment">//谁在后面，谁走的快 </span></span><br><span class="line">	<span class="comment">//ax+by=gcd(a,b)</span></span><br><span class="line">	<span class="keyword">int</span> gcd=exgcd(a,b,x,y);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"gcd="&lt;&lt;gcd&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">if</span>(c%gcd!=<span class="number">0</span>||m==n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"Impossible"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">		x=x*c/gcd;</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;"x="&lt;&lt;x&lt;&lt;endl;</span></span><br><span class="line">		ll t=b/gcd;</span><br><span class="line">	<span class="comment">//	cout&lt;&lt;"t="&lt;&lt;t&lt;&lt;endl;</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;=<span class="number">0</span>)x%=t;</span><br><span class="line">		<span class="keyword">else</span> x=x%t+t;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj 1284 Primitive Roots</title>
    <url>/2020/07/03/Poj-1284-Primitive-Roots/</url>
    <content><![CDATA[<p>@[toc]<br><a href="http://poj.org/problem?id=1284" target="_blank" rel="noopener">Poj 1284</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time Limit: <span class="number">1000</span>MS		Memory Limit: <span class="number">10000</span>K</span><br><span class="line">Total Submissions: <span class="number">6485</span>		Accepted: <span class="number">3697</span></span><br></pre></td></tr></table></figure>

<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>We say that integer x, 0 &lt; x &lt; p, is a primitive root modulo odd prime<br>p if and only if the set { (xi mod p) | 1 &lt;= i &lt;= p-1 } is equal to {<br>1, …, p-1 }. For example, the consecutive powers of 3 modulo 7 are<br>3, 2, 6, 4, 5, 1, and thus 3 is a primitive root modulo 7. Write a<br>program which given any odd prime 3 &lt;= p &lt; 65536 outputs the number of<br>primitive roots modulo p.</p>
</blockquote>
<a id="more"></a> 
<p><strong>Input</strong></p>
<blockquote>
<p>Each line of the input contains an odd prime numbers p. Input is<br>terminated by the end-of-file seperator.</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>For each p, print a single number that gives the number of primitive<br>roots in a single line.</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">79</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">24</span></span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给定一个p，存在一个x，使得x^i^%p的值的集合(i的范围是1~p-1）是{1,2…..p-1},求出x是多少？</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>数论题，涉及欧拉公式<br>先介绍一个概念：<br>设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。（其中φ(m)表示m的欧拉函数）<br>假设一个数g对于P来说是原根，那么g^i^ mod P的结果两两不同,且有 1&lt;g&lt;P, 0&lt;i&lt;P,那么g可以称为是P的一个原根,归根到底就是g^(P-1)^ = 1 (mod P)当且仅当指数为P-1的时候成立.(这里P是素数).<br>选自百度百科<br>结合到本题，x就是p的一个原根，那我们只需要找到满足x^p-1^=1(mod P)这个式子就可以，这个式子也就是欧拉公式的φ(p-1)<br><a href="https://blog.csdn.net/qq_35975367/article/details/105403662" target="_blank" rel="noopener">欧拉公式的讲解可以看这里</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">Euler</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	ll res=n;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n%i==<span class="number">0</span>)&#123;</span><br><span class="line">			n/=i;</span><br><span class="line">			res=res-res/i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(n%i==<span class="number">0</span>)n/=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1</span>)res=res-res/n;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> p;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;p)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Euler(p<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>原根</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Poj 3070 Fibonacci</title>
    <url>/2020/07/03/Poj-3070-Fibonacci/</url>
    <content><![CDATA[<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Time Limit: <span class="number">1000</span>MS		Memory Limit: <span class="number">65536</span>K</span><br><span class="line">Total Submissions: <span class="number">26063</span>		Accepted: <span class="number">17394</span></span><br></pre></td></tr></table></figure>
<p>@[toc]<br><a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener">Poj 3070 Fibonacci</a></p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>In the Fibonacci integer sequence, F0 = 0, F1 = 1, and Fn = Fn − 1 +<br>Fn − 2 for n ≥ 2. For example, the first ten terms of the Fibonacci<br>sequence are:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, …</p>
</blockquote>
<a id="more"></a> 
<blockquote>
<p>An alternative formula for the Fibonacci sequence is<br><img src="https://uploadfiles.nowcoder.com/files/20200702/543071257_1593675345758_20200702150853954.png" alt="在这里插入图片描述"> .</p>
<p>Given an integer n, your goal is to compute the last 4 digits of Fn.</p>
</blockquote>
<p><strong>Input</strong></p>
<p>The input test file will contain multiple test cases. Each test case consists of a single line containing n (where 0 ≤ n ≤ 1,000,000,000). The end-of-file is denoted by a single line containing the number −1.</p>
<p><strong>Output</strong></p>
<p>For each test case, print the last four digits of Fn. If the last four digits of Fn are all zeros, print ‘0’; otherwise, omit any leading zeros (i.e., print Fn mod 10000).</p>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">999999999</span></span><br><span class="line"><span class="number">1000000000</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">626</span></span><br><span class="line"><span class="number">6875</span></span><br></pre></td></tr></table></figure>

<p><strong>Hint</strong></p>
<blockquote>
<p>As a reminder, matrix multiplication is associative, and the product<br>of two 2 × 2 matrices is given by<br><img src="https://uploadfiles.nowcoder.com/files/20200702/543071257_1593675345797_20200702150951772.png" alt="在这里插入图片描述"> .</p>
<p>Also, note that raising any 2 × 2 matrix to the 0th power gives the<br>identity matrix:<br><img src="https://uploadfiles.nowcoder.com/files/20200702/543071257_1593675345770_202007021509552.png" alt="在这里插入图片描述"> </p>
</blockquote>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>其实就是求第x位斐波那契数列（记得mod10000），不过题目给你介绍了矩阵的相关知识，以及矩阵与斐波那契数列的联系，就是让你用矩阵快速幂来求斐波那契数列。</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><a href="https://blog.csdn.net/qq_35975367/article/details/107013556" target="_blank" rel="noopener">斐波那契数列的博客</a><br>我在这个博客里详细介绍了三种斐波那契数列的求法，其中就有矩阵快速幂的方法<br>所以我在这就不详细介绍，简单说说：<br>mul（a，b）是用来进行矩阵a与b的乘法运算<br> pow(mat a,ll n)//快速幂求矩阵a的n次幂 </p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">10000</span>;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;ll&gt; vec;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;vec&gt; mat;  </span><br><span class="line"><span class="function">mat <span class="title">mul</span><span class="params">(mat &amp;a,mat &amp;b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">mat <span class="title">c</span><span class="params">(a.size(),vec(b[<span class="number">0</span>].size()))</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;<span class="number">2</span>; k++)  </span><br><span class="line">            &#123;  </span><br><span class="line">                c[i][j]+=a[i][k]*b[k][j];<span class="comment">//矩阵的运算法则 </span></span><br><span class="line">                c[i][j]%=mod;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> c;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">mat <span class="title">pow</span><span class="params">(mat a,ll n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">mat <span class="title">res</span><span class="params">(a.size(),vec(a.size()))</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.size(); i++)  </span><br><span class="line">        res[i][i]=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) res=mul(res,a);  </span><br><span class="line">        a=mul(a,a);  </span><br><span class="line">        n/=<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function">ll <span class="title">solve</span><span class="params">(ll n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">mat <span class="title">a</span><span class="params">(<span class="number">2</span>,vec(<span class="number">2</span>))</span></span>;  </span><br><span class="line">    a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    a[<span class="number">0</span>][<span class="number">1</span>]=<span class="number">1</span>;  </span><br><span class="line">    a[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;  </span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;  </span><br><span class="line">    a=<span class="built_in">pow</span>(a,n);  </span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    ll n;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n!=<span class="number">-1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve(n)&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title>Music Problem</title>
    <url>/2020/04/17/Music-Problem/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/B" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Listening to the music is relax, but for obsessive(强迫症), it may be<br>unbearable. HH is an obsessive, he only start to listen to music at<br>12:00:00, and he will never stop unless the song he is listening ends</p>
<a id="more"></a> 
<p>at integral points (both minute and second are 0 ), that is, he can<br>stop listen at 13:00:00 or 14:00:00,but he can’t stop at 13:01:03 or<br>13:01:00, since 13:01:03 and 13:01：00 are not an integer hour time.<br>Now give you the length of some songs, tell HH whether it’s possible<br>to choose some songs so he can stop listen at an integral point, or<br>tell him it’s impossible. Every song can be chosen at most once.</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p> The first line contains an positive integer T(1≤T≤60), represents<br>there are T test cases.   For each test case:   The first line<br>contains an integer n(1≤n≤105), indicating there are n songs.   The<br>second line contains n integers a1,a2…an (1≤ai≤109 ), the ith integer<br>ai indicates the ith song lasts ai seconds.</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>For each test case, output one line “YES” (without quotes) if HH is<br>possible to stop listen at an integral point, and “NO” (without<br>quotes) otherwise.</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">1000</span> <span class="number">3000</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">3000</span> <span class="number">1600</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5400</span> <span class="number">1800</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br></pre></td></tr></table></figure>

<p>说明<br>In the first example it’s impossible to stop at an integral point.<br>In the second example if we choose the first and the third songs, they cost 3600 seconds in total, so HH can stop at 13:00:00<br>In the third example if we choose the first and the second songs, they cost 7200 seconds in total, so HH can stop at 14:00:00</p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你n个数，这些数自由组合能不能凑出3600的倍数</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始想到的是前缀和，后来感觉dp最直接<br>dp[x]=1表示能组成x这个数<br>dp = 0表示组不了<br>cnt是中间数组，暂时存储本轮的数值<br>因为求能不能组成3600，可以用mod，3600的倍数mod后都是0，直接求dp[0]是否等于1<br>每读取一个a，就把a与之前所求的值进行相加存在cnt里，然后再给dp[]，cnt就是工具人</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">3600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    		mem(dp);</span><br><span class="line">    	mem(cnt);</span><br><span class="line">    	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">int</span> a;</span><br><span class="line">    		<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    		a%=<span class="number">3600</span>;</span><br><span class="line">    		<span class="keyword">if</span>(!dp[<span class="number">0</span>])</span><br><span class="line">    		&#123;</span><br><span class="line">    			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">    			&#123;</span><br><span class="line">    				<span class="keyword">if</span>(dp[j]&gt;<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">    				&#123;</span><br><span class="line">    					cnt[(a+j)%<span class="number">3600</span>]=<span class="number">1</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(cnt[j])dp[j]=<span class="number">1</span>;</span><br><span class="line">					<span class="keyword">if</span>(cnt[j]==<span class="number">1</span>)cnt[j]=<span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			<span class="comment">//	mem(cnt);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!dp[<span class="number">0</span>])<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有个很玄学的地方我把读入n放在两个mem之前，数据就过了一半，放后面就ac了，不知道为什么<br><img src="https://img-blog.csdnimg.cn/20200416235545673.png" alt="在这里插入图片描述">看来卡时间卡的太紧了（笑哭）</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>ST表讲解</title>
    <url>/2020/04/20/ST%E8%A1%A8%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>ST表主要用于解决RMQ问题（区间最值问题）<br>当然你可以用线段树等，但今天用一种ST表（倍增算法）</p>
<p>ST表是倍增算法的一个典型应用<br>暴力做RMQ问题，往往会超时，ST表利用对其进行优化</p>
<a id="more"></a>
<p>给定一段序列A，ST算法能在O(NlogN)的时间预处理后，以O(1) 的复杂度查询，在线回答在一段区间l,r 中最大（小）值是多少。</p>
<p>f[i][j]用于表示在序列a中， 从第i位数字往后数2^j^个数，这个区间内的最大值，即区间[ i , i + 2 ^j^  ]内取得的最大值。</p>
<p>而这段区域的最大值等于左右子区间的最大值,2^j^ = 2 * 2 ^j-1^ = 2^j-1^ + 2^j-1^,把区间[i,i+2^j^]分成[i , i + 2^j-1^ ] [ i + 2^j-1^ + 1,2^j^]<br>(即f [ i ] [  j - 1 ] 与 f [ i + 2 ^j-1^ - 1 ] [ j -1 ]  ）</p>
<p>我们可得：F [ i ] [ j ] = max ( F [ i ] [ j - 1 ] , F [ i + 2 ^j-1^ - 1 ] [ j - 1 ] )<br>递推边界为f[i][0]=a[i]</p>
<p>其实说白了就是：相求大区间就先求出小区间，求小区间就求小小区间，一直这样套娃到最低层。</p>
<p>但是我们查询的区间不一定总是2的倍数，也有可能会超出区间<br>所以我们询问区间[l,r]时要用一个k，k=log<del>2</del>(len)，len为区间的长度，k向下取整<br>len=r-l+1<br>2^t^&lt;len&lt;2^t+1^<br>左右区间最大值分别是F [ l , k ] 与F [ r - 2^k^ + 1 , k ]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> f[<span class="number">100001</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span><span class="comment">//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=(<span class="keyword">int</span>)log2(n);k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            f[i][k]=max(f[i][k<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=log2(r-l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;query(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>ST表</tag>
        <tag>RMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2008]仪仗队</title>
    <url>/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20313" target="_blank" rel="noopener">牛客网</a><br>题目描述</p>
<blockquote>
<p>作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *<br>N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200409214206553.png" alt="在这里插入图片描述"><br>  <a id="more"></a><br>现在，C君希望你告诉他队伍整齐时能看到的学生人数。<br>输入描述:</p>
<p>共一个数N。</p>
<p>输出描述:</p>
<p>共一个数，即C君应看到的学生人数。</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>题解：<br>无限接近裸的欧拉函数<br>可以自己画图看看<br><img src="https://img-blog.csdnimg.cn/20200409214430241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我来解释下我这个图，我把n=4和5画在了一起，紫色区域是4<em>4区域，红色区域（也是整个区域）是5</em>5，左上角围成一个三角形区域，我们暂时不考虑对角线上的情况（因为对角线只能看见一个，后面的都被挡住了）。<br>左下角坐标是（0,0），我们发现能看的坐标（x，y），x与y为互质，如果不是互质，就一定会被挡住，（比如（2,4）会被（1,2）挡住，而1与2互质，（1,2）就不会被挡住）<br>我们用ans记录三角区域的情况数<br>就是ans=每行的情况加一起<br>那每行有多少种，可以用欧拉函数求<br>欧拉函数的ϕ(x)表示小于x的且与x互质的数有多少个<br>ϕ(3)=2（与3互质的有1和2，一共有两个）<br>特别注意ϕ(1)=1<br>公式法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="comment">// 直接求3</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Euler</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">  	 <span class="keyword">long</span> <span class="keyword">long</span> res = n;</span><br><span class="line">	 <span class="keyword">for</span>( <span class="keyword">long</span> <span class="keyword">long</span> i =<span class="number">2</span> ;i*i&lt;=n;i++)&#123;</span><br><span class="line">	 	<span class="keyword">if</span>( n %i == <span class="number">0</span> )&#123;</span><br><span class="line">			n/=i;</span><br><span class="line">			res = res - res/i;</span><br><span class="line">		&#125;</span><br><span class="line"> 		<span class="keyword">while</span>( n % i==<span class="number">0</span>)</span><br><span class="line">		 n/=i;</span><br><span class="line">	 &#125;</span><br><span class="line">     <span class="keyword">if</span>( n &gt; <span class="number">1</span> )</span><br><span class="line">	     res = res - res/n;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += Euler(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>筛法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(!phi[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    get_phi(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += phi[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>记录下欧拉函数的模板：<br>筛法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特性 :</span></span><br><span class="line"><span class="comment">1.若a为质数,phi[a]=a-1;</span></span><br><span class="line"><span class="comment">2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a</span></span><br><span class="line"><span class="comment">3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> m[n],phi[n],p[n],nump;</span><br><span class="line"><span class="comment">//m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m[i])<span class="comment">//i为素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[++nump]=i;<span class="comment">//将i加入素数数组p中</span></span><br><span class="line">            phi[i]=i<span class="number">-1</span>;<span class="comment">//因为i是素数,由特性得知    </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nump&amp;&amp;p[j]*i&lt;n;j++)  <span class="comment">//用当前已的到的素数数组p筛,筛去p[j]*i</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[p[j]*i]=<span class="number">1</span>;<span class="comment">//可以确定i*p[j]不是素数 </span></span><br><span class="line">            <span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="comment">//看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 </span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[p[j]*i]=phi[i]*p[j]; <span class="comment">//特性2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[p[j]*i]=phi[i]*(p[j]<span class="number">-1</span>); <span class="comment">//互质,特性3其,p[j]-1就是phi[p[j]]   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>公式法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eular</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n/=i,ret*=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,ret*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ret*=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N + <span class="number">0.5</span>), ans = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(N % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(N &gt; <span class="number">1</span>) ans = ans / N * (N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Recordering the Cows</title>
    <url>/2020/04/01/Recordering-the-Cows/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4860/B" target="_blank" rel="noopener">牛客网传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>Farmer John’s N cows (1 &lt;= N &lt;= 100), conveniently numbered 1..N, are<br>standing in a row. Their ordering is described by an array A, where<br>A(i) is the number of the cow in position i. Farmer John wants to<br>rearrange them into a different ordering for a group photo, described<br>by an array B, where B(i) is the number of the cow that should end up<br>in position i.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>For example, suppose the cows start out ordered as follows:</p>
<p>A = 5 1 4 2 3</p>
<p>and suppose Farmer John would like them instead to be ordered like<br>this:</p>
<p>B = 2 5 3 1 4</p>
<p>To re-arrange themselves from the “A” ordering to the “B” ordering,<br>the cows perform a number of “cyclic” shifts. Each of these cyclic<br>shifts begins with a cow moving to her proper location in the “B”<br>ordering, displacing another cow, who then moves to her proper<br>location, displacing another cow, and so on, until eventually a cow<br>ends up in the position initially occupied by the first cow on the<br>cycle. For example, in the ordering above, if we start a cycle with<br>cow 5, then cow 5 would move to position 2, displacing cow 1, who<br>moves to position 4, displacing cow 2, who moves to position 1, ending<br>the cycle. The cows keep performing cyclic shifts until every cow<br>eventually ends up in her proper location in the “B” ordering. Observe<br>that each cow participates in exactly one cyclic shift, unless she<br>occupies the same position in the “A” and “B” orderings.</p>
<p>Please compute the number of different cyclic shifts, as well as the<br>length of the longest cyclic shift, as the cows rearrange themselves.</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<ul>
<li><p>Line 1: The integer N.</p>
</li>
<li><p>Lines 2..1+N: Line i+1 contains the integer A(i).</p>
</li>
<li><p>Lines 2+N..1+2N: Line 1+N+i contains the integer B(i)</p>
</li>
</ul>
</blockquote>
<p>输出描述:</p>
<blockquote>
<ul>
<li>Line 1: Two space-separated integers, the first giving the number of cyclic shifts and the second giving the number cows involved in the<br>longest such shift.  If there are no cyclic shifts, output -1 for the<br>second number.</li>
</ul>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>题意：</strong><br>比如样例：通过移动A，将A=B<br>A     5 1 4 2 3<br>B   2 5 3 1 4<br>id   1 2 3 4 5<br>首先A中5要到1的位置（id=2），然后1移动到2的位置上（id=4），2要移动到5的位置上上（id=1）就是一个环，5-&gt;1-&gt;2-&gt;5，移动次数为3（也就是环的长度），除此之外还有4-&gt;3-&gt;4,移动次数为2，问将A通过移动转化成B的过程中，最长移动次数（即最长的环）是多少？环的数量是多少？<br><strong>题解：</strong><br><strong>（第一二个代码讲述的是我做错的过程，正解在是第三个）</strong><br><del>这题是我难以忘记的痛o(╥﹏╥)o</del><br><img src="https://img-blog.csdnimg.cn/20200330140321589.png" alt="在这里插入图片描述">看完这个题第一反应是noip考过的信息传递，所以一开始就用并查集来做，father[A[id]]=B[id]（就是id相对于A的父亲节点是B），因为一定能成环，所以就找一共多少个环，并求出最长环的长度<br>然而。。。。<img src="https://img-blog.csdnimg.cn/20200330140749959.png" alt="在这里插入图片描述"><br>我调了一阵子也但还是段错误，我换了个oj测评一下，然后就就AC了。。。玄学（<del>可能这个oj数据弱</del> ）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">int b[194000];</span><br><span class="line">int father[10003];</span><br><span class="line">bool f[100004];</span><br><span class="line">int maxx=0;</span><br><span class="line">void unionn(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    father[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x,int z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;//如果这个数在A中与B中位置相同，不需要交换</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;//如果这个数曾经被查询过</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;//如果这个环第一次被查询</span><br><span class="line">    z++;//z只有0和非0，来表示这个数之前是否被查询过</span><br><span class="line">    f[x]=1;</span><br><span class="line">    maxx=max(maxx,z);</span><br><span class="line">    find(father[x],z);//不断地向后查找5-&gt;1-&gt;2</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">        unionn(a[j],b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i,0))ant++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我痛定思痛，感觉是因为自身递归导致段错误，又改了一个思路，在寻找根节点并压缩路径的时候，顺便用dis来记录路径的长度，然后统计出最长的路径。<br>结果没段错误，但。。。wa了。。唉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">bool f[10034];//标记这个点所在的环是否被查询过</span><br><span class="line">int dis[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//  father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        int last=father[x];</span><br><span class="line">        father[x]=find(father[x]);</span><br><span class="line">        dis[x]+=dis[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line">void unionn(int aa,int bb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">    int x=find(aa);</span><br><span class="line">    int y=find(bb);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        father[x]=y;</span><br><span class="line">        dis[aa]=dis[bb]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);//更新最长边</span><br><span class="line">&#125;</span><br><span class="line">//int find(int x,int z)</span><br><span class="line">//&#123;</span><br><span class="line">//  <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;</span><br><span class="line">//  z++;</span><br><span class="line">//  f[x]=1;</span><br><span class="line">//  maxx=max(maxx,z);</span><br><span class="line">//  find(father[x],z);</span><br><span class="line">//&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">        <span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;//多少个环</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        unionn(a[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ant++;</span><br><span class="line">            f[father[i]]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我冷静一会后，重新思考，感觉把题越想越复杂了<br>样例：<br>A 5 1 4 2 3<br>B 2 5 3 1 4<br>f[]来标记id是否被查询过<br>我们用fa和fb来记录A和B中数的id位置，然后在union时,通过father[]来让 A中的点对应B的位置相互指向，A中id=1的5指向id=2的1，father[5]=1,依次类推<br>A    ——-&gt;5 1 4 2 3<br>fa——-&gt;2 4 5 3 1<br>B——–&gt;2 5 3 1 4<br>fb——–&gt;4 1 3 5 2<br>father—&gt;2 4 5 1 3<br>在查找时for(i-&gt;n),查询该点i后，接着查与这点i相连的点father[i]，并用f[]标记，ans记录长度，如果相连的点&gt;2(也就是这个点不是指向自己)，统计最长环长，并记录换的数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">int fa[10034];</span><br><span class="line">int fb[10034];</span><br><span class="line">int f[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">int ans;</span><br><span class="line">int id;</span><br><span class="line">int tot=0;</span><br><span class="line">int w=0;</span><br><span class="line">int find()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(f[i]==0)</span><br><span class="line">		&#123;</span><br><span class="line">			id=i;</span><br><span class="line">			ans=0;</span><br><span class="line">			<span class="keyword">while</span>(f[id]==0)</span><br><span class="line">			&#123;</span><br><span class="line">				f[id]=1;</span><br><span class="line">				ans++;</span><br><span class="line">				id=father[id];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(ans&gt;1)</span><br><span class="line">			&#123;</span><br><span class="line">				tot=max(ans,tot);</span><br><span class="line">				w++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(n)</span><br><span class="line">		&#123;</span><br><span class="line">					fa[a[i]]=i;	</span><br><span class="line">					fb[b[i]]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init1()</span><br><span class="line">&#123;</span><br><span class="line">		<span class="keyword">for</span>(n)</span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">			father[fa[a[i]]]=fb[a[i]];</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//	father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">//void unionn(int aa,int bb)</span><br><span class="line">//&#123;</span><br><span class="line">//	<span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">//	int x=find(aa);</span><br><span class="line">//	int y=find(bb);</span><br><span class="line">//	<span class="keyword">if</span>(x!=y)</span><br><span class="line">//	&#123;</span><br><span class="line">//		father[x]=y;</span><br><span class="line">//		dis[aa]=dis[bb]+1;</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);</span><br><span class="line">//&#125;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		<span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">//		<span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">if</span>(tot==0)</span><br><span class="line">//	&#123;</span><br><span class="line">//		cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">//		<span class="built_in">return</span> 0;</span><br><span class="line">//	&#125;</span><br><span class="line">//	int ant=0;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		</span><br><span class="line">//		unionn(a[i],b[i]);</span><br><span class="line">//	&#125;</span><br><span class="line">//	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//	&#123;</span><br><span class="line">//		<span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">//		&#123;</span><br><span class="line">//			ant++;</span><br><span class="line">//			f[father[i]]=1;</span><br><span class="line">//		&#125;</span><br><span class="line">//	&#125;</span><br><span class="line">//	cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">	init();</span><br><span class="line">	init1();</span><br><span class="line">	<span class="keyword">if</span>(find()==0)cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;w&lt;&lt;<span class="string">" "</span>&lt;&lt;tot;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于做出来了。。。我太菜了o(╥﹏╥)o</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Tr A HDU1575</title>
    <url>/2020/07/05/Tr-A-HDU1575/</url>
    <content><![CDATA[<p>@[toc]<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575" target="_blank" rel="noopener">Tr A HDU1575</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。</p>
</blockquote>
<a id="more"></a> 
<p><strong>Input</strong></p>
<blockquote>
<p>数据的第一行是一个T，表示有T组数据。 每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt;<br>10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。</p>
</blockquote>
<p><strong>Output</strong><br>对应每组数据，输出Tr(A^k)%9973。<br><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">99999999</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2686</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始以为A^k^的意思是主对角线各项的k次方的和，发现我太天真了，正确的含义应该是矩阵A的k次幂，然后再求主对角线各项的和<br>用 矩阵快速幂 来做<br>也算是模板题把</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 15</span></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>//定义一个结构体，方便传递值</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">mul</span><span class="params">(matrix a, matrix b)</span>    <span class="comment">//矩阵求积, 矩阵乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.m[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.m[i][j] += (a.m[i][k] * b.m[k][j]) % <span class="number">9973</span>;</span><br><span class="line">                ans.m[i][j] %= <span class="number">9973</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">quick_pow</span><span class="params">(matrix a, <span class="keyword">int</span> b)</span>    <span class="comment">//矩阵快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                ans.m[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.m[i][j] = <span class="number">0</span>;<span class="comment">//这里要初始化为单位矩阵，类比普通快速幂这里初始化为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)<span class="comment">//方法与普通快速幂相同，只有乘法的实现不同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            ans = mul(a, ans);</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a.m[i][j];</span><br><span class="line"></span><br><span class="line">        matrix tmp = quick_pow(a, k);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            ans += tmp.m[i][i] % <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line">        ans %= <span class="number">9973</span>;    <span class="comment">// 最后这里一定要再次取余！</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1059 Dividing</title>
    <url>/2020/06/16/hdu-1059-Dividing/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1059" target="_blank" rel="noopener">Hdu链接</a><br><a href="https://ac.nowcoder.com/acm/problem/105611" target="_blank" rel="noopener">牛客网链接</a><br>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://img-blog.csdnimg.cn/2020061620152084.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a> 
<p>输入描述:<br><img src="https://img-blog.csdnimg.cn/20200616201546929.png" alt="在这里插入图片描述"><br>输出描述:<br><img src="https://img-blog.csdnimg.cn/20200616201556645.png" alt="在这里插入图片描述"><br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Collection #<span class="number">1</span>:</span><br><span class="line">Can<span class="number">'</span>t be divided.</span><br><span class="line"></span><br><span class="line">Collection #<span class="number">2</span>:</span><br><span class="line">Can be divided.</span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>有价值分别是1~6的6种大理石，每种大理石的数量是ni，问能否将这些大理石分成完全相同的两部分？</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>这个题和<a href="https://blog.csdn.net/qq_35975367/article/details/106783250" target="_blank" rel="noopener">hdu 2844 Coins</a>做法基本一样，不过本题要稍微转变下思路<br>我们考虑用背包方法来做，题目给了数量，价值，却没有给总容量和体积。我们结合题意思考一下，要分成价值完全相同的两份，其实就是找到一份大理石，使得这一份的价值是总价值的一半。如果我们这样想，我们就会发现，总容量其实就是大理石总价值的一半，每个大理石的体积就是其价值，我们要做的就是找到“一些商品使得其体积满足总容量一半的情况是否存在”，这不就可以用混合背包来做。<br>对于数量多的用完全背包，对于数量少的用多重背包</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">120005</span>];</span><br><span class="line"><span class="keyword">bool</span> f=<span class="number">0</span>;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zerone</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=sum;i&gt;=cost;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=max(dp[i],dp[i-cost]+val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complet</span><span class="params">(<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cost;i&lt;=sum;i++)</span><br><span class="line">	dp[i]=max(dp[i],dp[i-cost]+cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cost*num&gt;=sum)</span><br><span class="line">	&#123;</span><br><span class="line">		complet(cost);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		zerone(i*cost,i*val);</span><br><span class="line">		num-=i;</span><br><span class="line">	&#125;</span><br><span class="line">	zerone(num*cost,num*val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>]&gt;&gt;a[<span class="number">3</span>]&gt;&gt;a[<span class="number">4</span>]&gt;&gt;a[<span class="number">5</span>]&gt;&gt;a[<span class="number">6</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		case1++;</span><br><span class="line">		</span><br><span class="line">		f=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">2</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">3</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">4</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">5</span>]==<span class="number">0</span>&amp;&amp;a[<span class="number">6</span>]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Collection #%d:\n"</span>,case1);</span><br><span class="line">		sum=a[<span class="number">1</span>]*<span class="number">1</span>+<span class="number">2</span>*a[<span class="number">2</span>]+<span class="number">3</span>*a[<span class="number">3</span>]+<span class="number">4</span>*a[<span class="number">4</span>]+<span class="number">5</span>*a[<span class="number">5</span>]+<span class="number">6</span>*a[<span class="number">6</span>];</span><br><span class="line">		<span class="keyword">if</span>(sum%<span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Can't be divided.\n"</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		sum/=<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			mul(i,i,a[i]);<span class="comment">//花费，价值，数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(dp[sum]==sum)f=<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(f==<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Can be divided."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Can't be divided."</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包问题</tag>
        <tag>混合背包</tag>
        <tag>二进制优化</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1525 Euclid‘s Game</title>
    <url>/2020/07/03/hdu-1525-Euclid%E2%80%98s-Game/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/submit.php?pid=1525" target="_blank" rel="noopener">hdu 1525</a><br>@[toc]</p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Two players, Stan and Ollie, play, starting with two natural numbers.<br>Stan, the first player, subtracts any positive multiple of the lesser<br>of the two numbers from the greater of the two numbers, provided that<br>the resulting number must be nonnegative. Then Ollie, the second<br>player, does the same with the two resulting numbers, then Stan, etc.,<br>alternately, until one player is able to subtract a multiple of the<br>lesser number from the greater to reach 0, and thereby wins. For<br>example, the players may start with (25,7): </p>
<p>25 7 11 7 4 7 4 3 1 3 1 0 </p>
<p>an Stan wins.</p>
</blockquote>
<p><strong>Input</strong></p>
<blockquote>
<p>The input consists of a number of lines. Each line contains two<br>positive integers giving the starting two numbers of the game. Stan<br>always starts.</p>
</blockquote>
<p><strong>Output</strong></p>
<blockquote>
<p>For each line of input, output one line saying either Stan wins or<br>Ollie wins assuming that both of them play perfectly. The last line of<br>input contains two zeroes and should not be processed.</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">34</span> <span class="number">12</span></span><br><span class="line"><span class="number">15</span> <span class="number">24</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Stan wins</span><br><span class="line">Ollie wins</span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>n和m两个数，两个人轮流进行操作，每次可以剪去i*min（n，m），i自定（剪去n和m中最小数的倍数），有一个数减到0即为胜利，问先手后手谁先赢</p>
<a id="more"></a> 
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><strong>非正式解答：</strong><br>一看是博弈论我就开始搜索我脑中的知识（发现为空）<br>直觉告诉我肯定有规律和公式，我便自造数据多次实验，最终发现最先遇到一个数是另一个数的两倍以上时，即可以成功（也就是（n/m&gt;1），此处n&gt;m）,特殊情况是n和m相同时也是谁遇到谁赢。综合下就是：谁遇到n/m!=1时，谁就赢。<br>为什么呢？我是这么理解的，当遇到n/m&gt;1时，此人可以选择减一个m，也可以选减多个m，而这对后面的情况是有影响的，而总有一种情况是对自己有利的，只要按照这个方向走，一定能赢（多局试验后得出）<br>当然如果全程n/m==1，那么双方的操作都是固定的，没有选择空间，因为都只能减一次，所以轮流操作，奇数个操作流程先手赢，反之后手赢<br><strong>正式解答：</strong><br><a href="https://blog.csdn.net/blessLZH0108/article/details/78271679" target="_blank" rel="noopener">正规解答来自</a><br>令n为较小的数，m为较大的数，可以发现：<br>当m%n=0时，先手必胜</p>
<p>当m&gt;=2n时，如果（m%n，m）为必胜态，先手可以先将局势变为（m%n+n，n），则后手只能将局势变为（m%n，n）；如果（m%n，n）为必败态，先手可以直接将局势变为（m%n，n）。因此，不论（m%n，n）为什么态，先手都必胜</p>
<p>当2n&gt;m&gt;n时，那就是一步一步走下去，直到出现m%n=0||m&gt;=2n结束</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)swap(n,m);</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">1</span>;<span class="comment">//记录步伐</span></span><br><span class="line">        <span class="keyword">int</span> f=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>&amp;&amp;m!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(m&gt;n)swap(n,m);</span><br><span class="line">            <span class="keyword">if</span>(n/m!=<span class="number">1</span>||m==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                f=ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            n-=m;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f&amp;<span class="number">1</span>)<span class="built_in">cout</span>&lt;&lt;<span class="string">"Stan wins"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Ollie wins"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>博弈论</tag>
        <tag>规律</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-1171 Big Event in HDU</title>
    <url>/2020/06/16/hdu-1171-Big-Event-in-HDU/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1171" target="_blank" rel="noopener">hdu试题链接</a><br>@[toc]</p>
<h2 id="Problem-Description"><a href="#Problem-Description" class="headerlink" title="Problem Description"></a>Problem Description</h2><blockquote>
<p>Nowadays, we all know that Computer College is the biggest department<br>in HDU. But, maybe you don’t know that Computer College had ever been<br>split into Computer College and Software College in 2002. </p>
<a id="more"></a> The
<p>splitting is absolutely a big event in HDU! At the same time, it is a<br>trouble thing too. All facilities must go halves. First, all<br>facilities are assessed, and two facilities are thought to be same if<br>they have the same value. It is assumed that there is N (0&lt;N&lt;1000)<br>kinds of facilities (different value, different kinds).</p>
</blockquote>
<p>Input</p>
<blockquote>
<p>Input contains multiple test cases. Each test case starts with a<br>number N (0 &lt; N &lt;= 50 – the total number of different facilities).<br>The next N lines contain an integer V (0&lt;V&lt;=50 –value of facility)<br>and an integer M (0&lt;M&lt;=100 –corresponding number of the facilities)<br>each. You can assume that all V are different. A test case starting<br>with a negative integer terminates input and this test case is not to<br>be processed.</p>
</blockquote>
<p>Output</p>
<blockquote>
<p>For each case, print one line containing two integers A and B which<br>denote the value of Computer College and Software College will get<br>respectively. A and B should be as equal as possible. At the same<br>time, you should guarantee that A is not less than B.</p>
</blockquote>
<p>Sample Input</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br><span class="line"><span class="number">20</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">1</span> </span><br><span class="line"><span class="number">20</span> <span class="number">2</span></span><br><span class="line"><span class="number">30</span> <span class="number">1</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>



<p>Sample Output</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">20</span> <span class="number">10</span></span><br><span class="line"><span class="number">40</span> <span class="number">40</span></span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>有n个物品，每个物品都有价值和个数，要把这些物品分成两份，尽可能使得这两份相等，如果不相同就要保证第一份不小于第二份。答案是分别输出两份的价值</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>混合背包的题目，我这篇讲<a href="https://blog.csdn.net/qq_35975367/article/details/106794526" target="_blank" rel="noopener">hdu 1059 Dividing</a>的题解几乎和这样是一样的，就是读入方式不一样，稍微改一改代码就可以<br>这可以当做是模板题吧，建议熟读（滑稽）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">120005</span>];</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">140</span>],m[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zerone</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=sum;i&gt;=cost;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=max(dp[i],dp[i-cost]+val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complet</span><span class="params">(<span class="keyword">int</span> cost)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cost;i&lt;=sum;i++)</span><br><span class="line">	dp[i]=max(dp[i],dp[i-cost]+cost);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cost*num&gt;=sum)</span><br><span class="line">	&#123;</span><br><span class="line">		complet(cost);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		zerone(i*cost,i*val);</span><br><span class="line">		num-=i;</span><br><span class="line">	&#125;</span><br><span class="line">	zerone(num*cost,num*val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n&gt;=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> sum1;</span><br><span class="line">		sum1=<span class="number">0</span>;</span><br><span class="line">			<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">				<span class="built_in">memset</span>(v,<span class="number">0</span>,<span class="keyword">sizeof</span>(v));</span><br><span class="line">					<span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;v[i]&gt;&gt;m[i];</span><br><span class="line">			sum1+=v[i]*m[i];</span><br><span class="line">		&#125;</span><br><span class="line">	sum=sum1/<span class="number">2</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			mul(v[i],v[i],m[i]);<span class="comment">//花费，价值，数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">		sum=max(dp[sum],sum1-dp[sum]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="string">" "</span>&lt;&lt;sum1-sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">10 1</span></span><br><span class="line"><span class="comment">20 1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">10 1 </span></span><br><span class="line"><span class="comment">20 2</span></span><br><span class="line"><span class="comment">30 1</span></span><br><span class="line"><span class="comment">-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包问题</tag>
        <tag>混合背包</tag>
        <tag>二进制优化</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】4月6日数码</title>
    <url>/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<p>题目：<a href="https://ac.nowcoder.com/acm/problem/13221" target="_blank" rel="noopener">数码</a><br>来源：<a href="https://ac.nowcoder.com/acm/contest/5#description" target="_blank" rel="noopener">美团2017年CodeM大赛-资格赛</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x<br>的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 </p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>一行，两个整数 l 和 r (1 ≤ l ≤ r ≤ 10^9^)。</p>
</blockquote>
<p>输出描述:</p>
<p>输出9行。</p>
<blockquote>
<p>第 i 行，输出数码 i 出现的次数。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>题解：<br>先介绍一个函数：<br>solve（a，b）就是从1<del>a中数码b的倍数出现的次数<br>solve(a,b)=a/b<br>那么求[l,r]的话，就用solve(r,b)-solve(l-1,b)，大致可以理解成前缀和那种<br>num就是0</del>9，计算每个num对应的区间<br>最高位是1的话：1,10 ~ 19,100 ~ 199， 1000 ~ 1999….<br>最高位是2的话：2,20 ~ 29,200 ~ 299， 2000 ~ 2999….</p>
<p>因为我们只记录约数的最高位，像1999，约数就是1和1999，我们只记录最高位，那么就是有两个1<br>那么我们枚举以num开头的数，计算它的倍数在[l,r]中出现的次数。<br>按照几位数和最高位是几进行枚举，有多少这样的数直接统计就ok<br>solve(r,num)-solve(l-1,num)<br>枚举num的值<br>让最高位等于x时num枚举相对应的区间（从x<em>10^y-1^~(x+1)</em>10^y-1^-1）y=1.2.3….<br>有部分数会被算重复，因为有完全平方数存在，<br>再运用整除分块技巧，让复杂度降到O(根号n)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">ll minn(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(a&gt;=b)</span><br><span class="line">	&#123;	</span><br><span class="line">		<span class="built_in">return</span> b;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	&#123;</span><br><span class="line">	//	cout&lt;&lt;a;</span><br><span class="line">	 <span class="built_in">return</span> a;</span><br><span class="line">	 	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll a, ll b) &#123;</span><br><span class="line">  ll res = 0;</span><br><span class="line">   ll beg;</span><br><span class="line">   ll end;</span><br><span class="line">  <span class="keyword">for</span> (ll i = 1; i &lt;= a / b; i *= 10) &#123;</span><br><span class="line">    beg = b * i;//区间开头</span><br><span class="line">    </span><br><span class="line">	 end = minn(a, beg + i - 1);//区间结尾</span><br><span class="line">	 int k;</span><br><span class="line">    <span class="keyword">for</span> (int j = beg; j &lt;= end; j = k + 1) &#123;</span><br><span class="line">      k = min(a / (a / j), end);</span><br><span class="line">      //cout&lt;&lt;a/(a/i)&lt;&lt;<span class="string">" "</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">      res += (k - j + 1) * (a / j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll l,r;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">   cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=9;i++)&#123;</span><br><span class="line">        cout&lt;&lt;solve(r,i)-solve(l-1,i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>整除分块</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 1576 A/B</title>
    <url>/2020/07/03/hdu-1576-A-B/</url>
    <content><![CDATA[<p>@[toc]<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576%28HDU-1576%29" target="_blank" rel="noopener">hdu 1576</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>要求(A/B)%9973，但由于A很大，我们只给出n(n=A%9973)(我们给定的A必能被B整除，且gcd(B,9973) = 1)。</p>
</blockquote>
<p><strong>Input</strong></p>
<blockquote>
<p>数据的第一行是一个T，表示有T组数据。 每组数据有两个数n(0 &lt;= n &lt; 9973)和B(1 &lt;= B &lt;= 10^9)。</p>
</blockquote>
<a id="more"></a> 
<p><strong>Output</strong></p>
<blockquote>
<p>对应每组数据输出(A/B)%9973。</p>
</blockquote>
<p><strong>Sample Input</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1000</span> <span class="number">53</span></span><br><span class="line"><span class="number">87</span> <span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p><strong>Sample Output</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7922</span></span><br><span class="line"><span class="number">6060</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>先了解一些概念：<br>费马小定理：a^p−1^≡1 (mod p) ，其中 gcd(a,p)=1 ，p为质数</p>
<p>逆元：对于a和p，若 a * inv(a) % p ≡ 1，则称inv(a)为a%p的逆元。p为质数<br><img src="https://uploadfiles.nowcoder.com/files/20200701/543071257_1593598139238_20200701180427181.png" alt="在这里插入图片描述"><br><img src="https://uploadfiles.nowcoder.com/files/20200701/543071257_1593598139204_20200701180432979.png" alt="在这里插入图片描述"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	ll base=a;</span><br><span class="line">	<span class="keyword">while</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>!=<span class="number">0</span>)ans=ans*base%mod;</span><br><span class="line">		base=base*base%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		ll n,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;b;</span><br><span class="line">		<span class="comment">//cout&lt;&lt;poww(2,3)&lt;&lt;endl;</span></span><br><span class="line">		cout&lt;&lt;n*poww(b,mod-2)%mod&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>费马小定理</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】6月30日 Growth</title>
    <url>/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%916%E6%9C%8830%E6%97%A5-Growth/</url>
    <content><![CDATA[<p><a href="%E7%89%9B%E5%AE%A2%E7%BD%91https://ac.nowcoder.com/acm/problem/19809">来源：</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a≥ xi且b≥<br>yi，则弱弱在接下来的每一天都可以得到zi的分数。 问m天以后弱弱最多能得到多少分数。 输入描述: 第一行一个两个整数n和m（1≤ n≤<br>1000，1≤ m≤ 2000000000）。 接下来n行，每行三个整数xi，yi，zi（1≤ xi,yi≤ 1000000000，1≤<br>zi ≤ 1000000）。</p>
</blockquote>
<p><strong>输出描述:</strong><br>一行一个整数表示答案。<br>示例1<br>输入<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>输出<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>备注:</p>
<blockquote>
<p>在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。 共获得0+0+20+30=50分。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>dp [ i ] [ j ]表示在sum = i+j天，两种属性分别是i和j所得到的分数（一共）<br>根据题意可得：<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]<br>a[i][j]表示属性分别是i和j可获得大分数（当天）<br>那a[i][j]是怎么得到的？<br>我们用二维前缀和的思想来实现：<br>a[ x<del>i</del> ][ x<del>j</del> ]=z<br>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]<br>整合一下最后答案就是：<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]<br>ans=max(ans,dp[i][j]+(m-i-j)*a[i][j])<br>如果我们在这一天可以获得a[][]的分数，那之后的每一天都可以获得，在此之后还有（m-i-j）天，所以直接加上这个分数在以后天数获得的总和<br>本题的xi，yi，m都比较大记得要先离散化。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1400</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],z[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;z[i];</span><br><span class="line">		b[i]=x[i];</span><br><span class="line">		c[i]=y[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">	sort(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line">	<span class="keyword">int</span> ant1=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">int</span> ant2=unique(c+<span class="number">1</span>,c+<span class="number">1</span>+n)-c<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		x[i] = lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ant1,x[i])-b;</span><br><span class="line">        y[i] = lower_bound(c+<span class="number">1</span>,c+<span class="number">1</span>+ant2,y[i])-c;</span><br><span class="line">        a[x[i]][y[i]] += z[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		a[i][j]+=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j]+(b[i]-b[i<span class="number">-1</span>]<span class="number">-1</span>)*a[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]+(c[j]-c[j<span class="number">-1</span>]<span class="number">-1</span>)*a[i][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b[i]+c[i]&gt;m)<span class="keyword">break</span>;</span><br><span class="line">		sum=max(sum,dp[i][j]+(m-b[i]-c[i])*a[i][j]);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】4月1日题目 Rinne Loves Edges </title>
    <url>/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22598" target="_blank" rel="noopener">牛客网</a></p>
<ol>
<li>题目：</li>
</ol>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<blockquote>
<p>题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m<br>条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为<br>1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1<br>了！作为回报，她会让你的排名上升一定的数量。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<blockquote>
<p>第一行三个整数 N,M,S，意义如「题目描述」所述。</p>
<p>接下来 M 行，每行三个整数 u,v,w 代表点 u 到点 v 之间有一条长度为 w 的无向边。</p>
</blockquote>
<p>输出描述:</p>
<p>一个整数表示答案。</p>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 1 </span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>说明</p>
<p>需要使得点 2,3,4 不能到达点 1，显然只能删除所有的边，答案为 3</p>
<p>示例2<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<p>说明</p>
<blockquote>
<p>需要使得点 4 不能到达点 1，显然删除边 2↔3是最优的。</p>
</blockquote>
<p>备注:</p>
<blockquote>
<p>2≤S≤N≤10^5^,M=N−1保证答案在 C++ long long 范围内</p>
</blockquote>
<ol start="2">
<li>题解：</li>
</ol>
<p>仔细观察题中给的数据m=n-1，其实就是给你一个树，而被删除度为1的点就是这个树的叶子节点，给你的s就是这个树的根<br>那一切就很清楚了：给你一个树和根节点，让你通过删边使得根节点与叶子节点不相连，问你怎么删值最小<br>这个是树形dp问题，我们要做的就是在搜索树的过程中不断处理数据<br>凡是dp问题，都有状态转移，就是一个大问题可以小问题<br>s为根节点时，要删去一些边让s与每个叶子节点不连通，其实就是让x为根节点的子树删去一些边，使得s和x的子树上每个叶子节点不连通。<br>两种情况：一个就是删去x与他儿子y的边<br>另一个就是看以y为子树的根节点的最小情况。<br>我们取较小值<br>    f[x]+=min(f[y],edge[i].w);<br>    edge[i].w是指当前节点x与其子节点y的距离<br>    具体看代码吧</p>
<ol start="3">
<li>代码：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+3;</span><br><span class="line">int f[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">	int u,v,w,next;</span><br><span class="line">&#125;edge[maxn*2];</span><br><span class="line">int root[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">int cnt=0;</span><br><span class="line">	int n,m,s;</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int fa)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(x!=s&amp;&amp;root[x]==1)f[x]=-1;//如果这个是叶子节点，就断绝与父亲的关系 </span><br><span class="line">	//根节点s也有可能度为1，所以要除s之外</span><br><span class="line">	int now;//当前点x的子节点</span><br><span class="line">	//关系(fa--&gt;x--&gt;now)</span><br><span class="line">	<span class="keyword">for</span>(int i=head[x];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		now=edge[i].v;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(now==fa)<span class="built_in">continue</span>;//因为是无向图，我们要防止返回到父亲节点</span><br><span class="line">		</span><br><span class="line">		dfs(now,x);//继续向下</span><br><span class="line">		<span class="keyword">if</span>(f[now]==-1)f[x]+=edge[i].w;//这个我们已经给断绝关系了，只加当前边的权值</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">		f[x]+=min(f[now],edge[i].w);//考虑两个方面</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">	int u,v,w;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		addt(u,v,w);</span><br><span class="line">		addt(v,u,w);//链式前向星</span><br><span class="line">		root[u]++;</span><br><span class="line">		root[v]++;</span><br><span class="line">	 &#125; </span><br><span class="line">	 dfs(s,0);</span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[s]);</span><br><span class="line">	 <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dp</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】7月1日题目精讲 借教室</title>
    <url>/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E5%80%9F%E6%95%99%E5%AE%A4/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16564" target="_blank" rel="noopener">来源：牛客网</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">131072</span>K，其他语言<span class="number">262144</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p>
<p>   面对海量租借教室的信息，我们自然希望编程解决这个问题。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>   我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj,<br>tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。</p>
<p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p>
<p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。</p>
<p>   现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p>
</blockquote>
<p><strong>输入描述:</strong></p>
<blockquote>
<p>第一行包含两个正整数n, m，表示天数和订单的数量。</p>
<p>第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。</p>
<p>接下来有m行，每行包含三个正整数dj, sj, tj，表示租借的数量，租借开始、结束分别在第几天。</p>
<p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。</p>
</blockquote>
<p>示例1<br><strong>输入</strong><br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong><br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong><br>第1 份订单满足后，4 天剩余的教室数分别为0，3，2，3。<br>第2 份订单要求第2 天到第4 天每天提供3 个教室，而第3 天剩余的教室数为2，因此无法满足。分配停止，通知第2个申请人修改订单。<br><strong>备注:</strong></p>
<blockquote>
<p>对于10%的数据，有1≤n,m≤10； 对于30%的数据，有1≤n,m≤1000； 对于70%的数据，有1≤n,m≤105；<br>对于100%的数据，有1≤n, m≤106, 0≤ri, dj≤109, 1≤sj≤tj≤ n。</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>noip原题<br>第一反应线段树，不过线段树懒得打，我们用其他方法<br>差分+二分</p>
<h3 id="差分："><a href="#差分：" class="headerlink" title="差分："></a>差分：</h3><p>我们都知道前缀和，所谓差分简单理解就是前缀和的逆运算<br>前缀和：<br>其中数组a可以看做是相邻sum数组的差值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;<span class="built_in">cin</span>&gt;&gt;a[i];sum[i]=sum[i<span class="number">-1</span>]+a[i];&#125;</span><br></pre></td></tr></table></figure>
<p>差分：<br>差分就是给你相邻的差值，然后求出每一项</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;<span class="built_in">cin</span>&gt;&gt;dif[i];a[i]=dif[i]+a[i<span class="number">-1</span>];&#125;</span><br></pre></td></tr></table></figure>
<p>前缀和是用元数据求元与元之间的并集关系，而差分则是根据元与元之间的逻辑关系求元数据，是互逆思想</p>
<h3 id="二分："><a href="#二分：" class="headerlink" title="二分："></a>二分：</h3><p>这个题为什么能用二分呢？<br>二分的条件：状态的决策过程或者序列是否满足单调性或者可以局部舍弃性<br>如果第x个订单无法满足，那x之后的就都不用看了，我们要找的答案就一定在x之前，如果x能满足，答案就在x之后，这不就是典型的二分吗？</p>
<h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">dif[l[i]]+=d[i];</span><br><span class="line">dif[r[i]+<span class="number">1</span>]-=d[i];</span><br></pre></td></tr></table></figure>
<p>我们在读入时是 d l r，分别表示数量和时间范围<br>dif[x]+=d 可以理解为第x天之后（含第x天）的每天都需要数量为d的教室，为什么？看一下下面的代码，need[i]表示第i天的需求，need是由dif推导出来的，也就是dif[i]的结果会影响到第i天之后的每一个need,这样我们就可以通过改变dif来实现操作区间<br>但是我们数量d的范围是[l,r]，所以还要加一个dif[r[i]+1]-=d[i]，也就是第r+1天之后的数量减d，这样就和之前加d的影响给抵消了，最终效果只体现在区间[l,r]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">need[i]=need[i<span class="number">-1</span>]+dif[i];</span><br><span class="line"><span class="keyword">if</span>(need[i]&gt;a[i])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//供不应需 ，教室不够</span></span><br></pre></td></tr></table></figure>

<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dif[maxn],need[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dif,<span class="number">0</span>,<span class="keyword">sizeof</span>(dif));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dif[l[i]]+=d[i];</span><br><span class="line">		dif[r[i]+<span class="number">1</span>]-=d[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		need[i]=need[i<span class="number">-1</span>]+dif[i];</span><br><span class="line">		<span class="keyword">if</span>(need[i]&gt;a[i])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//供不应需 ，教室不够 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">cin</span>&gt;&gt;d[i]&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line">	<span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line">	<span class="keyword">if</span>(isok(m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>, <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(isok(mid))<span class="comment">//当前情况可以 </span></span><br><span class="line">			l=mid+<span class="number">1</span>; </span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//当前情况不可以</span></span><br><span class="line">		 	r=mid; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"-1\n%d"</span>,l);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>差分</tag>
        <tag>二分</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】7月7日题目精讲-最短路</title>
    <url>/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%887%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19814" target="_blank" rel="noopener">来源：牛客网：</a><br>@[toc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给一个连通图，每次询问两点间最短路。每条边的长度都是1。 输入描述: 第一行两个整数n和m，表示图的点数和边数（1≤ n≤ 100000,<br>1≤ m≤ n+100）。 接下来m行每行两个整数a和b，表示一条边（1≤ a, b≤ n）。保证没有自环和重边。保证图连通。<br>接下来一个整数q表示询问的个数（1≤ q≤ 100000）。 接下来q行每行两个整数a和b表示询问a和b之间的最短路。</p>
</blockquote>
<a id="more"></a>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>每个询问输出一行表示答案。</p>
</blockquote>
<p>示例1<br><strong>输入</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><del>我看了别人的讲解才逐渐明白。。我太菜了</del><br>题目是最短路，题目内容也是最短路，但是解法却不是常用的spfa等，因为询问的个数有点多（1 ~ 100000）<br>我们仔细看数据范围，m&lt;n+100,什么意思？想想m = n-1时是一棵树，那我们就可以把他当做树处理，然后剩下的边再慢慢干<br>如果当做一棵树的话，边长为1，求最短路径，我们就可以通过最近公共祖先（lca）得到两点的最近距离，dep[a]+dep[b] - 2<em>dep [ lca(a, b) ] (a的深度+b的深度，然后a和b有重复的部分，减去重复的部分)<br>然后我们看看多出来的100个边，会对结果有什么影响？<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594279390052_20200709143940363.png" alt="在这里插入图片描述"><br>蓝色是原本的树，橙色，绿色是多出来的边<br>如果是橙色，对结果没有影响，如果是绿色会有影响<br>那么该如何处理？<br>我们可以把剩下多出来的边跑单元最短路（以这些边的一个端点开始）并记录下来<br>然后与原路径进行比较<br>a到b的最小距离就在dep[a] +dep[b]-2</em>dep[ lca(a,b) ]与dis[a[i]]+dis[b[i]]中取最小值<br>不知道有没有听明白，我拿样例做个分析：<br>我们看一下样例，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>多余的边是：1-2 , 4-3,<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594279390425_20200709151000526.png" alt="在这里插入图片描述"><br>ans最开始的值就是树上的lca<br>ans={1,2,1,3}<br>然后开始跑1-2这个边，从1这个点开始，计算出1到个点的距离<br>dis={0,1,2,1}<br>然后更新最短距离：<br>ans[i] = min(ans[i], dis[a[i]] + dis[b[i]]);<br>a和b分别表示询问中a和b的距离<br>a[2]=1,b[2]=2<br>dis[a[2]]+dis[b[2]]=0+1=1&lt;ans[2]<br>所以ans[2]=1<br>大致就是这个过程</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p><a href="https://blog.nowcoder.net/n/7353e7a20a194775bb5e50669deb2b18" target="_blank" rel="noopener">代码来自</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//const int mod = 998244353;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dir[][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, depth[maxn], f[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> from[maxn], to[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>], cnt = <span class="number">1</span>, Log[maxn], From[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], used[maxn];</span><br><span class="line"><span class="comment">//链式前向星加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    From[++cnt] = u, to[cnt] = v, nxt[cnt] = from[u], from[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算深度&amp;计算祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Log[n]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &gt; depth[u]) <span class="keyword">break</span>;</span><br><span class="line">        f[u][i] =  f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = from[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        ll v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = used[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[v][<span class="number">0</span>] = u;</span><br><span class="line">        dfs (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算LCA</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="comment">//我们默认x为更深的那个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = Log[n] ; i &gt;= <span class="number">0</span> ; --i)</span><br><span class="line">        <span class="keyword">if</span>(depth[x] - (<span class="number">1</span> &lt;&lt; i) &gt;= depth[y]) x = f[x][i];</span><br><span class="line">    <span class="comment">//将x跳到和y同一深度上</span></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = Log[n]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="comment">//一起向上跳</span></span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//不难看出，此时两个点均在其LCA的下方，往上跳一次即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addEdge (u, v); addEdge(v, u);</span><br><span class="line">        Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log[n] = Log[n &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> p , <span class="keyword">int</span> q)</span></span>&#123;<span class="keyword">return</span> depth[p] + depth[q] - <span class="number">2</span> * depth[LCA(p , q)];&#125;</span><br><span class="line"><span class="keyword">int</span> ans[maxn],a[maxn],b[maxn],dis[maxn], Q, q[maxn], h, t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dis[i] = inf;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    h = t = <span class="number">0</span>;</span><br><span class="line">    q[++h] = s;</span><br><span class="line">    <span class="keyword">while</span> (t &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[++t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from[u]; i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + <span class="number">1</span>)</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>, q[++h] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">        ans[i] = min(ans[i], dis[a[i]] + dis[b[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//  freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="comment">//  freopen("out.txt", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">        ans[i] = dist(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">            used[i] = used[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            bfs(From[i]);</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">101</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>一起开心2020暑假训练第一周（数论篇）</title>
    <url>/2020/07/03/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%832020%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<h2 id="hdu-1576-A-B"><a href="#hdu-1576-A-B" class="headerlink" title="hdu 1576 A/B"></a>hdu 1576 A/B</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1576%28HDU-1576%29" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107069074" target="_blank" rel="noopener">题解：</a></p>
<h2 id="Poj-1061-青蛙的约会"><a href="#Poj-1061-青蛙的约会" class="headerlink" title="Poj 1061 青蛙的约会"></a>Poj 1061 青蛙的约会</h2><p><a href="http://poj.org/problem?id=1061" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107072590" target="_blank" rel="noopener">题解：</a></p>
<a id="more"></a> 
<h2 id="hdu-1525-Euclid‘s-Game"><a href="#hdu-1525-Euclid‘s-Game" class="headerlink" title="hdu 1525 Euclid‘s Game"></a>hdu 1525 Euclid‘s Game</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1525" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107082170" target="_blank" rel="noopener">题解：</a></p>
<h2 id="Poj-3070-Fibonacci"><a href="#Poj-3070-Fibonacci" class="headerlink" title="Poj 3070 Fibonacci"></a>Poj 3070 Fibonacci</h2><p><a href="http://poj.org/problem?id=3070" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107084754" target="_blank" rel="noopener">题解：</a></p>
<h2 id="HDU-2504-又见GCD"><a href="#HDU-2504-又见GCD" class="headerlink" title="HDU 2504 又见GCD"></a>HDU 2504 又见GCD</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2504" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107096246" target="_blank" rel="noopener">题解：</a></p>
<h2 id="Poj-1284-Primitive-Roots"><a href="#Poj-1284-Primitive-Roots" class="headerlink" title="Poj 1284 Primitive Roots"></a>Poj 1284 Primitive Roots</h2><p><a href="http://poj.org/problem?id=1284" target="_blank" rel="noopener">oj传送</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/107101360" target="_blank" rel="noopener">题解：</a></p>
]]></content>
      <categories>
        <category>一起开心</category>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>一起开心2020暑假训练第二周 图论（模板题）</title>
    <url>/2020/07/13/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%832020%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%BA%8C%E5%91%A8-%E5%9B%BE%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://vjudge.net/contest/381143#problem" target="_blank" rel="noopener">比赛链接：</a><br>@[toc]</p>
<a id="more"></a>
<h2 id="A-HDU-1285-一"><a href="#A-HDU-1285-一" class="headerlink" title="A HDU 1285 一"></a>A HDU 1285 一</h2><p>拓扑排序模板题，记录每个点的入度，然后按照入度大小以及顺序进行输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>[<span class="number">517</span>][<span class="number">517</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">517</span>];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(c!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>[v][i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(!in[i])</span><br><span class="line">                q.push(i);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span> <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">map</span>[i][j]=<span class="number">1</span>;</span><br><span class="line">            in[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-HDU-1863-起"><a href="#B-HDU-1863-起" class="headerlink" title="B    HDU 1863    起"></a>B    HDU 1863    起</h2><p>最小生成树模板题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">32</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	total=<span class="number">0</span>;</span><br><span class="line">	sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u=find(edge[i].u);</span><br><span class="line">		<span class="keyword">int</span> v=find(edge[i].v);</span><br><span class="line">		<span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">		sum+=edge[i].w;</span><br><span class="line">		fa[u]=v;</span><br><span class="line">		total++;</span><br><span class="line">		<span class="keyword">if</span>(total==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line">		<span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		sort(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m,cmp);</span><br><span class="line">		Kruskal();</span><br><span class="line">		<span class="keyword">if</span>(total==n<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-POJ-2387-开"><a href="#C-POJ-2387-开" class="headerlink" title="C    POJ 2387    开"></a>C    POJ 2387    开</h2><p>最短路模板，从n 到 1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,num_edge=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn],head[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> next,to,dis;</span><br><span class="line">&#125;edge[maxm]; <span class="comment">//结构体表示静态邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span> <span class="comment">//邻接表建图</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//以下是数据结构书上的标准代码，不懂翻书看解释</span></span><br><span class="line">  edge[++num_edge].next=head[from]; <span class="comment">//链式存储下一条出边</span></span><br><span class="line">  edge[num_edge].to=to; <span class="comment">//当前节点编号</span></span><br><span class="line">  edge[num_edge].dis=dis; <span class="comment">//本条边的距离</span></span><br><span class="line">  head[from]=num_edge; <span class="comment">//记录下一次的出边情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//spfa用队列，这里用了STL的标准队列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dis[i]=inf; <span class="comment">//带权图初始化</span></span><br><span class="line">    vis[i]=<span class="number">0</span>; <span class="comment">//记录点i是否在队列中，同dijkstra算法中的visited数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.push(s); dis[s]=<span class="number">0</span>; vis[s]=<span class="number">1</span>; <span class="comment">//第一个顶点入队，进行标记</span></span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> u=q.front(); <span class="comment">//取出队首</span></span><br><span class="line">    q.pop(); vis[u]=<span class="number">0</span>; <span class="comment">//出队标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=edge[i].next) <span class="comment">//邻接表遍历，不多解释了（也可用vector代替）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> v=edge[i].to; </span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].dis) <span class="comment">//如果有最短路就更改</span></span><br><span class="line">      &#123;</span><br><span class="line">        dis[v]=dis[u]+edge[i].dis;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) <span class="comment">//未入队则入队</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[v]=<span class="number">1</span>; <span class="comment">//标记入队</span></span><br><span class="line">          q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">  s=n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> f,g,w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;f&gt;&gt;g&gt;&gt;w; </span><br><span class="line">    addedge(f,g,w); <span class="comment">//建图，有向图连一次边就可以了</span></span><br><span class="line">    addedge(g,f,w);</span><br><span class="line">  &#125;</span><br><span class="line">   spfa(); <span class="comment">//开始跑spfa</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//否则打印最短距离</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-POJ-1502-心"><a href="#D-POJ-1502-心" class="headerlink" title="D    POJ 1502    心"></a>D    POJ 1502    心</h2><p>也是最短路模板题，只是读入方式有些奇怪</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10010</span>,MAXM=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XY</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> w,to,pre;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XX</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> dis,num;</span><br><span class="line">&#125;d[MAXN],tmp;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(XX &amp;a,XX &amp;b)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> w[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n,s,sz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> las[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line">priority_queue&lt;XX,<span class="built_in">vector</span>&lt;XX&gt;,cmp1&gt; q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sz=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">memset</span>(las,<span class="number">0</span>,<span class="keyword">sizeof</span>(las));</span><br><span class="line">	<span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">	++sz;</span><br><span class="line">	e[sz].to=y;</span><br><span class="line">	e[sz].w=w;</span><br><span class="line">	e[sz].pre=las[x];</span><br><span class="line">	las[x]=sz;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> min,u=<span class="number">0</span>;</span><br><span class="line">	s=<span class="number">1</span>;</span><br><span class="line">	d[s].dis=<span class="number">0</span>;</span><br><span class="line">	q.push(d[s]);</span><br><span class="line">	<span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">		u=q.top().num;</span><br><span class="line">		q.pop();</span><br><span class="line">		<span class="keyword">if</span> (flag[u]) <span class="keyword">continue</span>;</span><br><span class="line">		flag[u]=<span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=las[u];j;j=e[j].pre)&#123;</span><br><span class="line">			<span class="keyword">int</span> mu=e[j].to;</span><br><span class="line">			<span class="keyword">if</span> (d[mu].dis&gt;d[u].dis+e[j].w)&#123;</span><br><span class="line">				d[mu].dis=d[u].dis+e[j].w;</span><br><span class="line">				q.push(d[mu]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zhuanhua</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'x'</span>)</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++)</span><br><span class="line">            sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">		&#123;</span><br><span class="line">			d[i].num=i;</span><br><span class="line">			d[i].dis=<span class="number">2147483647</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">scanf</span>(<span class="string">"%s"</span>,w);</span><br><span class="line">				<span class="keyword">int</span> zz=zhuanhua(w);</span><br><span class="line">				add(i,j,zz);</span><br><span class="line">			    add(j,i,zz);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Dijkstra();</span><br><span class="line">		<span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">			maxx=max(maxx,d[i].dis);</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt;maxx;</span><br><span class="line">		<span class="keyword">while</span>(!q.empty())q.pop(); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-HDU-5922-图"><a href="#E-HDU-5922-图" class="headerlink" title="E    HDU 5922    图"></a>E    HDU 5922    图</h2><p>找规律，表面是最小生成树，但仔细看会发现将点1与其他点相连费用最低（因为费用为两点之和，而1是最小的数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll n;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,i,(n<span class="number">-1</span>)*(n+<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="F-HDU-2112-论"><a href="#F-HDU-2112-论" class="headerlink" title="F    HDU 2112    论"></a>F    HDU 2112    论</h2><p>也是最短路，不过每个站点都是具体的城市名，可以用map实现名字与编号的唯一对应</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">70005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,num_edge=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp; </span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn],head[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> next,to,dis;</span><br><span class="line">&#125;edge[maxm]; <span class="comment">//结构体表示静态邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span> <span class="comment">//邻接表建图</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//以下是数据结构书上的标准代码，不懂翻书看解释</span></span><br><span class="line">  edge[++num_edge].next=head[from]; <span class="comment">//链式存储下一条出边</span></span><br><span class="line">  edge[num_edge].to=to; <span class="comment">//当前节点编号</span></span><br><span class="line">  edge[num_edge].dis=dis; <span class="comment">//本条边的距离</span></span><br><span class="line">  head[from]=num_edge; <span class="comment">//记录下一次的出边情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//spfa用队列，这里用了STL的标准队列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dis[i]=inf; <span class="comment">//带权图初始化</span></span><br><span class="line">    vis[i]=<span class="number">0</span>; <span class="comment">//记录点i是否在队列中，同dijkstra算法中的visited数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.push(s); </span><br><span class="line">  dis[s]=<span class="number">0</span>;</span><br><span class="line">vis[s]=<span class="number">1</span>; <span class="comment">//第一个顶点入队，进行标记</span></span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> u=q.front(); <span class="comment">//取出队首</span></span><br><span class="line">    q.pop(); vis[u]=<span class="number">0</span>; <span class="comment">//出队标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=edge[i].next) <span class="comment">//邻接表遍历，不多解释了（也可用vector代替）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> v=edge[i].to; </span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].dis) <span class="comment">//如果有最短路就更改</span></span><br><span class="line">      &#123;</span><br><span class="line">        dis[v]=dis[u]+edge[i].dis;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) <span class="comment">//未入队则入队</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[v]=<span class="number">1</span>; <span class="comment">//标记入队</span></span><br><span class="line">          q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	num_edge=<span class="number">0</span>;</span><br><span class="line">	mp.erase(mp.begin(),mp.end());</span><br><span class="line">	<span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">	<span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m)</span><br><span class="line">	&#123;</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">if</span>(m==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">string</span> a,end,b;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;end;</span><br><span class="line">		mp[a]=<span class="number">1</span>;</span><br><span class="line">	  	s=<span class="number">1</span>;</span><br><span class="line">	  	<span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">	 	 <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		<span class="keyword">int</span> w;</span><br><span class="line">	    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">		<span class="keyword">if</span>(mp[a]==<span class="number">0</span>)</span><br><span class="line">		mp[a]=++cnt;</span><br><span class="line">		<span class="keyword">if</span>(mp[b]==<span class="number">0</span>)</span><br><span class="line">		mp[b]=++cnt; </span><br><span class="line">	    addedge(mp[a],mp[b],w); <span class="comment">//建图，有向图连一次边就可以了</span></span><br><span class="line">	    addedge(mp[b],mp[a],w);</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	n=cnt;</span><br><span class="line">	   spfa(); <span class="comment">//开始跑spfa</span></span><br><span class="line">	   <span class="keyword">if</span>(mp[end]==<span class="number">0</span>||dis[mp[end]]==inf)</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	  <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[mp[end]]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//否则打印最短距离</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>一起开心</category>
        <category>比赛</category>
        <category>题解</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】7月6日精讲-平衡二叉树</title>
    <url>/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%886%E6%97%A5%E7%B2%BE%E8%AE%B2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19775" target="_blank" rel="noopener">来源：牛客网：</a><br>@[toc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>平衡二叉树，顾名思义就是一棵“平衡”的二叉树。在这道题中，“平衡”的定义为，对于树中任意一个节点，都满足左右子树的高度差不超过 d.</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>空树的高度定义为0，单个节点的高度为1，其他情况下树的高度定义为根节点左右子树高度最大值 + 1.<br>一棵在高度上平衡的树，节点数可能不平衡，因此再定义一棵树的不平衡度为这棵树中所有节点的左右子树的节点数之差的最大值。 给定平衡的定义参数d,<br>你需要求出所有高度为 n 的平衡树中不平衡度的最大值。</p>
</blockquote>
<p><strong>输入描述:</strong></p>
<blockquote>
<p>两个整数，n, d.</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>一个整数：所有高度为 n 的平衡树中不平衡度的最大值。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<blockquote>
<p>下面这棵树在 d=1 的定义下高度是平衡的，其不平衡度为 5。</p>
</blockquote>
<p><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594268527449_2020070912062399.png" alt="在这里插入图片描述"></p>
<p>备注:</p>
<blockquote>
<p>0 ≤ n, d ≤ 60</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>不平衡度为这棵树中所有节点的左右子树的节点数之差的最大值<br>那我们要让不平衡度最大就要尽可能使左右子树差最大，左子树尽可能多，右子树尽可能少<br>左子树尽可能多的话我们可以直接给拉满，也就是满二叉树节点就是pow(2,n-1),n为整个树的高度，n-1为左子树的高度<br>右子树尽可能少，那深度就尽可能浅，但因为有题目左右子树的高度差不超过 d的限制，所以右子树的深度就是m=n-1-d。然后右子树也是有左右子子树，同样的道理<br>我们定义dp[i]表示深度为i的子树最少总节点个数<br>当前的树高是i，满足题意就是建一颗高度为i-1的左子树和一颗h-d-1的右子树<br>能得到转移方程：dp[i]=dp[i-1]+dp[i-d-1]+1<br>这个+1就是+根<br>我们要求最大的不平衡度<br>最后用满左子树 -（高度为n-d-1的右子树）- 1</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">4</span>;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,d;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d;</span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>, <span class="number">0</span>;</span><br><span class="line">	sum=(<span class="number">1l</span>l&lt;&lt;(n<span class="number">-1</span>)); </span><br><span class="line">	dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-d<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(i-d<span class="number">-1</span>&gt;=<span class="number">0</span>)dp[i]+=dp[i-d<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum-dp[n-d<span class="number">-1</span>]<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
      </tags>
  </entry>
  <entry>
    <title>一起开心暑假集训第一周限时训练 2020/7/5</title>
    <url>/2020/07/05/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%AC%AC%E4%B8%80%E5%91%A8%E9%99%90%E6%97%B6%E8%AE%AD%E7%BB%83-2020-7-5/</url>
    <content><![CDATA[<p>@[toc]</p>
<p><a href="https://vjudge.net/contest/381396#problem/D" target="_blank" rel="noopener">vjudge试题集链接</a></p>
<h2 id="A-Goldbach’s-Conjecture-POJ-2262"><a href="#A-Goldbach’s-Conjecture-POJ-2262" class="headerlink" title="A - Goldbach’s Conjecture POJ - 2262"></a>A - Goldbach’s Conjecture POJ - 2262</h2><p><a href="http://poj.org/problem?id=2262" target="_blank" rel="noopener">试题链接：</a><br>线性筛先预处理，然后判断就行</p>
<a id="more"></a> 
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn+<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> isprime[maxn+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</span><br><span class="line">	isprime[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(isprime[i])prime[++cnt]=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			isprime[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	Prime(maxn);</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(isprime[i]!=<span class="number">0</span>&amp;&amp;isprime[n-i]!=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"%d = %d + %d\n"</span>,n,i,n-i);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="B-同余方程-计蒜客-T2010"><a href="#B-同余方程-计蒜客-T2010" class="headerlink" title="B - 同余方程 计蒜客 - T2010"></a>B - 同余方程 计蒜客 - T2010</h2><p><a href="https://nanti.jisuanke.com/t/T2010" target="_blank" rel="noopener">试题链接：</a><br>求逆元裸题，好像是noip原题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	ll gcd=exgcd(a,mod,x,y);</span><br><span class="line">	<span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll a,b;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;inv(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Tr-A-HDU-1575"><a href="#C-Tr-A-HDU-1575" class="headerlink" title="C - Tr A HDU - 1575"></a>C - Tr A HDU - 1575</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575" target="_blank" rel="noopener">试题链接：</a><br><a href="http://jozky.top/2020/07/05/Tr-A-HDU1575/">题解</a></p>
<h2 id="D-C-Looooops-POJ-2115"><a href="#D-C-Looooops-POJ-2115" class="headerlink" title="D - C Looooops POJ - 2115"></a>D - C Looooops POJ - 2115</h2><p><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">试题链接：</a><br><a href="http://jozky.top/2020/07/05/C-Looooops-POJ-2115/">题解：</a></p>
]]></content>
      <categories>
        <category>比赛</category>
        <category>一起开心</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu-2844 Coins</title>
    <url>/2020/06/16/hdu-2844-Coins/</url>
    <content><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2844" target="_blank" rel="noopener">HDU链接</a><br><a href="https://ac.nowcoder.com/acm/problem/51167" target="_blank" rel="noopener">牛客网链接</a><br>@[toc]<br>出于种种原因，最近很少更新博客了，虽然一直在更新csdn。。。<br>从现在开始继续更新博客，坚持不断更</p>
<a id="more"></a> 
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p><img src="https://img-blog.csdnimg.cn/20200616110800256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>输入描述:<br><img src="https://img-blog.csdnimg.cn/20200616110821261.png" alt="在这里插入图片描述"><br>输出描述:</p>
<blockquote>
<p>For each test case output the answer on a single line.</p>
</blockquote>
<p>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>有n种硬币，面额分别是Ai，每种硬币数量分别是Ci，问这些硬币能组成1~m中多少个数？<br>样例分析：<br>3 10<br>1 2 4 2 1 1<br>有2个一元，1个两元，1个四元，可以组成1,2，3，4,5，6，7,8，（9和10无法组成）能组成的一共八个</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如果还没学习背包问题的知识，<a href="https://blog.csdn.net/qq_35975367/article/details/106759161" target="_blank" rel="noopener">看这里</a><br>混合背包问题<br>可以用二进制的方法来优化<br>背包问题中常见的三个元素：体积（所占容量），价值，数量<br>在本题中，硬币的价值即是体积也是价值A[i]，数量为硬币的数量C[i]<br>容量上限是m<br>当c<em>a&gt;m时，也就是一种货币的金额就超过m时，我们可以当做是完全背包，即将这种货币看做无数个，因为货币的数量乘以金额已经超过上限，所以再多也没有影响。这一部分用完全背包的做法<br>当c</em>a&lt;m时，我们就当做多重背包来做，将多重背包进行二进制优化，用01背包的解法来做<br>具体看代码：</p>
<h2 id="（代码）"><a href="#（代码）" class="headerlink" title="（代码）"></a>（代码）</h2><p>含详细讲解</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">120</span>],c[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zeroone</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=m;i&gt;=cost;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		dp[i]=max(dp[i],dp[i-cost]+val);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wanquanbeibao</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=cost;i&lt;=m;i++)dp[i]=max(dp[i],dp[i-cost]+val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> cost,<span class="keyword">int</span> val,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cost*num&gt;=m)wanquanbeibao(cost,val);<span class="comment">//完全背包不必考虑数量</span></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			zeroone(i*cost,i*val);<span class="comment">//乘以对应的系数 </span></span><br><span class="line">			num-=i; </span><br><span class="line">		&#125;</span><br><span class="line">		zeroone(num*cost,num*val);<span class="comment">//剩余部分处理 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&amp;&amp;(n+m))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cal(a[i],a[i],c[i]);<span class="comment">//花费，价值，数量 </span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dp[i]==i)sum++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>背包问题</tag>
        <tag>混合背包</tag>
        <tag>二进制优化</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/C" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>多次查询[l,r]范围内的完全平方数个数</p>
<p>定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x</p>
</blockquote>
<a id="more"></a> 
<p>输入描述:</p>
<blockquote>
<p>第一行一个数n表示查询次数 之后n行每行两个数l,r 输出描述: 对于每个查询，输出一个数表示答案</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1000000000</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>31622<br>备注:<br>n &lt;= 100000<br>0&lt;= l &lt;= r &lt;= 1000000000</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>签到题<br>l,r直接开方，注意l开方后向上取整。<br>r1-l1+1就是答案</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000005</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">int</span> l,r;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">int</span> l1=<span class="built_in">sqrt</span>(l);</span><br><span class="line">		<span class="keyword">int</span> r1=<span class="built_in">sqrt</span>(r);</span><br><span class="line">		<span class="keyword">if</span>(l1*l1!=l)l1++;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;r1-l1+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>区间处理</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列</title>
    <url>/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18203" target="_blank" rel="noopener">牛客网题目</a><br>题目描述</p>
<blockquote>
<p>给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示</p>
<p>接下来一行N个整数，表示给出的序列</p>
<p>保证序列内的数互不相同</p>
</blockquote>
<a id="more"></a>
<p>输出描述:</p>
<blockquote>
<p>对于每组数据，输出一个整数表示答案，对10^9^ + 7 取模 每组数据之间以换行分割</p>
</blockquote>
<p> 示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span> </span><br><span class="line"><span class="number">100</span> <span class="number">1020</span> <span class="number">2050</span> <span class="number">102</span> <span class="number">12</span> <span class="number">235</span> <span class="number">4</span> <span class="number">57</span> <span class="number">32135</span> <span class="number">54354</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">81000</span></span><br><span class="line"><span class="number">521918013</span></span><br></pre></td></tr></table></figure>

<p>说明：<br>第一组数据解释<br>所有长度为3的子序列为 (5,3,1) (5,3,4) (3,1,4) (5,1,4)<br>最终答案为3∗4∗3∗4=1443<br><img src="https://img-blog.csdnimg.cn/20200409222358794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">题解：<br>对于子序列一个数a，a会以三种形式存在<br>1.最大值<br>2.最小值<br>3.中间值<br>我们现将序列从小到大排序（从0开始），并不影响结果，但是有利于计算<br> a在长度为 k 的子序列中出现的次数为 C^k−1^<del>n−1</del>(因为如果它出现在子序列中，那么总数还有 n−1 个 数字，序列的长度还有 k−1 个)<br>对于第一种情况，a作为最大值的下表为i，a之前的i个数都比a小，所选出的子序列一定有以下标i为结尾的，我们需要从前i个中选出k-1个，组成长度为k的子序列，个数为C^k-1^<del>i</del>(组合数）<br>同理：ai 是最小值的情况的方法数为 C^k−1^<del>n−i−1</del><br>pi=C^k−1^<del>n−1</del>−C^k−1^<del>i</del>−C^k−1^<del>n−i−1</del> 对于 ai这个数来说，它对答案的贡献为 a^pi^<del>i</del><br>最终的答案为 ：ans=∏^n−1^<del>i=0</del>a^pi^<del>i</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function">LL <span class="title">Pow</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL c[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % (MOD<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a, a+n);</span><br><span class="line">        LL tmp = c[n<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL b = tmp-c[i][k<span class="number">-1</span>]-c[n-i<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">            b = (b%(MOD<span class="number">-1</span>)+(MOD<span class="number">-1</span>))%(MOD<span class="number">-1</span>);</span><br><span class="line">            ans = ans*Pow(a[i], b)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为那个是指数，比如说 a^b^%p，可以用费马小定理 a^(b%(p-1))^ % p</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title>【每日一题】7月3日精讲-毒瘤xor</title>
    <url>/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%883%E6%97%A5%E7%B2%BE%E8%AE%B2-%E6%AF%92%E7%98%A4xor/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18979" target="_blank" rel="noopener">【每日一题】7月3日精讲—毒瘤xor</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">32768</span>K，其他语言<span class="number">65536</span>K</span><br><span class="line">Special Judge, <span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200708/543071257_1594194323314_20200708152132188.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p><strong>输入描述:</strong></p>
<blockquote>
<p>第一行一个整数N，表示序列的长度 第二行N个整数，表示序列内的元素 第三行一个整数q，表示询问的个数 接下来q行，每行两个整数[L,<br>R]，表示询问的区间</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>输出q行，每行一个整数表示答案</p>
<p>若有多组可行解，请输出较小的解</p>
</blockquote>
<p>示例1<br><strong>输入</strong><br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">78</span> <span class="number">12</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2147483632</span></span><br><span class="line"><span class="number">2147483635</span></span><br><span class="line"><span class="number">2147483635</span></span><br></pre></td></tr></table></figure>

<p>备注:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">对于<span class="number">30</span>%的数据，n , q ≤ <span class="number">10</span></span><br><span class="line">对于<span class="number">60</span>%的数据，n , q ≤ <span class="number">1000</span></span><br><span class="line">对于<span class="number">100</span>%的数据，n, q ≤ <span class="number">10</span>^<span class="number">5</span></span><br><span class="line">保证ai &lt; <span class="number">2</span>^<span class="number">31</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>很久没有遇到异或的题了<br>先讲下异或：1 ^ 1 =0 , 0 ^ 0= 0,1 ^ 0 =1,0 ^ 1 =1<br>相同为0，不同为1<br>异或是两个数二进制状态下相同数位进行操作<br>我们要找一个x使得x ^ a[i]的和最大，那我们就尽量使x与a[i]的相同位数异或后为1，这样就最大<br>a[i]是一个数组，所以我们就求这个数组里每个数的二进制状态下，每一位0和1的个数，比如说，数组有n个数，其中b个数二进制状态下第一位是0，剩下n-b个数二进制状态下第一位是1，如果b&gt;n-b,那我们就使X二进制的第一位是1，（就是和最多情况的数呈相反，这样异或出来才是1）<br>然后是第二位，依次类推最后我们就得到X的二进制状态，转化成十进制输出即可<br>因为有多轮询问，所以我们可以用前缀和来处理每一位为1的数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> w=((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);<span class="comment">//判断第j位是0是1 </span></span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+w);<span class="comment">//前缀和进行累加</span></span><br></pre></td></tr></table></figure>

<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">bool</span> w=((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);<span class="comment">//判断第j位是0是1 </span></span><br><span class="line">			sum[i][j]=(sum[i<span class="number">-1</span>][j]+w);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">	<span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(q--)</span><br><span class="line">	&#123;</span><br><span class="line">		tot=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> l,r;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(sum[r][j]-sum[l<span class="number">-1</span>][j] &lt; ( (r-l)/<span class="number">2</span>+<span class="number">1</span>) )<span class="comment">//当这一位0居多时，X选为1 </span></span><br><span class="line">			tot+=(<span class="number">1</span>&lt;&lt;j); </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>位运算</tag>
        <tag>异或</tag>
      </tags>
  </entry>
  <entry>
    <title>小H和游戏</title>
    <url>/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/D" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit<br>IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<pre><code>小H正在玩一个战略类游戏，她可以操纵己方的飞机对敌国的N座城市(编号为1~N)进行轰炸
敌国的城市形成了一棵树，小H会依次进行Q次轰炸，每次会选择一个城市A进行轰炸，和这座城市距离不超过2的城市都会受损(这里距离的定义是两点最短路径上的边数)，轰炸结束后，小H还想知道当前城市A受损的次数
作为游戏的开发者之一，你有义务回答小H的问题 </code></pre></blockquote>
<a id="more"></a> 
<p>  输入描述:</p>
<blockquote>
<p>第1行，两个整数N(1≤N≤750000)、Q(1≤Q≤750000) 第2<del>N行，每行两个整数表示树上的一条边<br>第N+1</del>N+Q行，每行一个整数，表示小H这次轰炸的城市 </p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p> 输出Q行，每行一个整数表示这一次轰炸的城市在此次轰炸后共计受损几次</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始以为一个城市被轰炸后还在。。。发现并不是<br>我们来分析一个点被轰炸，哪些点会受到牵连<br><img src="https://img-blog.csdnimg.cn/20200417122447514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中点1被轰炸，1的父亲的父亲，儿子的儿子还有兄弟（父亲的儿子）这些点会受损，同理这些点被轰炸，1也会被受损。</p>
<p>fa[]表示父子关系<br>我们可以用二维数组表示dp[i][j]来表示i节点攻击范围<br>j = 1 为结点i被轰炸的次数<br>j = 2 结点i的子结点被轰炸的次数<br>j = 3 结点i的子结点的子结点被轰炸的次数<br>而每个节点的父亲节点只有一个，我们可以用fa[x]来实现，而儿子节点可以有多个我们通过二维数组来实现。</p>
<p>总结图中节点x被轰炸的情况;<br>1.本身被轰炸 dp[x][1]<br>2.子节点被轰炸 dp[x][2]<br>3.子节点的子节点被轰炸 dp[x][3]<br>4.父亲节点被轰炸 dp[fa[x]][1]<br>5.父亲的父亲节点被轰炸 dp [ fa [ fa [ x ] ] ] [ 1 ]<br>6.兄弟节点被轰炸 dp[fa [ x ] ] [ 2 ] - dp [x ] <a href="第一个dp求出来的还包含x本身，去掉x的情况就是x的兄弟情况"> 1 </a></p>
<p>维护好这些，这样我们就可轻松进行查询<br>当x被轰炸时,就让上面6种情况++,注意第六种情况和第一种情况可以合并，所以这两个合成一个 dp[fa [ x ] ] [ 2 ]++就行。<br>最后输出距离x距离为0，1,2的点<br>距离为0即本身 dp[x][1]<br>距离为1 dp[fa[x]][2]<br>距离为2 dp [ fa [ fa [ x ] ] ]  [ 3 ]<br>加起来就是x的答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">750003</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,fa[maxn],dp[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:edge[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=f)</span><br><span class="line">        dfs(v,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> u,v,x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dp[fa[x]][<span class="number">2</span>]++;<span class="comment">//父亲的儿子，情况1和6</span></span><br><span class="line">    dp[fa[x]][<span class="number">1</span>]++;<span class="comment">//父亲本身 情况4</span></span><br><span class="line">    dp [ fa [ fa [ x ] ] ] [ <span class="number">1</span> ] ++;<span class="comment">//父亲的父亲 情况5</span></span><br><span class="line">    dp [ x ] [ <span class="number">2</span> ] ++;<span class="comment">//儿子 情况2</span></span><br><span class="line">    dp [ x ] [ <span class="number">3</span> ] ++;<span class="comment">//儿子的儿子 情况3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[x][<span class="number">1</span>]+dp[fa[x]][<span class="number">2</span>]+dp[fa[fa[x]]][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>使用一段时间牛客网的心得</title>
    <url>/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（<del>心痛</del> ）<br>牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉<br>一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。<br>等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200414000658411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414000643124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>背包等着我<del>~</del></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>小a的旅行计划</title>
    <url>/2020/07/05/%E5%B0%8Fa%E7%9A%84%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20808" target="_blank" rel="noopener">来源：牛客网</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">32768</span>K，其他语言<span class="number">65536</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>小a终于放假了，它想在假期中去一些地方游玩，现在有N个景点，编号为1, 2, \dots<br>N1,2,…N，同时小b也想出去游玩。由于一些特殊♂原因，他们的旅行计划必须满足一些条件 首先，他们可以从这N个景点中任意选几个游玩<br>设小a选出的景点集合为A，小b选的景点集合为B，则需要满足</p>
<ol>
<li>A,B的交集不能为空集</li>
<li>A,B不能相互包含(A=B也属于相互包含) 注意：在这里我们认为(A,B)是无序的，即(A,B)和(B,A)是同一种方案</li>
</ol>
</blockquote>
<a id="more"></a> 
<p><strong>输入描述:</strong><br>一个整数N表示景点的数量<br><strong>输出描述:</strong><br>一个整数表示方案数，答案对10^8^ + 7取模<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>说明<br>合法的方案如下：<br>小a：(1, 2) 小b： (2, 3)<br>小a：(1, 3) 小b： (2, 3)<br>小a：(1, 2) 小b： (1, 3)<br>示例2<br>输入<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>

<p>示例3<br>输入<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>输出<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>示例4<br>输入<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>输出<br>复制</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">68735934</span></span><br></pre></td></tr></table></figure>

<p>示例5<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>备注:<br>对于100%的数据1⩽n⩽10 ^13^</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><a href="https://blog.csdn.net/weixin_42757232/article/details/89702769" target="_blank" rel="noopener">解题思路来自</a><br>我们整合一下题目的条件可以得到，A和B都至少有两个元素，且最少有一个相同，至少有一个不同<br>一共n的元素，我们可以先选出A的元素，然后在A中选一些元素作为公共元素，然后在A未选的元素中选择给B<br>可以得到公式<br><img src="https://uploadfiles.nowcoder.com/files/20200704/543071257_1593829203785_20200704100610423.png" alt="在这里插入图片描述"><br>我们注意到公式中存在除法操作，且我们需要mod，所以用逆元来算<br><a href="https://blog.csdn.net/qq_35975367/article/details/107119628" target="_blank" rel="noopener">求逆元的方法：</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	ll gcd=exgcd(a,mod,x,y);</span><br><span class="line">	<span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	ll base=a%mod;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*base%mod;</span><br><span class="line">		base=base*base%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ll inv(ll a,ll mod)&#123;</span></span><br><span class="line"><span class="comment">//	return poww(a,mod-2);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;poww(2,3)&lt;&lt;endl;</span></span><br><span class="line">	ll ans1=((poww(<span class="number">4</span>,n)<span class="number">-1</span>)-(poww(<span class="number">3</span>,n+<span class="number">1</span>))+mod)%mod;</span><br><span class="line">    ll ans2=<span class="number">3</span>*poww(<span class="number">2</span>,n<span class="number">-1</span>)%mod;</span><br><span class="line">    ll ans3=inv(<span class="number">2</span>,mod)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(ans1*ans3+ans2)%mod;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
        <tag>组合数</tag>
        <tag>二项式定理</tag>
      </tags>
  </entry>
  <entry>
    <title>幸运数字Ⅱ </title>
    <url>/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/E" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。<br>定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r</p>
<ul>
<li>1) + next(r)。 输入描述:</li>
</ul>
<p>两个整数l和r (1 &lt;= l &lt;= r &lt;= 1000,000,000)。</p>
</blockquote>
<a id="more"></a> 

<p>输出描述:</p>
<blockquote>
<p>一个数字表示答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure>

<p>示例2<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>题意：<br>打表出奇迹<br>你可以提前打好表，记录在数组里<br>或者现打表，有两个方法<br>一个是用vector，<br>或者自身递归查找，存在pre中<br>打完表后，直接从l开始对比数到r<br>直接if判断然后sum加有点慢<br>你可以看每两个pre之间的数最后都做一样相加，比如47~74之间（不含47）的数都算作74，那有多少个数？就是74-47+1，然后直接乘74，加起来就ok了<br>注意注意！！！不要忘了longlong，可坑死我了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll pre[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n&gt;<span class="number">1e10</span>+<span class="number">2</span>)<span class="keyword">return</span> ; </span><br><span class="line">	pre[cnt++]=n;</span><br><span class="line">	dfs(n*<span class="number">10</span>+<span class="number">4</span>);</span><br><span class="line">	dfs(n*<span class="number">10</span>+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(ll x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	if(n-1e9&gt;0)return ;</span></span><br><span class="line"><span class="comment">	q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">	dfs((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">	dfs((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">	q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dfs(0);</span></span><br><span class="line"><span class="comment">sort(q.begin(),q.end());</span></span><br><span class="line"><span class="comment">q.push_back(4444444444); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll r,l;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;l,&amp;r);</span><br><span class="line">	dfs(<span class="number">0</span>);</span><br><span class="line">	sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;pre[cnt-1]&lt;&lt;endl;</span></span><br><span class="line">	ll sum=<span class="number">0</span>;</span><br><span class="line">	ll ant=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ll i=l;i&lt;=r;)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="comment">//	if(i&gt;pre[ant])ant++;</span></span><br><span class="line">	<span class="comment">//	sum+=pre[ant];</span></span><br><span class="line">		<span class="keyword">while</span>(i&gt;pre[ant])ant++;</span><br><span class="line">		sum+=pre[ant]*(min(r,pre[ant])-i+<span class="number">1</span>);</span><br><span class="line">		i=pre[ant]+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树(模板)</title>
    <url>/2020/04/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>@[TOC]<br>昨天做蓝桥杯的题，最后一题最小生成树，但好久没用一下子生疏了。。。<br>最小生成树两种方法：<br>Prim和Kruskal</p>
<h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2><p>prim:该算法的时间复杂度为O(n2)。与图中边数无关，该算法适合于稠密图。</p>
<p>kruskal:需要对图的边进行访问，所以克鲁斯卡尔算法的时间复杂度只和边又关系，可以证明其时间复杂度为O（eloge）。适合稀疏图。</p>
<a id="more"></a>
<p> <strong>模板：</strong></p>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,u,v,total;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start,to;<span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">&#125;bian[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//并查集部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x]==x) <span class="keyword">return</span> x; </span><br><span class="line">	<span class="keyword">else</span>  <span class="keyword">return</span> find(f[x]);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span><span class="comment">//结构体快排时用到的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span><span class="comment">//最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=find(bian[i].start);</span><br><span class="line">        v=find(bian[i].to);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;<span class="comment">//判断在不在同一个并查集里面，在就下一个循环</span></span><br><span class="line">            ans+=bian[i].val;<span class="comment">//不在，就加上</span></span><br><span class="line">            f[u]=v;<span class="comment">//连接两个并查集</span></span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span>(total==n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//当形成了最小生成树后，退出（之后做的也没用了）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;bian[i].start,&amp;bian[i].to,&amp;bian[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(bian+<span class="number">1</span>,bian+m+<span class="number">1</span>,cmp);<span class="comment">//快排边长</span></span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;<span class="comment">//快读，不理解的同学用cin代替即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 123456789</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//注意是无向图，开两倍数组</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn],cnt,n,m,tot,now=<span class="number">1</span>,ans;</span><br><span class="line"><span class="comment">//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1-&gt;3,2-&gt;3)</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//链式前向星加边</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v=v;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read(),v=read(),w=read();</span><br><span class="line">        add(u,v,w),add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先把dis数组附为极大值</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意重边，所以要用到min</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[<span class="number">1</span>];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[e[i].v]=min(dis[e[i].v],e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)<span class="comment">//最小生成树边数等于点数-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        re <span class="keyword">int</span> minn=inf;<span class="comment">//把minn置为极大值</span></span><br><span class="line">        vis[now]=<span class="number">1</span>;<span class="comment">//标记点已经走过</span></span><br><span class="line">        <span class="comment">//枚举每一个没有使用的点</span></span><br><span class="line">        <span class="comment">//找出最小值作为新边</span></span><br><span class="line">        <span class="comment">//注意这里不是枚举now点的所有连边，而是1~n</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="comment">//枚举now的所有连边，更新dis数组</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            re <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;e[i].w&amp;&amp;!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=e[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,prim());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>树学</title>
    <url>/2020/04/14/%E6%A0%91%E5%AD%A6/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/201400" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:&gt; %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep<del>root</del>为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep<del>i</del>=dep<del>fa</del> <del>i</del>+1,整棵树的价值W=<img src="https://img-blog.csdnimg.cn/20200414204932422.png" alt="在这里插入图片描述"> ，即所有点的深度和</p>
<a id="more"></a>
<p>牛妹希望这棵树的W最小，请你告诉她，选择哪个点可以使W最小<br>输入描述:<br>第一行，一个数，n<br>接下来n-1行，每行两个数x,y，代表x-y是树上的一条边<br>输出描述:<br>一行，一个数，最小的W<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>备注:<br>对于30%30%的数据，1&lt;= n&lt;=1000<br>对于100%100%的数据，1&lt;=n &lt;=10^6^</p>
<h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>树形dp+换根<br>用到的几个函数：<br>dep[i]：节点i的深度<br>ant[i]：i的子树的个数（含本身）<br>f[x]：以x为根的每个节点深度的和<br><img src="https://img-blog.csdnimg.cn/20200414211409638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图一为以u为根节点<br>图二为以v为根节点<br>从u转到v 之后，图二中黄色区域（u和子树1和子树2）根节点都加1（因为成为别人的子节点），绿色区域（v和根节点2）根节点减1（因为成为别人的根节点）<br>那转换成公式是什么样的？<br>f[v]=（f[u]-ant[v]）+(n-ant[v]);<br>怎么理解呢？<br>第一个括号里，是将图二的绿色区域根节点减一，因为黄色区域一共ant[v]个节点，这个区域内每个节点都减1，所以整个区域f[u]要减ant[v].<br>第二个括号就是黄色区域每个节点都加一，那整个区域就加这个区域的节点数，这个区域的节点数=整个区域-绿色区域，所以就是n-ant[v]<br>我们从1开始dfs，求出每个节点的深度，即dep[]<br>然后再dfs求出每个点子树数量,再dfs换成其他根，利用公式求出f来</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//链式前项星 </span></span><br><span class="line">ll head[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//无向边，所以乘2</span></span><br><span class="line">ll dep[maxn];<span class="comment">//节点的深度 </span></span><br><span class="line">ll ant[maxn];<span class="comment">//节点x的子树数量（包含本身） </span></span><br><span class="line">ll f[maxn];<span class="comment">//以i为根的时候每个点深度的和 </span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll minn=<span class="number">1e7</span>;</span><br><span class="line">	ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	edge[++cnt].v=v;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		forr(n)f[<span class="number">1</span>]+=dep[i];<span class="comment">//在dfs1求完每个点深度后，接着求出以1为根的时候每个点深度的和  </span></span><br><span class="line">		forr(n)ant[i]=<span class="number">1</span>;<span class="comment">//每个节点的子树一开始都是本身 </span></span><br><span class="line">&#125;	</span><br><span class="line">ll v=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		v=edge[i].v;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">		dfs1(v,now);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//以1为根节点开始，计算出每个节点的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		v=edge[i].v;</span><br><span class="line"> 		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> 		dfs2(v,now);</span><br><span class="line"> 		ant[now]+=ant[v]; </span><br><span class="line">	 &#125;</span><br><span class="line">&#125;<span class="comment">//求出x节点的子树数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> 	&#123;</span><br><span class="line"> 		v=edge[i].v;</span><br><span class="line"> 		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> 		f[v]=f[now]-ant[v]+(n-ant[v]); </span><br><span class="line"> 		dfs3(v,now);</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1开始换成其他根，并求出其他根的f值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u,v;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">		add(u,v);</span><br><span class="line">		add(v,u);</span><br><span class="line">	&#125;	</span><br><span class="line">	dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	init(n);<span class="comment">//初始化 </span></span><br><span class="line">	dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	dfs3(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		minn=min(minn,f[i]);</span><br><span class="line">	 &#125; </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;minn;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看会发现dfs1与dfs2结构相似，完全可以和在一起写<br>或者用vector写更简洁</p>
<h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p>我看有很多大佬都用重心的性质来做<br>树的重心有一个这样的性质：在树中所有点到某点的距离和 当中，到树的重心的距离和是最小的，如果有多个重心，那他们距离和一样。<br>树中所有点到重心的距离和最小，不就是我们要求的那个值吗。<br>先用dfs树形dp求出重心，再求出重心与每个点的距离进行累加求和</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ant[maxn],root[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">ll res;</span><br><span class="line">ll point=maxn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ant[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(u,v);</span><br><span class="line">            </span><br><span class="line">            ant[v]+=(ant[u]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            maxx=max(ant[u],maxx);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxx=max(n-ant[v]<span class="number">-1</span>,maxx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(maxx&lt;point)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">        point=maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxx==point)</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res+=dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">            dfs2(u,v,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有关树的重心其他性质，有空专门讲讲</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dp</tag>
        <tag>树上dfs</tag>
        <tag>换根</tag>
        <tag>树的重心</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图匹配--匈牙利算法</title>
    <url>/2020/07/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>@[toc]</p>
<h2 id="二分图："><a href="#二分图：" class="headerlink" title="二分图："></a>二分图：</h2><p>二分图是一个无向图，点集分成子集X和Y，图中每一条边都是一边在X一边在Y<br>当且仅当无向图G的每一个回路次数都是偶数时（包括0），G就是一个二分图</p>
<a id="more"></a>
<p><img src="https://uploadfiles.nowcoder.com/files/20200711/543071257_1594440096071_20200711112506406.png" alt="在这里插入图片描述"></p>
<h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>介绍完二分图后我们看看匹配<br>匹配：如果任意两个边的端点都不相同，我们就称之为匹配。匹配是边的集合<br>最大匹配：所含匹配边数最多的匹配<br>完美匹配：在一次匹配中，所有的顶点都是匹配点<br>完美匹配一定是最大匹配，但是反过来不一定</p>
<h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>以上讲的均为离散知识，现在开始讲算法<br>交替路：从一个未匹配点开始，按照非匹配边，匹配边，非匹配边。。。。这样的顺序形成的路径<br>增广路：从一个未匹配点开始，走交替路，如果途中经过另一个未匹配点，则这条交替路叫做增广路<br>增广路特点：非匹配边比匹配边多一条<br>算法核心就是寻找增广路径，直到没有<br>匈牙利算法寻找最大匹配，就是通过不断寻找原有匹配M的增广路径，因为找到一条M匹配的增广路径，就意味着一个更大的匹配M ‘ ，其恰好比M多一条边。这样不断更新，找不到就是最大情况<br>过程：<br>一开始随便选一个未匹配点，先是匹配（x1,y1），标记，然后给x2匹配，匹配（x2，y2），这样就形成匹配M，有两条边，目前没问题<br>然后x3匹配，发现y1已经被x1抢占了，然后x3横刀夺爱抢走y1，x1悲恨交加只能找下一个，然后把x2的对象y2也抢了，x2也只能顺位找y5，（这是个递归的过程，直到匹配到未被抢占的）,这就形成匹配M1<br>刚才的争执过程（x3,y1,x1,y2,x2,y5）,这就是匹配M的增广路<br>发现增广路就说明有更优的情况，所以我们由匹配M扩展到现在的M1<br>然后将x4加入，一次类推<br>如果争执过程中，最后一个人没找到对象怎么办？那也没事，反正整体的数量不会亏<br><img src="https://uploadfiles.nowcoder.com/files/20200711/543071257_1594440094213_20200711114942501.png" alt="在这里插入图片描述"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>我珍藏多年的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,e;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">4000</span>][<span class="number">4000</span>];<span class="comment">//map[i][j]=1表示X部的i和Y部的j存在路径,是否可以匹配</span></span><br><span class="line"><span class="keyword">int</span> cx[maxn], cy[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//cx[i]表示X部i点匹配的Y部顶点的编号</span></span><br><span class="line"><span class="comment">//cy[i]表示Y部i点匹配的X部顶点的编号</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//dfs进入的都是X部的点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= m; v++)<span class="comment">//枚举Y部的点，判断X部的u和Y部的v是否存在路径</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果存在路径并且还没被标记加入增广路</span></span><br><span class="line">		<span class="keyword">if</span> (Map[u][v] &amp;&amp; !vis[v])<span class="comment">//vis数组只标记Y组</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//标记加入增广路</span></span><br><span class="line">			vis[v] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">			<span class="comment">//如果Y部的点v还未被匹配</span></span><br><span class="line">			<span class="comment">//或者已经被匹配了，但是可以从v点原来匹配的cy[v]找到一条增广路</span></span><br><span class="line">			<span class="comment">//说明这条路就可是一个正确的匹配</span></span><br><span class="line">			<span class="comment">//因为递归第一次进入dfs时，u是未匹配的</span></span><br><span class="line">			<span class="comment">//如果v还没有匹配对象，即和它相连的所有边都不在，已经选择的匹配边集合M（M\in E）中，这时就找到了u-v增广路径</span></span><br><span class="line">			<span class="comment">//如果v已经有匹配对象了，那么u-v是一条未选择的边，</span></span><br><span class="line">			<span class="comment">//而v-cy[v] \in M 则是一条已经选择的边, dfs(cy[v])从cy[v]开始搜索增广路径</span></span><br><span class="line">				<span class="comment">//如果新的v'没有匹配对象，那么u-v-cy[v]-v'就是一条增广路径，</span></span><br><span class="line">				<span class="comment">//如果v'已经有匹配对象了，那么根据匹配是唯一的，</span></span><br><span class="line">				<span class="comment">//cy[v]-v'一定不在已经选择的边中(和cy[v]-v冲突)，</span></span><br><span class="line">				<span class="comment">//u-v-cy[v]-v'-cy[v']符合增广路径对边顺序的要求，继续利用dfs(cy[v'])搜索u-v-cy[v]-v'-cy[v']-下面的点</span></span><br><span class="line">				<span class="comment">//当搜索到增广链时，如u-v-cy[v]-v',那么经过递归的匹配调整和return 1，进行匹配增广操作，假设dfs0 是main调用的dfs算法，dfs1是dfs0调用的dfs算法</span></span><br><span class="line">				<span class="comment">//在dfs1中进行cy[v]-v'的匹配，因为dfs1返回1，因此在dfs0中进行u-v的匹配，匹配增广操作的结果是&#123;cy[v]-v&#125;-&gt;&#123;u-v,cy[v]-v'&#125;</span></span><br><span class="line">				<span class="comment">//如果在一个dfs(k)自调用的dfs(k+1)中，遍历所有的v(k+1),要么已经有匹配点了，要么和输入u(k+1)没有连接可能，这时搜索终止，说明不存在经过u(k+1)的增广链，返回0</span></span><br><span class="line">				<span class="comment">//而在main调用的dfs(0)中，调用的dfs(1)返回的都是0，而且v都是已经有匹配了，那么不存在从该点出发的增广链，那么就该点就不在最大匹配当中</span></span><br><span class="line">				<span class="comment">//为什么找不到增广链就不在最大匹配当中呢？感觉可以用反证法证明，博客中下面内容可能有更新这方面的思考</span></span><br><span class="line">			<span class="keyword">if</span> (cy[v] == <span class="number">-1</span> || dfs(cy[v]))</span><br><span class="line">			&#123;</span><br><span class="line">				cx[u] = v;<span class="comment">//可以匹配，进行匹配</span></span><br><span class="line">				cy[v] = u;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不能匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxmatch</span><span class="params">()</span><span class="comment">//匈牙利算法主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//匹配清空，全部置为-1</span></span><br><span class="line">	<span class="built_in">memset</span>(cx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(cx));</span><br><span class="line">	<span class="built_in">memset</span>(cy, <span class="number">-1</span>, <span class="keyword">sizeof</span>(cy));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cx[i] == <span class="number">-1</span>)<span class="comment">//如果X部的i还未匹配</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//每次找增广路的时候清空vis</span></span><br><span class="line">			ans += dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//输入匹配的两个点集合的数量</span></span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m&gt;&gt;e;</span><br><span class="line">	<span class="comment">//输入两个点集合成员间的匹配可能</span></span><br><span class="line">	<span class="keyword">int</span> x, y;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		Map[x][y] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//执行匈牙利算法，输出最大匹配</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; maxmatch() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 7 12</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">6 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>欧拉序与DFS序</title>
    <url>/2020/04/20/%E6%AC%A7%E6%8B%89%E5%BA%8F%E4%B8%8EDFS%E5%BA%8F/</url>
    <content><![CDATA[<p>@[TOC]<br>欧拉序与DFS序相似又不同</p>
<p>欧拉序的定义<br>树在dfs过程中的节点访问顺序称为欧拉序.<br>那有人会问：dfs序和欧拉序啥区别？</p>
<p>dfs序：是指将一棵树被dfs时所经过的节点顺序（不绕回原点）。<br>欧拉序：就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序。</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200420152716218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欧拉序与dfs序不同地方在于，欧拉序中每个节点可以出现多次，比如进入一次退出一次，又比如每次回溯时记录一次。<br> 代码：</p>
<p>s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</p>
<h2 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h2><p>核心代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> s[maxn], e[maxn];<span class="comment">//s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</span></span><br><span class="line"><span class="keyword">int</span> n,id,len;</span><br><span class="line"><span class="keyword">int</span> dfsxu[<span class="number">20000</span>];<span class="comment">//存放dfs序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	s[u] = ++id;</span><br><span class="line">	dfsxu[++len]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	e[u] = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> s[maxn], e[maxn];<span class="comment">//s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</span></span><br><span class="line"><span class="keyword">int</span> n,id,len;</span><br><span class="line"><span class="keyword">int</span> dfsxu[<span class="number">20000</span>];<span class="comment">//存放dfs序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	s[u] = ++id;</span><br><span class="line">	dfsxu[++len]=u;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> v = g[u][i];</span><br><span class="line">		<span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">		dfs(v, u);</span><br><span class="line">	&#125;</span><br><span class="line">	e[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(dfsxu,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfsxu));</span><br><span class="line">	ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		g[u].push_back(v);</span><br><span class="line">		g[v].push_back(u);</span><br><span class="line">	&#125;</span><br><span class="line">	id = <span class="number">0</span>;</span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"DFS序:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;s[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dfsxu[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"入时间戳:"</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;s[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"出时间戳:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;e[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>核心代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">40010</span>]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> oulaxu[<span class="number">80020</span>]; <span class="comment">//存放欧拉序在，在欧拉序中第一次出现为“入时间戳”，第二次出现为“出时间戳”。</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">    <span class="keyword">int</span> sz=g[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">            dfs(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">40010</span>]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> oulaxu[<span class="number">80020</span>]; <span class="comment">//存放欧拉序在，在欧拉序中第一次出现为“入时间戳”，第二次出现为“出时间戳”。</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">    <span class="keyword">int</span> sz=g[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">            dfs(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(oulaxu,<span class="number">0</span>,<span class="keyword">sizeof</span>(oulaxu));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> from,to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;from,&amp;to);</span><br><span class="line">            g[from].push_back(to);</span><br><span class="line">            g[to].push_back(from);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,oulaxu[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>欧拉序</tag>
      </tags>
  </entry>
  <entry>
    <title>序列求和</title>
    <url>/2020/07/03/%E5%BA%8F%E5%88%97%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/15950" target="_blank" rel="noopener">来源：牛客网</a><br>@[toc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">131072</span>K，其他语言<span class="number">262144</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>定义S(n) = 12 + 22 + … + n2，输出S(n) % 1000000007。</p>
<p>注意：1 &lt; n &lt; 1e18。</p>
</blockquote>
<a id="more"></a> 
<p><strong>输入描述:</strong></p>
<blockquote>
<p>多组输入，输入直到遇到EOF为止；</p>
<p>第一行输入一个正整数n。</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>输出S(n) % 1000000007的结果。</p>
</blockquote>
<p><strong>示例1</strong><br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">333833500</span></span><br></pre></td></tr></table></figure>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>平方和公式：1^2^+2^2^+3^2^+……+n^2^=n(n+1)(2n+1)/6<br>（建议补一补高中的一些公式，<del>我也没想起来</del> ）<br>注意题目是要mod的<br>模运算：<br>(a + b) % p = (a % p + b % p) % p<br>(a - b) % p = (a % p - b % p) % p<br>(a * b) % p = (a % p * b % p) % p<br>a ^b^ % p = ((a % p)^b^) % p<br>我们可以发现唯独没有除法的模运算，但是公式中有个 /6 需要处理，那我们可以用逆元的方式将除法变成乘法<br>逆元：整数a,b，满足a * b = 1（mod m），那么称b是a的模m乘法逆元<br>比如：A/B%C我们可以写成A * （1 / B）% C，这样就是A<em>X%C的形式，如何求X？和上面的逆元结合起来就OK了<br>这样/6%mod，我就可以写成</em> inv（6）%mod<br>求逆元的方法这里就不详细介绍了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1000000007</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	ll gcd=exgcd(a,mod,x,y);</span><br><span class="line">	<span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		ll ans=<span class="number">0</span>;</span><br><span class="line">		ans=(((n%mod)*((n+<span class="number">1</span>)%mod)%mod*((<span class="number">2</span>*n+<span class="number">1</span>)%mod))%mod);</span><br><span class="line">		ll inv6=inv(<span class="number">6</span>,mod);</span><br><span class="line">		ans=(ans%mod*inv6%mod)%mod;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>序列自动机</title>
    <url>/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/</url>
    <content><![CDATA[<p>题目：<br>给你a和b两个字符串，问b是不是a的子序列？</p>
<ul>
<li>题解：<br><a href="https://ac.nowcoder.com/discuss/396686" target="_blank" rel="noopener">参考题解</a><br>注意看，子序列不是子串，两者含义不一样</li>
</ul>
<blockquote>
<p>一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S<br>通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。</p>
</blockquote>
<a id="more"></a>
<p>可以理解成：abc是abcd的子串，abc是adbewc的子序列，而非子串<br>求子串可以用kmp<br>那求子序列就用今天要讲的序列自动机<br>字符串A：abcdefgh<br>字符串B：aez<br>当a匹配过后，再去枚举后面的bcd没有意义，因为我们要找的是A中是否要aez三个字符，并且是这样的顺序，无须是连着的。如果我们能在a之后直接跳到a后面的一个e，再跳到e后面第一个z，等到子串B遍历完，或者在a中找不到了，我们就可以结束啦。<br>注意：我们在往后跳找字母时，比如a后面有很多个e，那么我们选第一个，因为如果第一个不行的话，那第二个第三个也白瞎，我们选的越往前其实选择空间就越大<br>仔细想想怎么能实现跳跃查找这个呢：<br>开个数组next[i][j]表示主串第i个字母之后的第一个‘a’+j的坐标，<br>next的维护只需要从后向前扫描主串，到第i位时维护一个数组last[j]，j表示对应的‘a’~‘z’，last反映的是最靠前的字母j在哪里，然后把值赋给next就ok了<br>这样查找时顺着走就可以了<br>每次匹配B复杂度是O（|B|），<br>总复杂度O(26|A|+|B|)，因为A要用26个字母都循环一遍所以是26|A|<br>可以通过下图理解<br><img src="https://img-blog.csdnimg.cn/20200402131626533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6 + 10;</span><br><span class="line">int n, t, next[maxn][30];</span><br><span class="line">char s[maxn], str[maxn];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	scanf(<span class="string">"%s"</span>, s+1);</span><br><span class="line">	int len = strlen(s+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=len; i; i--) &#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=0; j&lt;26; j++) </span><br><span class="line">		&#123;</span><br><span class="line">		next[i-1][j] = next[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		next[i-1][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	scanf(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span>(t--)&#123;</span><br><span class="line">		scanf(<span class="string">"%s"</span>, str);</span><br><span class="line">		int lenc = strlen(str), f = 0;</span><br><span class="line">		int now=0;</span><br><span class="line">		<span class="keyword">for</span>(int i=0; i&lt;lenc; i++)&#123;</span><br><span class="line">			now = next[now][str[i]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(!now) &#123;</span><br><span class="line">				f = 1;</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f) puts(<span class="string">"No"</span>);</span><br><span class="line">		<span class="keyword">else</span> puts(<span class="string">"Yes"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>求组合数C(n,m) % mod的几种方法</title>
    <url>/2020/04/29/%E6%B1%82%E7%BB%84%E5%90%88%E6%95%B0C-n-m-mod%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/cutedumpling/article/details/81840047?utm_source=distribute.pc_relevant.none-task-blog-baidujs-1" target="_blank" rel="noopener">转载</a></p>
<p>@[TOC]</p>
<h2 id="算法一：乘法逆元，在m-n和mod比较小的情况下适用"><a href="#算法一：乘法逆元，在m-n和mod比较小的情况下适用" class="headerlink" title="算法一：乘法逆元，在m,n和mod比较小的情况下适用"></a>算法一：乘法逆元，在m,n和mod比较小的情况下适用</h2><p>乘法逆元：（a/b）% mod = a * b^(mod-2)，mod为素数<br><img src="https://img-blog.csdnimg.cn/20200429232308242.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">9982</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL n = MOD<span class="number">-2</span>; </span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   <span class="keyword">if</span>(n &amp; <span class="number">1</span>)	</span><br><span class="line">	   	 res=res*x%MOD;</span><br><span class="line">	   x=x*x%MOD;</span><br><span class="line">	   n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res%MOD;	</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n,LL m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(n &lt; m)<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(m &gt; n-m) m = n-m;  </span><br><span class="line"> </span><br><span class="line">    LL up = <span class="number">1</span>, down = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span> ; i &lt; m ; i ++)&#123;  </span><br><span class="line">        up = up * (n-i) % MOD;  <span class="comment">//分子 </span></span><br><span class="line">        down = down * (i+<span class="number">1</span>) % MOD;  <span class="comment">//分母 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> up * <span class="built_in">pow</span>(down) % MOD;  <span class="comment">//乘法逆元 </span></span><br><span class="line">&#125;  </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">	LL ans = C(n,m)%MOD; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法二：Lucas定理-乘法逆元，适用于mod为素数且大小为10-5左右"><a href="#算法二：Lucas定理-乘法逆元，适用于mod为素数且大小为10-5左右" class="headerlink" title="算法二：Lucas定理 + 乘法逆元，适用于mod为素数且大小为10^5左右"></a>算法二：Lucas定理 + 乘法逆元，适用于mod为素数且大小为10^5左右</h2><p>**Lucas定理：我们令 n = tp + r , m = sp + q .（q ，r ≤p）,那么 <img src="https://private.codecogs.com/gif.latex?C_%7Btp&plus;r%7D%5E%7Bsp%20&plus;%20q%7D%20%5Cequiv%20C%20_%7Bt%7D%5E%7Bs%7DC%20_%7Br%7D%5E%7Bq%7D%28mod%28p%29%29" alt="在这里插入图片描述"></p>
<p>即：Lucas(n,m,p)=C(n%p,m%p)<em>Lucas(n/p,m/p,p)*</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">100000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL n = MOD<span class="number">-2</span>; </span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(n &amp; <span class="number">1</span>)    </span><br><span class="line">            res=res*x%MOD;</span><br><span class="line">       x=x*x%MOD;</span><br><span class="line">       n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res%MOD;    </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(LL n,LL m)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(m &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(n &lt; m)<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(m &gt; n-m) m = n-m;  </span><br><span class="line"> </span><br><span class="line">    LL up = <span class="number">1</span>, down = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(LL i = <span class="number">0</span> ; i &lt; m ; i ++)&#123;  </span><br><span class="line">        up = up * (n-i) % MOD;  <span class="comment">//分子 </span></span><br><span class="line">        down = down * (i+<span class="number">1</span>) % MOD;  <span class="comment">//分母 </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> up * <span class="built_in">pow</span>(down) % MOD;  <span class="comment">//乘法逆元 </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//当n和m比较大，mod是素数且比较小的时候（10^5左右），通过Lucas定理计算</span></span><br><span class="line"><span class="function">LL <span class="title">Lucas</span><span class="params">(LL n, LL m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n%MOD,m%MOD)*Lucas(n/MOD,m/MOD)%MOD;    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    LL ans;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">        ans = Lucas(n,m)%MOD;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法三：预处理-乘法逆元，适用于mod为素数且比较大的时候（超过10-5）"><a href="#算法三：预处理-乘法逆元，适用于mod为素数且比较大的时候（超过10-5）" class="headerlink" title="算法三：预处理 + 乘法逆元，适用于mod为素数且比较大的时候（超过10^5）"></a>算法三：预处理 + 乘法逆元，适用于mod为素数且比较大的时候（超过10^5）</h2><p><strong>预处理的时候注意: m!的MOD次方 = (m-1)!的MOD次方 * m的MOD次方</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"> </span><br><span class="line">LL fact[maxn+<span class="number">5</span>];	<span class="comment">//阶乘 </span></span><br><span class="line">LL a[maxn+<span class="number">10</span>];	<span class="comment">// 乘法逆元 </span></span><br><span class="line"><span class="comment">//LL inv[maxn+10];	//快速幂 </span></span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">pow</span><span class="params">(LL x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL n = MOD<span class="number">-2</span>;</span><br><span class="line">    LL res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	   <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)	</span><br><span class="line">	   	 res=res*x%MOD;</span><br><span class="line">	   x=x*x%MOD;</span><br><span class="line">	   n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;	</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//  inv[1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000005</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fact[i] = fact[i<span class="number">-1</span>] * i % MOD;</span><br><span class="line">		a[i] = a[i<span class="number">-1</span>] * <span class="built_in">pow</span>(i) % MOD;	<span class="comment">//m!的MOD次方 = (m-1)!的MOD次方 * m的MOD次方 </span></span><br><span class="line"><span class="comment">//      inv[i] = (MOD - MOD/i)*inv[MOD%i]%MOD;</span></span><br><span class="line"><span class="comment">//      a[i] = a[i-1] * inv[i] % MOD;	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;	<span class="comment">//乘法逆元 </span></span><br><span class="line">	<span class="keyword">if</span>(n&lt;<span class="number">0</span>||m&lt;<span class="number">0</span>||n&lt;m)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fact[n]*a[n-m]%MOD*a[m]%MOD;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> T,n,m;</span><br><span class="line">	LL ans;</span><br><span class="line">	init();<span class="comment">//预处理 </span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">		ans = C(n,m)%MOD;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>算法讲解</category>
      </categories>
      <tags>
        <tag>组合数</tag>
        <tag>取模运算</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客每日一题3.31 城市网络</title>
    <url>/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13331" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<blockquote>
<p>题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。<br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v<br>），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行，两个正整数 n , q (2 ≤ n ≤ 10^5^ , 1 ≤ q ≤ 10^5^)。 第二行，n 个正整数 a_i (1 ≤<br>a_i ≤ 10^5) 描述每个城市售卖的珠宝的价值。 接下来 n-1 行，每行描述一条道路 x , y (1 ≤ x,y ≤<br>n)，表示有一条连接 x 和 y 的道路。 接下来 q 行，每行描述一次行程 u , v , c (1 ≤ u,v ≤ n , 1 ≤ c<br>≤ 10^5^)。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>对于每次行程输出一行，为所购买次数。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">3 5 1 2 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 2 1</span><br><span class="line">4 2 2</span><br><span class="line">4 2 3</span><br><span class="line">5 1 5</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>题解:<br>毋庸置疑就是用倍增来做<br>那什么是倍增呢？<br>（先挖个坑，有空做个倍增的讲解）<br>递推式fa[i][j] = fa[fa[i][j-1]][j - 1],只要倍增得到fa[i][0]就行，因为有了这个后面都可以推出<br>fa[i][j] 代表i节点往上走2^j的距离，且比当前大的点<br>每次查询时，在所有需要问的点加一条新点，连在u的下方，新点的权值就是询问的初始权值，从这个新点往上倍增就可以了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">const int maxn=2e5+2;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int fa[maxn][23];</span><br><span class="line">int n,q;</span><br><span class="line">int to[maxn];</span><br><span class="line">vector&lt;int&gt; W[2*maxn];</span><br><span class="line">void dfs(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">	int pos=f;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(int i=21;i&gt;=0;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(fa[pos][i]&amp;&amp;a[fa[pos][i]]&lt;=a[u])</span><br><span class="line">		pos=fa[pos][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a[pos]&gt;a[u])fa[u][0]=f;</span><br><span class="line">	<span class="keyword">else</span> fa[u][0]=fa[pos][0];</span><br><span class="line">	<span class="keyword">for</span>(int i=1;fa[fa[u][i-1]][i-1];i++)</span><br><span class="line">	&#123;</span><br><span class="line">		fa[u][i]=fa[fa[u][i-1]][i-1];</span><br><span class="line">	&#125;</span><br><span class="line">		dis[u]=dis[f]+1;</span><br><span class="line">	<span class="keyword">for</span>(int v=0;v&lt;W[u].size();v++)</span><br><span class="line">	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(W[u][v]==f)<span class="built_in">continue</span>;</span><br><span class="line">		dfs(W[u][v],u);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int a;</span><br><span class="line">	  int b;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        W[a].push_back(b);</span><br><span class="line">        W[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i =1; i &lt;= q ; ++i)&#123;//增加新点</span><br><span class="line">        int aa,b,c;</span><br><span class="line">        scanf(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;b,&amp;c);</span><br><span class="line">        W[n+i].push_back(aa);</span><br><span class="line">        W[aa].push_back(i+n);</span><br><span class="line">        a[n+i] = c;</span><br><span class="line">        to[n+i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">   int sum = 0; </span><br><span class="line">   int pos;</span><br><span class="line">    <span class="keyword">for</span>(int i = n+1; i &lt;= n+q; ++i)&#123;</span><br><span class="line">       pos=i;</span><br><span class="line">      sum=0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 21; j &gt;= 0; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[fa[pos][j]] &gt;= dis[to[i]]) &#123;</span><br><span class="line">                sum += (1 &lt;&lt; j);</span><br><span class="line">				pos= fa[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 32768K  其他语言 65536K<br> 64bit IO Format:%lld</p>
<p><a href="https://ac.nowcoder.com/acm/problem/50528" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">洛谷</a><br> <strong>题目描述</strong><br>给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：</p>
</blockquote>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200329120250163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>你的任务是找出窗体在各个位置时的最大值和最小值。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第1行：两个整数N和K； 第2行：N个整数，表示数组的N个元素(≤2×10^9^)；</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>第一行为滑动窗口从左向右移动到每个位置时的最小值，每个数之间用一个空格分开；<br>第二行为滑动窗口从左向右移动到每个位置时的最大值，每个数之间用一个空格分开。</p>
</blockquote>
<p>示例1<br>输入<br>8 3<br>1 3 -1 -3 5 3 6 7<br>输出<br>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7<br>备注:<br>对于20%的数据，K≤N≤1000；<br>对于50%的数据，K≤N≤10^5^<br>对于100%的数据，K≤N≤10^6^<br><strong>题解：</strong><br>老题了。。<br>（<del>想起来我当年逝去的OI梦</del> ）</p>
<p>赶紧从洛谷找到以前的代码<br>就是单调队列的模板题<br><del>手写就完事了</del> </p>
<p>构造一个单调队列，<br>我们来模拟下过程：<br>（以求最小为例）<br>head指向头，tail指向尾<br>a[]是我们一开始存放的数<br>mi存放的是最小值的坐标（即 i ）<br>i是指向数组a当前位置<br>m=3<br>例如 1 3 -1<br>坐标 1 2  3<br>1和3顺利存入mi中（存的是坐标）mi={1,2}；<br>读入-1时与前面的进行比较，-1&lt;3然后tail–，-1&lt;1,tail–,直到整个区间都比完（也就是tail大于head时），或者是出现比-1还小的数x，tail就在x的位置停下来。然后将-1的坐标存入到mi[++tail]中,说明从tail之后没有比-1还小的了.<br>m=3<br>例如1 2 4 5 4<br>如果读入的数没有比之前小的，就依次读入mi中，mi=[1,2,3],head=1;当i=4时,就超出m的范围时（mi[head]+m&lt;=i），就将区间向后移动（head++，头向后移动，整个区间也跟着移动），随着输出（将多的输出来）<br>然后一直循环就可以了。<br>head指的是mi，mi反应的是当前最小值在a中的坐标<br>也可以写两个数组来一个表示单调队列，一个表示对应的在原列表里的序号，我这就用了一个。<br>（话说线段树也可以做）<br><del>讲的我自己也有点乱，明白但是讲不大出来，结合者代码看吧</del> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+3;</span><br><span class="line">int a[maxn];</span><br><span class="line">int ma[maxn];</span><br><span class="line">int mi[maxn]; </span><br><span class="line">void min(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">	int head=1;</span><br><span class="line">	int tail=0;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;mi[head]+m&lt;=i)</span><br><span class="line">		head++;//向后移动head</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&lt;a[mi[tail]])</span><br><span class="line">		tail--;//向前移动tail</span><br><span class="line">		</span><br><span class="line">		tail++;</span><br><span class="line">		mi[tail]=i;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[mi[head]]&lt;&lt;<span class="string">" "</span>;//如果元素超出就输出当前区域最小</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">void max(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">	int head=1;</span><br><span class="line">	int tail=0;</span><br><span class="line">	<span class="keyword">for</span>(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;ma[head]+m&lt;=i)head++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&gt;a[ma[tail]])tail--;</span><br><span class="line">		tail++;</span><br><span class="line">		ma[tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[ma[head]]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int n,m;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(n)cin&gt;&gt;a[i];</span><br><span class="line">	min(n,m);</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">	max(n,m);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客算法周周练1</title>
    <url>/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="A-Maximize-The-Beautiful-Value"><a href="#A-Maximize-The-Beautiful-Value" class="headerlink" title="A Maximize The Beautiful Value"></a>A Maximize The Beautiful Value</h2><p><a href="http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/">站内题解</a></p>
<h2 id="B-身体训练"><a href="#B-身体训练" class="headerlink" title="B 身体训练"></a>B 身体训练</h2><p><a href="http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/">站内题解</a></p>
<a id="more"></a>
<h2 id="C-Borrow-Classroom"><a href="#C-Borrow-Classroom" class="headerlink" title="C Borrow Classroom"></a>C Borrow Classroom</h2><p>待定。。。</p>
<h2 id="D-景区路线规划"><a href="#D-景区路线规划" class="headerlink" title="D 景区路线规划"></a>D 景区路线规划</h2><p>待定。。。</p>
<h2 id="E-幸运数字Ⅱ"><a href="#E-幸运数字Ⅱ" class="headerlink" title="E 幸运数字Ⅱ"></a>E 幸运数字Ⅱ</h2><p><a href="http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/">站内题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>牛客算法周周练2</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/">站内题解</a></p>
<h2 id="B-Music-Problem"><a href="#B-Music-Problem" class="headerlink" title="B Music Problem"></a>B Music Problem</h2><p><a href="http://jozky.top/2020/04/17/Music-Problem/">站内题解</a></p>
<h2 id="C-完全平方数"><a href="#C-完全平方数" class="headerlink" title="C 完全平方数"></a>C 完全平方数</h2><p><a href="http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/">站内题解</a></p>
<h2 id="D-小H和游戏"><a href="#D-小H和游戏" class="headerlink" title="D 小H和游戏"></a>D 小H和游戏</h2><p><a href="http://jozky.top/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/">站内题解</a></p>
<h2 id="E-水题-water"><a href="#E-水题-water" class="headerlink" title="E 水题(water)"></a>E 水题(water)</h2><p><a href="http://jozky.top/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/">站内题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>清明追思家国永念</title>
    <url>/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/</url>
    <content><![CDATA[<p>我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行<img src="https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p>本来想睡觉，企鹅群不小心看见一些发言气醒了。</p>
<p>4月4日默哀是形式主义?</p>
<p>你知道什么是形式主义吗?这种公共活动都是形式主义?死去的同胞、牺牲的医护都配不上，那谁还配得上这样的国礼?这算哪门子形式?</p>
<p>你可以说，我觉得宣传口的工作不够到位;你也可以说，我觉得现在才发布通知过于仓促;你还可以说，禁止的范围有待商榷。</p>
<p>无动于衷不是罪过，没有感同身受不是罪过，做不到泪流满面不是罪过，私下继续娱乐活动也不是罪过。你可以不爱听歌功颂德的文本，可以用自己的方式怀缅，可以用其他途径玩得.昏天黑地。</p>
<p>娱乐至死的时代，只有无聊才让人如临大敌，都懂。</p>
<p>做了不代表尊重，没做也不代表不尊重。</p>
<p>没有卫兵站在你家里用枪抵着你的后脑勺让你哭天抢地，没有条子叔叔把看电视打游戏听音乐的人逮起来，也没有人让你排着长队对着什么东西跪地哀嚎。事实上，没有人强迫你。只是有一点，自身的态度和对外界的要求要-致。若是不以流程怀念，就不要对着默哀的人喊你们是一群被形式主义迫害的粉红，缄默到底。若是以流程怀缅，也不必逼迫他人做超出公报内容的事，真挚只能自发。</p>
<p>你可以不立正，可以不起床。但是在鸣笛的那几分钟里，你必须清楚，你还活着，没有失去年长的亲人、远方的朋友是因为谁。你也得清楚，这样的祭奠，那些人配得上。<br>———转载<br><img src="https://img-blog.csdnimg.cn/20200404230406288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200404230410721.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网 【每日一题】4月10日 二分图染色(弱化版)</title>
    <url>/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/13229" target="_blank" rel="noopener">题目传送</a></p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述 </p>
<blockquote>
<p>给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。<br>计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>二分图单边的顶点数目n(n ≤ 10^7)</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数,即所求的答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure>

<h2 id="题意-amp-amp-题解：："><a href="#题意-amp-amp-题解：：" class="headerlink" title="题意&amp;&amp;题解：："></a>题意&amp;&amp;题解：：</h2><p>完全二分图:是一种特殊的二分图，可以把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连。<br>我们可以把左右各有n个点的二分图的题转化成n*n的棋盘问题。（离散上学过）<br>题目：让染三个颜色，红蓝绿，但是绿色并没有什么要求，我们可以最后再随便放。所以我们先考虑红和蓝。<br>红和蓝都是不能共享端点，同步到棋盘上（行和列分别表示二分图两个集合），也就是棋盘上行和列只能有一个红或蓝</p>
<p>现在的题目就是：<br>在n*n的棋盘上，放任意红和蓝棋子，任一行和列不能有相同颜色的棋子，有多少种放的方法？<br>F<del>n</del>表示棋盘大小为 n * n时的答案<br>先只考虑一个颜色： F<del>n</del>=<img src="https://img-blog.csdnimg.cn/20200416162741561.png" alt="在这里插入图片描述">)种方案(先在n行里选若干行，然后每一行选若干列，行没有顺序区分，就是选两行，选第一行和第三行与选第一行和第二行没差，所以选行用组合；而列不一样，因为行列只能放一个，我们可以先放在一行上，然后分散到其他行，所以选列的时候要考虑顺序问题，要用的是排列而不是组合)<br>如图：<br><img src="https://img-blog.csdnimg.cn/20200416164224892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如我们选两行（C^2^ <del>n</del> ），然后每行放一个，我们先考虑都放在一行上，看图中最上面两行（黄色和绿色），都是选的第一个格和第二个格，但是分散开不一样，（图中4 * 4的表格）说明我们要考虑顺序，所以选列是A^2^<del>n</del>，将所以情况加起来就是选一个颜色的方案</p>
<p>选两个颜色：从上面我们能得到一个颜色是F<del>n</del>，两个就是F<del>n</del>* F<del>n</del>，非也，因为这样会出现一个格子放两个棋子，我们还要将这种情况删去。需要容斥。<br>我们用g<del>i</del>表示最少有i个点放了两个棋子（颜色不一样）的方案数。那么除去i 行和i 列（i个点所在），我们在剩下n-i行与列里就不会有重复的，g<del>i</del> = f ^2^<del>n-i</del> 。被除去的 i 行与 i列选法和之前一样是 C^i^<del>n</del>A^i^<del>n</del> ，最后得到容斥公式：<br><img src="https://img-blog.csdnimg.cn/20200416170156368.png" alt="在这里插入图片描述"><br>（这一部分好好理解）</p>
<p>C^k^<del>n</del>A^k^<del>n</del>都可以求好，但是Fn提前求会超时，说明上面的公式不能用，我们要换一个想法来求<br>我们来考虑F<del>n</del>能不能递推出来，从F<del>n-1</del>推出F<del>n</del><br>考虑n-1到n的过程：<br>一共增加了2n-1个格子（n^2^-(n-1)^2^）,n-1之前的格子都已经放好了，我们只需要考虑多出的这些格子该怎么放。<br>如果只放一个棋子，就有2n-1个方案，如果都不放，一个方案，一共是2n种方案，也就是2n<em>F<del>n-1</del>，（F<del>n-1</del>是之前n-1行列已经放好的方案数）<br>但是有限制条件，每一行不能有相同颜色，每放一个棋子，意味着这一行这一列都不能放了，就会出现n-1种重复情况（因为是从n-1的扩展来的），我们之前n-1行列的棋子都平移靠边，因为之前都是不同行同列，所以靠边后，正好占了一行一列，也就是我们在新增部分可以放的棋子，实际上是F<del>n-2</del>而非F<del>n-1</del>（这里可以看看图），那一共（n-1）F<del>n-2</del>次重复情况，可以选n-1行，而且每一列也可以进行相同操作,总的方案数就是2×(n−1) ^2^ ∗F(n−2)<br>借鉴邓老师的图：<br><img src="https://img-blog.csdnimg.cn/2020041617195483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还要考虑放两个的情况;<br>即最后一行和列分别放一个，这样不重复嘛<br>方案就是：（n-1）^2^</em>F(n-2)<br><img src="https://img-blog.csdnimg.cn/20200416172115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：得到公式<br>F[n]=2<em>n</em>F[n-1]-(n-1)^2^F[n-2]<br>（<del>我真的是把我所能理解都写出来了</del> ）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000004</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N],s[N],F[N];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[m] % mod * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        g[i] = <span class="number">1l</span>l * g[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        </span><br><span class="line">         ll ans1 = <span class="number">1</span>;</span><br><span class="line">   		 <span class="keyword">for</span>(;y;y &gt;&gt;= <span class="number">1</span>,x = x * x % mod)</span><br><span class="line">   		 &#123;</span><br><span class="line">   		 	        <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans1 = ans1 * x % mod;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    s[n] = ans1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        s[i] = <span class="number">1l</span>l * s[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;F[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">        F[i] = (<span class="number">2l</span>l * i * F[i - <span class="number">1</span>] - <span class="number">1l</span>l * F[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod * (i - <span class="number">1</span>) % mod) % mod;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">     ll k ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">       k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) k = <span class="number">-1</span>;</span><br><span class="line">        ans += k * C(n,i) * A(n,i) % mod * F[n - i] % mod * F[n - i] % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans + mod) % mod);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>dp</tag>
        <tag>组合</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title>水题(water)（非详细解答）</title>
    <url>/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5203/E" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述<br><img src="https://img-blog.csdnimg.cn/20200417185530435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a> 
<blockquote>
<p>其中，f(1)=1;f(2)=1;Z皇后的方案数：即在Z×Z的棋盘上放置Z个皇后，使其互不攻击的方案数。</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>输入数据共一行，两个正整数x,m，意义如“题目描述”。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一个正整数k，表示输出结尾0 的个数或者放置皇后的方案数</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">375</span> <span class="number">16</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">14200</span></span><br></pre></td></tr></table></figure>

<p>说明<br><img src="https://img-blog.csdnimg.cn/20200417185538216.png" alt="在这里插入图片描述"><br>题解：<br>看了一阵子没明白，也是从其他人那学完之后，自己总结着再写<br>这个题内含三个小题：<br>1.判断是否存在k使得f(k)=xf(k)=x<br>2.n!在m进制下末尾零的个数<br>3.Z皇后方案数<br>解答：（非详细）<br>1.F函数其实就是斐波那契数列</p>
<p>斐波那契数列平方和的性质：（就是题目中所给公式）<br><img src="https://img-blog.csdnimg.cn/20200417185913695.png" alt="在这里插入图片描述"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fi[<span class="number">1</span>] = <span class="number">1</span>, fi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;; ++i) &#123;</span><br><span class="line">    fi[i] = fi[i - <span class="number">1</span>] + fi[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (fi[i] &gt; <span class="number">1e18</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2.求n!在m进制的末尾0个数</p>
<p>首先一个结论：n!的质因子p的个数等于：1~n中p的倍数(n/p)加上(n/p)!中质因子p的个数</p>
<p>然后：<br>写出<br>将数W转化成m进制的末尾0的个数<br>的暴力代码是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(W%m==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	tot++;</span><br><span class="line">	W/m;</span><br><span class="line">&#125;<span class="comment">//tot计数</span></span><br></pre></td></tr></table></figure>
<p>可以得到 W=a * m^tot^（n是m^tot^的倍数）</p>
<p>末尾几个0，tot就是几（tot是记录末尾0<br>的数量）</p>
<p>我们看 n ! 最多可以分解出多少个m<br>质因数 pi<br>设m=p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^<br>W = n!<br> n！= a  *  m ^tot^<br>n！=a * （p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^）^tot^</p>
<p>n!=a * p<del>1</del>^b1^ <em>p<del>2</del>^b2^ *….</em>p<del>k</del>^bk^</p>
<p>b<del>k</del>=a<del>k</del> *tot</p>
<p>求出！x最多可以分解出多少个p<del>i</del></p>
<p>tot=min(b<del>k</del>/a<del>k</del>)<br>枚举k</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll prime[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=n/m;</span><br><span class="line">        n/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="comment">//n!的质因子p的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ans_solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1e18</span>+<span class="number">3</span>;</span><br><span class="line">	M=m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; prime[i] &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (M % prime[i] == <span class="number">0</span>) </span><br><span class="line">		&#123;</span><br><span class="line">			++ans1[prime[i]];</span><br><span class="line">			M /= prime[i];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">		&#123;</span><br><span class="line">            ans2[prime[i]]=getsum(x,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">        ans=min(ans,ans2[prime[i]]/ans1[prime[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>3.求z皇后方案数<br>z=x%min(13,m)+1<br>根据式子就能得到z的范围在1~13，范围不大直接打表就可以</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dabiao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	  z[<span class="number">1</span>]=<span class="number">1</span>;z[<span class="number">2</span>]=<span class="number">0</span>;z[<span class="number">3</span>]=<span class="number">0</span>;z[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">      z[<span class="number">5</span>]=<span class="number">10</span>;z[<span class="number">6</span>]=<span class="number">4</span>;z[<span class="number">7</span>]=<span class="number">40</span>;z[<span class="number">8</span>]=<span class="number">92</span>;</span><br><span class="line">      z[<span class="number">9</span>]=<span class="number">352</span>;z[<span class="number">10</span>]=<span class="number">724</span>;z[<span class="number">11</span>]=<span class="number">2680</span>;</span><br><span class="line">	  z[<span class="number">12</span>]=<span class="number">14200</span>;z[<span class="number">13</span>]=<span class="number">73712</span>;</span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; z[x%min(<span class="number">13</span>*<span class="number">1l</span>l,k)+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网 【每日一题】7月9日题目 Color</title>
    <url>/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE-Color/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14254" target="_blank" rel="noopener">来源：牛客网：</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">131072</span>K，其他语言<span class="number">262144</span>K</span><br><span class="line">Special Judge, <span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给一个没有重边的二分图, 要求给边染色. 有公共点的边不能同色. 问最少用多少种颜色, 并任意构造一组方案.  输入描述:<br>第一行两个数n和m表示图的点数和边数(0&lt;n&lt;1001,0&lt;m&lt;2001). 之后m行每行2个数表示一条边的两个端点. 点从1编号到n.<br>保证给的是二分图.</p>
</blockquote>
<a id="more"></a>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>第一行一个数k表示需要多少种颜色. 接下来m行每行一个数表示输入的边的颜色. 按照输入的顺序输出, 颜色从1编号到k.</p>
</blockquote>
<p>示例1<br><strong>输入</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>题目要求有公共点的边不能同色，最后要求最少的颜色数<br>所以有公共点的边我们就让他同色<br>二分图匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（也就是匹配出没有共同点的边）<br>边数最大的子图就是最大匹配<br>所以我们可以多次调用二分图最大匹配（比如匈牙利算法），为每次匹配出来的边附上色，直到全部匹配<br>但是有的边可能在多次最大匹配中都可以被匹配上，怎么保证最优呢？<br>根据题意，每个点所连的边颜色各不相同，所以答案就是度数最大的那个点，所以每次匹配有限从度数大的开始匹配<br>具体为什么从最大度下手？可以从反证法，假设从最小度开始匹配会怎么样。也可以看看<a href="https://ac.nowcoder.com/discuss/448422" target="_blank" rel="noopener">官方解释</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//点i的度数 </span></span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],col[<span class="number">1040</span>][<span class="number">1040</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> match[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> d[x]&gt;d[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!vis[v])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[v]=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(match[v]==<span class="number">0</span>||dfs(match[v]))</span><br><span class="line">			&#123;</span><br><span class="line">				match[v]=u;</span><br><span class="line">				match[u]=v;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">	sort(id+<span class="number">1</span>,id+<span class="number">1</span>+n,cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">		d[x[i]]++;</span><br><span class="line">		d[y[i]]++;</span><br><span class="line">		ans=max(ans,max(d[x[i]],d[y[i]]));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)id[i]=i;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">		<span class="keyword">if</span>(!col[x[j]][y[j]])<span class="comment">//该边还未被标记 </span></span><br><span class="line">		&#123;</span><br><span class="line">			g[x[j]].push_back(y[j]);<span class="comment">//存边 </span></span><br><span class="line">			g[y[j]].push_back(x[j]);</span><br><span class="line">		&#125;</span><br><span class="line">		init();</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k=id[j];j&lt;=n;j++,k=id[j])<span class="comment">//从度数最大的开始下手 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!match[k]) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">				dfs(k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//对每一次最大匹配进行染色 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(match[j])<span class="comment">//如果j已经匹配 </span></span><br><span class="line">			&#123;</span><br><span class="line">				col[j][match[j]]=i;<span class="comment">//染上色 </span></span><br><span class="line">				d[j]--;</span><br><span class="line">			&#125;</span><br><span class="line">			g[j].clear();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;col[x[i]][y[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
        <tag>匈牙利算法</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客练习赛60--斩杀线计算大师</title>
    <url>/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4853/D" target="_blank" rel="noopener">题目传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。<br>数据保证一定存在解。如果存在多组解，输出任意一组。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>一行四个整数分别表示a,b,c,k</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一行输出三个整数分别表示x,y,z</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3 4 5 20</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure>

<p>备注:<br>1 ≤ a , b , c ≤ 1e5<br>0 ≤ k ≤ 1e12</p>
<ul>
<li>题意：</li>
</ul>
<p>就是多少个a+多少个b+多少个c=k<br>问你这个“多少个”分别是什么</p>
<p> <strong>题解</strong></p>
<ol>
<li>方法一</li>
</ol>
<p>把题目改成公式形式就是<br>ax+by+cz=k<br>没错，其实就是exgcd，只不过exgcd是ax+by=k<br>你把咱们这个式子再变变形<br>就能得到：<br>a x + b y = k - c * z<br>而这个z我们可以枚举<br>那就是a x + b y = k - c * i<br>题目说了肯定有解，那放心枚举i就完事了<br>把后面这部分-c<em>i当做整体M<br>ax+by=M<br>然后就是exgcd的步骤<br>用exgcd求出x0,y0<br>a</em>x0+b<em>y0=GCD(a,b)<br>两边同时除以gcd（a，b）<br>(gcd(a,b)我们用w代替)<br>两边除以w，再乘c<br>a</em>x0+b<em>y0-gcd(a,b)+b</em>y*c/gcd(a,b)=c</p>
<p>如果w=1<br>x = x0 + b *  t<br>y = y0 - a *  t<br>且对任一正数t，皆成立<br>根据这个我们就可以求出方程所有解<br>t = b / w<br>x= ( x % t + t ) % t<br><del>有空专门整理一下exgcd原理和博客</del> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod =1e9+3;</span><br><span class="line">ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!b)</span><br><span class="line">	&#123;</span><br><span class="line">		x=1;</span><br><span class="line">		y=0;</span><br><span class="line">		<span class="built_in">return</span> a;</span><br><span class="line">	&#125;</span><br><span class="line">	ll d;</span><br><span class="line">	d=exgcd(b,a%b,y,x);</span><br><span class="line">	y=y<span class="_">-a</span>/b*x;</span><br><span class="line">	<span class="built_in">return</span> d;</span><br><span class="line">&#125;//exgcd模板 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	ll a,b,c,k,x,y;</span><br><span class="line">	scanf(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line">	<span class="keyword">for</span>(ll i=0;i&lt;k/c;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll ans=(k-i*c);//去掉c*i的剩余部分</span><br><span class="line">		ll w = exgcd(a,b,x,y);</span><br><span class="line">		<span class="keyword">if</span>(ans%w)<span class="built_in">continue</span>;</span><br><span class="line">		</span><br><span class="line">		x= x * ans / w;</span><br><span class="line">		y= y * ans / w;</span><br><span class="line">		</span><br><span class="line">		x=( x % ( b / w ) + ( b / w ) ) % ( b / w );</span><br><span class="line">		y= ( ans - x * a ) / b;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(x&gt;=0&amp;&amp;y&gt;=0)</span><br><span class="line">		&#123;</span><br><span class="line">			cout&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line">			<span class="built_in">return</span> 0;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>方法二</li>
</ol>
<p>公式还有个变形方式：<br>k-ax-by=cz<br>(k-ax-by)/c=z<br>也就是( k - a x - b y ) % c = = 0<br> ( k - a i - b j ) % c = = 0<br> 枚举i和j就ok了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(j)</span><br><span class="line"> &#123;</span><br><span class="line">	 <span class="keyword">if</span>( k - a i - b j ) % c = = 0</span><br><span class="line">	 &#123;</span><br><span class="line">	 cout&lt;&lt;;</span><br><span class="line">	 &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>曾经noip好像考过ecgcd裸题感兴趣可以做做</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>exgcd</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网2020愚人节比赛</title>
    <url>/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/</url>
    <content><![CDATA[<h2 id="牛客2020年愚人节比赛2020-4-1-21-32-11"><a href="#牛客2020年愚人节比赛2020-4-1-21-32-11" class="headerlink" title="牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 "></a>牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 </h2><p><del>欢乐的一晚上</del><br><a href="https://ac.nowcoder.com/acm/contest/4863#question" target="_blank" rel="noopener">题目链接</a><br>其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感<br><img src="https://img-blog.csdnimg.cn/20200401211211311.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211308221.png" alt="在这里插入图片描述">不知道这是哪位哥的，心疼一下</p>
<a id="more"></a>
<p><strong>题解</strong><br>注：一下题解没必要较劲，欢乐局而已<br>对不对无所谓，换了最重要奥<br>A题rand36：<br>我试了好几个数，最后3过了，以为答案3，结果发现答案是随机的，看命了有人一下就过。。。<br>B寻宝游戏：<br>要找的宝贝就在宝藏图上，输出题目中图的地址就ac了<br>C老铁安排上：<br>看图是什么手机？老年机，所以是九字输入法，字母按照九字输入法的对应数字<br>D神奇的字母<br>输出题目中的样例<br>“一个字符，表示神奇的字母（范围从’a’到’z’，保证小写）。”<br>即可<br>E return1；<br>不会（笑哭）貌似场上唯一一个没人做出来的题<br>F 抬头，答案在天上<br>天上就是指你浏览器的上面，也就是网址，按照顺序对应相应的数字<br>G抬头在地上<br>就是看字地下的标点符号，你会发现有个标点符号是超链接，输出超链接地址即可<br>H园<br>问你能套多少园，可没说不能套娃哦<del>，n是几就能套几个<br>I牛客搜索题<br>这里面最扯的题（个人感觉<img src="https://img-blog.csdnimg.cn/20200401212525727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">）<br>J签到题<br>不会（笑哭）<br>K四万像素五角星<br>有个大佬手打出来了。。。<br>L positive-integer<br>经过证明<br>n=1时，输出1；<br>其他输出0<br>证明过程嘛。。。（</del>多尝试几次就OK了，不怕失败，都wa了多少次了）~~<br>好像官方出题解了，看官方题解吧<br><a href="https://ac.nowcoder.com/discuss/396514?type=101&order=0&pos=5&page=1" target="_blank" rel="noopener">题解</a></p>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
      <tags>
        <tag>欢乐局</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月25日 tokitsukaze and Soldier</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/</url>
    <content><![CDATA[<p>@<a href="牛客网【每日一题】3月25">TOC</a></p>
<p> 题号：NC50439<br>名称： tokitsukaze and Soldier<br>来源：练习赛50-C<br>链接: <a href="https://ac.nowcoder.com/acm/problem/50439" target="_blank" rel="noopener">牛客网</a>.</p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。<br>第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。<br>但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)<br>tokitsukaze想知道，团的战力最大为多少。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<p>第一行包含一个正整数n(1≤n≤10^5)。<br>接下来n行，每行包括2个正整数v,s(1≤v≤10^9,1≤s≤n)。</p>
<p>输出描述:</p>
<p>输出一个正整数，表示团的最大战力。</p>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p>示例2<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">100 1</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure>

<p><strong><em>思路</em></strong><br>所求的最大战斗力由v和s这两个因素限制。<br>结构体数组a存放v和s，然后对其排序，先按照s从大到小，如果s相同再排v，也是从大到小（先要保证足够的人数，后面好进行取舍）。<br>定义一个从小到大的优先队列q，ans相互跟随q，（q每次添加一个战力值，同时用ans加上战力值；ans删去，q也弹出），战力值的先后加入由s的排序决定，当q的元素数量大于当前s的值时（s是由大到小的排序的），就将多出的部分pop出（q是从小到大排序，所以弹出的总是其中最小值），再用ans减去，这样ans的值即为在人数限定在s内的最佳情况（因为弹出的是最小值，相对于前s个数的和，所以之后也不用再考虑被弹出的数），记录ans的最大值<br><del>我刚开始提交是70多分，想了一阵子才发现是数组开小了（笑哭）</del> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v,s;	</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(a.s!=b.s)<span class="keyword">return</span> a.s&gt;b.s;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> a.v&gt;a.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i].v&gt;&gt;a[i].s;</span><br><span class="line">	&#125;</span><br><span class="line">	sort (a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//	int tot=0;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> minn=maxn;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q.push(a[i].v);</span><br><span class="line">		ans+=a[i].v;</span><br><span class="line">		<span class="keyword">while</span>(q.size()&gt;a[i].s)</span><br><span class="line">		&#123;</span><br><span class="line">			</span><br><span class="line">			ans-=q.top();</span><br><span class="line"><span class="comment">//			printf("q.size=%d,a[i].s=%d,ans=%d\n",q.size(),a[i].s,ans);</span></span><br><span class="line">			q.pop();</span><br><span class="line"><span class="comment">//			tot--;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(ans&gt;maxx)maxx=ans;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;maxx;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code></code></pre>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月26日 合并回文子串</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><strong>题号：NC13230<br>名称：合并回文子串<br>来源：美团2017年CodeM大赛-初赛A轮</strong><br><a href="https://ac.nowcoder.com/acm/problem/13230" target="_blank" rel="noopener">题目链接</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<p><strong>题目描述</strong></p>
<blockquote>
<p>输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。<br>我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。<br>需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>第一行一个整数T(T ≤ 50)。 接下来2T行，每两行两个字符串分别代表A,B(|A|,|B| ≤ 50)，A,B的字符集为全体小写字母。</p>
</blockquote>
<p>输出描述:</p>
<p>对于每组数据输出一行一个整数表示价值最大的C的价值。<br>示例1</p>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">a</span><br><span class="line">aaaabcaa</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>思路：区间dp问题</strong><br>dp[i][j][m][n]表示A中下标i到j-1以及B中下标m到n-1的串，能否组成回文串<br>(dp值为零则表示不构成回文串，不为零则表示构成)<br>首先：字符本身是回文串<br>其次，分为四种情况<br>a[i]==a[j-1]        dp[i][j][m][n]+=c[i+1][j-1][m][n];<br>因为dp我们只考虑是否为0或非0，所以dp之间可以+=也可以|=,都不影响<br>（当A的第i为和第j-1位相同时，那么dp[i][j]是否为回文串就取决于比它小一层的dp[i+1][j-1]，这样一次往里推，就可以推到以一种情况）<br>b[m]==b[n-1]    dp[i][j][m][n]+=c[i][j][m+1][n-1];<br>(和上一个思路相同)</p>
<p>a[i]==b[n-1]        dp[i][j][m][n]+=c[i+1][j][m][n-1];<br>（当A的i与B的n-1相同时，那么dp[i][][][n]是否为回文串就取决于A的后一位i+1和B的前一位n-1的情况）<br>a[m]==b[j-1]    dp[i][j][m][n]+=c[i][j-1][m+1][n];<br><strong>代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">int t;</span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int c[maxn][maxn][maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	char ch=getchar();</span><br><span class="line">	int j;</span><br><span class="line">	int n;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		int ans=0;</span><br><span class="line">		cin&gt;&gt;a;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		cin&gt;&gt;b;</span><br><span class="line">		ch=getchar();</span><br><span class="line">		int len1=strlen(a),len2=strlen(b);</span><br><span class="line">		<span class="keyword">for</span>(int tj=0;tj&lt;=len1;tj++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(int tn=0;tn&lt;=len2;tn++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(int i=0;i+tj&lt;=len1;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span>(int m=0;m+tn&lt;=len2;m++)</span><br><span class="line">					&#123;</span><br><span class="line">						j=i+tj;</span><br><span class="line">						n=m+tn;</span><br><span class="line">						<span class="keyword">if</span>(tj+tn&lt;=1)c[i][j][m][n]=1;</span><br><span class="line">						<span class="keyword">else</span></span><br><span class="line">						&#123;</span><br><span class="line">							c[i][j][m][n]=0;</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=2&amp;&amp;a[i]==a[j-1])c[i][j][m][n]|=c[i+1][j-1][m][n];                                               </span><br><span class="line">							<span class="keyword">if</span>(tn&gt;=2&amp;&amp;b[m]==b[n-1])c[i][j][m][n]|=c[i][j][m+1][n-1];</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[i]==b[n-1])c[i][j][m][n]|=c[i+1][j][m][n-1];</span><br><span class="line">							<span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[m]==b[j-1])c[i][j][m][n]|=c[i][j-1][m+1][n];</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span>(c[i][j][m][n])ans=max(ans,tj+tn);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		 &#125; </span><br><span class="line">		cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另外</strong><br>tj和tn从0开始，不断讨论A中i到i+tj和B中m到tn的回文字符串</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>区间dp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网 【每日一题】4月15日 Treepath</title>
    <url>/2020/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8815%E6%97%A5-Treepath/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14248" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一棵n个点的树，问其中有多少条长度为偶数的路径。路径的长度为经过的边的条数。x到y与y到x被视为同一条路径。路径的起点与终点不能相同。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行一个数n表示点的个数； 接下来n-1行，每行两个整数x，y表示边； 保证输入数据形成一棵树； 1&lt;=n&lt;=100000</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>一行一个整数表示答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>求长度为偶数的路径<br>偶数层的点到偶数层的点长度是偶数<br>奇数层到奇数层的点的路径长度也是偶数<br>奇数层的点到偶数层的点路径长度就算奇数<br>所以需要统计多少个奇数层多少点偶数层多少点<br>我们发现如果层数奇偶性一样，路径长度就是偶数<br>为什么呢？引用邓老师的讲解</p>
<blockquote>
<p>我们可以考虑先让两个点里深度深的那个往上走，走到和另外一个点一样的高度，这个显然是偶数步完成的，之后两个点一起往上走直到汇合，走到步数是一样的，所以最终加起来也是偶数。</p>
</blockquote>
<p>然后我们会用到数组dp[][]<br>dp[i][0/1]表示以i为根的子树，与根节点i的距离<br>因为距离长度只有偶数奇数两种情况，所以我们把偶数设为0，奇数设为1，这样好统计<br>u是v的父亲，<br>也就是一个来自v的子树的点，到u点的路径会比到v的路径长度 长1<br>这样我们有：<br>dp[u][0]+=dp[v][1]<br>以u为根的子树，与u的距离长度为偶数的情况一个本身，另一个来自dp[v][i].因为以v为根节点，与v的距离为奇数，那到u的距离就要加1，也就是偶数<br>dp[u][1]+=dp[v][0]<br>同理</p>
<p>sum + = dp [ u ] [ 0 ] * dp [ v ] [ 1 ] + dp [ u] [ 1 ] * dp [ v ] [ 0 ]<br>已有dp[u][0]条以u为端点长度为偶数的路径，与dp[v][1]条以v为端点长度为奇数的路径合并可以得到 dp [ u ] [ 0 ] * dp [ v ] [ 1 ]   条长度为偶数的路径<br>同理dp[u][i]*dp[v][0]也是一样</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll dp[maxn][<span class="number">3</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dp[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> v : edge[u]) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">		dfs(v,u);</span><br><span class="line">	</span><br><span class="line">			sum+=dp[u][<span class="number">0</span>]*dp[v][<span class="number">1</span>]+dp[u][<span class="number">1</span>]*dp[v][<span class="number">0</span>];</span><br><span class="line">			dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];</span><br><span class="line">			dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">int</span> a,b;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">		edge[a].push_back(b);</span><br><span class="line">		edge[b].push_back(a);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dp</tag>
        <tag>树上dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】3月27日 数学考试</title>
    <url>/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/</url>
    <content><![CDATA[<blockquote>
<p> 题号 NC15553<br> 名称 数学考试<br> 来源 2018年长沙理工大学第十三届程序设计竞赛<br>链接：<a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15553</a><br>来源：牛客网<br><a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">试题传送门</a><br>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述<br>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br>他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br>即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行一个整数T（T&lt;=10）,代表有T组数据 接下来一行两个整数n,k,(1&lt;=n&lt;=200,000),(1&lt;=k,2k &lt;= n)<br>接下来一行n个整数a1,a2,…,an，（-100,000&lt;=ai&lt;=100,000）</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数，qwb能获得的最大分数</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">8 2</span><br><span class="line">-1 0 2 -1 -1 2 3 -1</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p><strong><em>题解：</em></strong><br>题意就是求不想交的前缀与后缀和的最大值<br>第一反应是线段树（<del>毕竟是有关区间查询</del> ） ，不过仔细想想也不能这么麻烦（<del>打线段树不累吗？</del> ） ，不过也有大佬用线段树做的。<br>根据题意知道前缀与后缀长度一样，依据朴素的原则单纯打暴力肯定不行，需要优化优化，怎么优化呢？</p>
<p>我们先求出所有前缀和q[]<br>然后按照给定前后缀的长度k，求出每个k长区间的和<br>比如 -1 0 2 -1 -1 2 3 -1   k=2；<br>每个k长区间的和为：w[]-1 2 1 -2 1 5 2<br>我们所要求的最大值max=dp1+dp2<br>dp1是前缀和最大值<br>dp2是后缀和最大值<br>那其实就是在w中取一个dp1再取一个dp2，使他们和最大<br>但注意前缀与后缀不能相交和相连<br>方法一：<br>稍微处理下,可以先选后缀，然后前缀的范围就是去除已选的后缀，在里面取最大的前缀<br>maxx=(q[i]-q[i-k])+max(q[1],q[2],q[3]…..q[i-k-1])<br>(q[i]-q[i-k])后缀和<br>max(q[1],q[2],q[3]…..q[i-k-1])最大的前缀<br>然后求出maxx的最大值情况<br>诶，这不就是线性dp吗！wok做完才注意到<br>方法二：<br>求出前缀和所能取到的最大值（从头开始），放入数组w1<br>求出后缀和所能取到的最大值（从尾开始），放入w2中<br>然后再一个循环，求出w1[i]与w2[i+1]（即当前位i的前缀和与排在i之后的最大后缀和之和）的最大值<br>代码一</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">	  	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	  	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		cin&gt;&gt;cnt;</span><br><span class="line">	  		q[i]=q[i-1]+cnt; </span><br><span class="line">		&#125;</span><br><span class="line">		memset(w1,-128,sizeof(w1));</span><br><span class="line">			memset(w2,-128,sizeof(w2));</span><br><span class="line">		cnt=-1e10;</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		w[i]=q[i]-q[i-k];</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">				w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line">				<span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(w[i]+w1[i-k]&gt;cnt)cnt=w[i]+w1[i-k];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码二</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">	  	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	  	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		cin&gt;&gt;cnt;</span><br><span class="line">	  		q[i]=q[i-1]+cnt; </span><br><span class="line">		&#125;</span><br><span class="line">		memset(w1,-128,sizeof(w1));</span><br><span class="line">			memset(w2,-128,sizeof(w2));</span><br><span class="line">		cnt=-1e10;</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">	  	&#123;</span><br><span class="line">	  		w[i]=q[i]-q[i-k];</span><br><span class="line">		&#125; </span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">			w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=n-k+1;i&gt;=k+1;i--)</span><br><span class="line">			w2[i]=w2[i+1]&gt;w[i+k-1]?w2[i+1]:w[i+k-1];</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(w2[i+1]+w1[i]&gt;cnt)cnt=w2[i+1]+w1[i];</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对了还有变形的问题：<br><del>（等晚上有空再想吧）</del> </p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>前缀后缀和</tag>
        <tag>dp</tag>
        <tag>线性dp</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月16日 逆序对</title>
    <url>/2020/04/19/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8816%E6%97%A5-%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14731" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>求所有长度为n的01串中满足如下条件的二元组个数： 设第i位和第j位分别位ai和aj（i&lt;j），则ai=1,aj=0。<br>答案对1e9+7取模。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:<br>输入一个n。<br>输出描述:<br>输出答案对1e9+7取模<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>说明<br><img src="https://img-blog.csdnimg.cn/2020041911312348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注:<br> n &lt;= 10^18^</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>就是一个求逆序对<br>我们看如果1后面有5个0，就能构成5个逆序对<br>也就是我们考虑任意两个位置，只要前面是1，后面是0，无论其他位置是什么数，都能构成一个逆序对。而这样的情况有多少种，就说明有多少逆序对<br>接下来我们就要用到组合排列<br>在n个位置任选两个位置的方案数C^2^<del>n</del> ,<br>其他n-2个位置就是放0和1，随便放，那就是n-2个2相乘，就是2^n-2^,所以总逆序对是C^2^<del>n*</del> 2^n-2^</p>
<p>C^2^<del>n*</del> 2^n-2^=n<em>(n-1)/2 *2^n-2^= n *(n-1)</em>2^n-3^</p>
<p>因为n可以很大，所以要用到快速幂<br>n=1要特判一下<br>我提交后一直卡在95%，原来当n=2时程序就死循环了，所以n=2也要特判</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll sum=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line">		a=a*a%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll n;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;( ( ( n%mod )* ( ( n<span class="number">-1</span> ) % mod ) %mod )*(poww(<span class="number">2l</span>l,n<span class="number">-3</span>)%mod))%mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆序对</tag>
        <tag>排列组合</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月13号 Accumulation Degree</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/51180" target="_blank" rel="noopener">本题目传送</a></p>
<p>题目树学是这个题的简易版，也涉及换根问题，可以先看看这个<br><a href="https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92" target="_blank" rel="noopener">树学</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit<br>IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>Trees are an important component of the natural landscape because of<br>their prevention of erosion and the provision of a specific<br>ather-sheltered ecosystem in and under their foliage. Trees have also</p>
<a id="more"></a>
<p>been found to play an important role in producing oxygen and reducing<br>carbon dioxide in the atmosphere, as well as moderating ground<br>temperatures. They are also significant elements in landscaping and<br>agriculture, both for their aesthetic appeal and their orchard crops<br>(such as apples). Wood from trees is a common building material.</p>
<p>Trees also play an intimate role in many of the world’s mythologies.<br>Many scholars are interested in finding peculiar properties about<br>trees, such as the center of a tree, tree counting, tree coloring.<br>A(x) is one of such properties.</p>
</blockquote>
<p>A(x) (accumulation degree of node x) is defined as follows:</p>
<ol>
<li>Each edge of the tree has an positive capacity.</li>
<li>The nodes with degree of one in the tree are named terminals.</li>
<li>The flow of each edge can’t exceed its capacity.</li>
<li>A(x) is the maximal flow that node x can flow to other terminal nodes.</li>
</ol>
<p>Since it may be hard to understand the definition, an example is showed below:<br><img src="https://img-blog.csdnimg.cn/20200415184510424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="样例分析："><a href="#样例分析：" class="headerlink" title="样例分析："></a>样例分析：</h2><p>A(1)=11+5+8=24<br>Details:<br>1-&gt;2    11<br>1-&gt;4-&gt;3    5<br>1-&gt;4-&gt;5    8(since 1-&gt;4 has capacity of 13)</p>
<hr>
<p>A(2)=5+6=11<br>Details:<br>2-&gt;1-&gt;4-&gt;3    5<br>2-&gt;1-&gt;4-&gt;5    6</p>
<hr>
<p>A(3)=5<br>Details:    3-&gt;4-&gt;5    5</p>
<hr>
<p>A(4)=11+5+10=26<br>Details:    4-&gt;1-&gt;2    11<br>4-&gt;3    5<br>4-&gt;5    10</p>
<hr>
<p>A(5)=10<br>Details:    5-&gt;4-&gt;1-&gt;2    10</p>
<hr>
<p>The accumulation degree of a tree is the maximal accumulation degree among its nodes. Here your task is to find the accumulation degree of the given trees.</p>
<p>输入描述:<br>The first line of the input is an integer T which indicates the number of test cases. The first line of each test case is a positive integer n. Each of the following n - 1 lines contains three integers x, y, z separated by spaces, representing there is an edge between node x and node y, and the capacity of the edge is z. Nodes are numbered from 1 to n.<br>All the elements are nonnegative integers no more than 200000. You may assume that the test data are all tree metrics.<br>输出描述:<br>For each test case, output the result on a single line.<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure>

<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>看看样例分析应该就明白了<br>每个节点都有流量，求出最大流量是多少？</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>flow【i】表示i点的流量：<br>一个点的流量是怎么来的？如果j（j是i的子节点）的流量小于i与j边的容量，flow【i】=flow[j]，如果大于两点之间的容量，flow[i]=i与j的流量<br>i与j的流量就是i与j的边权，我们用edge[i][j]表示。<br>可以得到公式：flow[i]=∑min(flow[j],edge[i][j])<br>因为i有可能有很多子节点，所以加在一起<br>考虑完i之后，我们来考虑换根<br>如图：<img src="https://img-blog.csdnimg.cn/20200415185955370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们将根从x换成y<br>题一中（以x为根）<br>x的流量来自于y，子树2，子树3<br>y的流量来自于子树1<br>图二中（以y为根）<br>x的流量来自子树2，子树3<br>y的流量来自子树1，x</p>
<p>我们发现换根后，x的流量就没有了y的部分，其他都还在，此时x的流量就是原本的减去从y流向x的部分，new[x]=flow[ x ] - min ( flow[ y ] , edge[ x ] [ y ] ),这个new表示x新的流量</p>
<p>我们再看y，y的流量多了从x流来的部分，y的流量就是flow[y]+min(new[x],edge[x][y])，，因为换根x的流量发生改变（上一段所讲），那流向y的是现在x的流量，而不是换跟前的flow[x].</p>
<p>换根前后，图二中绿色区域没有发生改变，也就是父节点改变影响不到子节点</p>
<p>还要注意叶子节点，如果x从根变成叶子节点（x的儿子只有y，当y成为根节点之后，x没有了儿子），x的流量不是上面的公式，而是变成了edge[x][y]，因为没有子节点的流量流向x，只有x与y的边权值，也就是上面讲的式子使用条件是min（x，y），x和y不能为0。</p>
<p>先求出x为根的流量，然后依次换根求出最大值</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt = <span class="number">0</span>, d[maxn], deg[maxn], f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">	  cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].x = x;</span><br><span class="line">    edge[cnt].y = y;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg[y] == <span class="number">1</span>)&#123;<span class="comment">//如果y只有一个子节点，y的流量只能是root与y的边权值 </span></span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(y, root);</span><br><span class="line">            ans += min(d[y], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[root] = ans </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//先求出节点x的流量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg[x] == <span class="number">1</span>)&#123;</span><br><span class="line">            f[y] = d[y] + edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[y] = d[y] + min(f[x] - min(d[y], edge[i].w), edge[i].w);<span class="comment">//核心公式 </span></span><br><span class="line">        &#125;</span><br><span class="line">        dp(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//从x不断换根 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">       <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();<span class="comment">//初始化 </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">         </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            addedge(x, y, w);<span class="comment">//添边 </span></span><br><span class="line">            addedge(y, x, w);<span class="comment">//添边 </span></span><br><span class="line">                deg[x]++;<span class="comment">//deg用于判断这个点有几个子节点 </span></span><br><span class="line"> 			    deg[y]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        dfs(s, <span class="number">0</span>);<span class="comment">//求x的流量 </span></span><br><span class="line">        f[s] = d[s];</span><br><span class="line">        dp(s, <span class="number">0</span>);<span class="comment">//不断换根 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ans = max(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>树上dp</tag>
        <tag>换根</tag>
        <tag>二次扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客算法周周练14</title>
    <url>/2020/07/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%8314/</url>
    <content><![CDATA[<h2 id="A-友谊巨轮"><a href="#A-友谊巨轮" class="headerlink" title="A 友谊巨轮"></a>A 友谊巨轮</h2><h2 id="B-Circle"><a href="#B-Circle" class="headerlink" title="B Circle"></a>B Circle</h2><p>我们要找最大对数，相邻元素互质的对数其实就是n<br>因为互质说明最大公因数是1，而1与任何数a的最大公因数都是a，所以将n个数按照大小顺序首尾顺序佩列得到的互质的对数最多<br>也就是读入n输出n。。。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-Tree"><a href="#C-Tree" class="headerlink" title="C Tree"></a>C Tree</h2><h2 id="D-绝地求生-pubg"><a href="#D-绝地求生-pubg" class="headerlink" title="D 绝地求生(pubg)"></a>D 绝地求生(pubg)</h2><p>没错，你没有想错就是求最小公倍数<br>不过，我们求最小公倍数的公式是：x*y/gcd(x,y)<br>我们要先除后乘，如果x先乘y再除gcd，那就通不过了。。<br>可能是因为x和y可以取很大，乘后就更大了直接爆longlong，如果先除可以将数化小再运算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ggcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">return</span> ggcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">	<span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ll x,y;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">		<span class="comment">//ll gcd=ggcd(x,y);</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,i,x/ggcd(x,y)*y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="E-「水」悠悠碧波"><a href="#E-「水」悠悠碧波" class="headerlink" title="E 「水」悠悠碧波"></a>E 「水」悠悠碧波</h2><p>我看好多用kmp来做的，string里面本身就带着截取和查询，我们可以直接用<br>思路很简单：分别截取字符串头和尾相同的长度，比较是否相同，然后再从未截取的中间部分查询是否有截取部分，如果有记录截取片段，最后输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sum,a,a1,a2;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">	<span class="keyword">int</span> len=s.length();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(len+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		a=s.substr(<span class="number">0</span>,i);<span class="comment">//头</span></span><br><span class="line">		a1=s.substr(len-i,i);<span class="comment">//尾</span></span><br><span class="line">		a2=s.substr(i,len-i*<span class="number">2</span>);<span class="comment">//未截取部分</span></span><br><span class="line">		<span class="keyword">if</span>(a==a1&amp;&amp;a2.find(a)!=<span class="built_in">string</span>::npos)sum=a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月7号题目精讲 树</title>
    <url>/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13611" target="_blank" rel="noopener">树</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K<br>其他语言262144K<br>64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边；</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出一个整数表示方案数（mod 1e9+7）。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">39</span><br></pre></td></tr></table></figure>

<p>备注:</p>
<p>对于30%的数据，n≤10, k≤3；<br>对于100%的数据，n,k≤300。<br><strong>题解：</strong><br><del>shy爹有棵树</del><br>这个题也可以这么想，把相同颜色当成一个整体，连通块，问构成连通块的方案<br>我们用dp来计数<br>dp[i][j]表示i个点用了j个颜色的方案<br>那么转移方程就是<br>dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(k-(j-1))<br>dp[i][j]=第i个点和第i-1个点颜色相同或者第i-1个点所用的颜色与之前不同，之前用了（j-1）个颜色，这个点可用的颜色种类就是k-（j-1）<br>（可以理解成前者在一个连通块，后者不在一个连通块内）<br>因为数据给的肯定是棵树，那树的形状并不会影响结果，所以。。。也可以不输入那（n-1）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=303;</span><br><span class="line">ll mod =1e9+7;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line">int n,k;</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=1;j&lt;=k;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(i==1&amp;&amp;j==1)</span><br><span class="line">			&#123;</span><br><span class="line">				dp[i][j]=k;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-(j-1)))%mod;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=k;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum=(sum+dp[n][i])%mod;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有第二个办法：<br>一下为转载：<br>题目意思是用k个点把一个有n个节点的树染色,然后的地方必须联通,求有多少方案数?<br>下面给大家介绍两种做法..<br><img src="https://img-blog.csdnimg.cn/20200407185522399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">切边表示染色用的颜色个数,比如我要用3种颜色染色,那么我就只要考虑切2条边,比如切2-4,和3和7这是一种方案。若将树分割为 i个连通块，则需要删去 i−1条边，故方案数为 C^i-1^ n−1然后考虑染色,假如我现在切的是i条边,要从k种颜色中选出i中颜色染色，而且是有顺序的，故方案数为A(k,i+1).<br>综上，总的方案数为：<br><img src="https://img-blog.csdnimg.cn/20200407190618154.png" alt="在这里插入图片描述">可以线性求逆元，枚举 i 实现。</p>
<p>时间复杂度：O(n)<br>代码如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">const ll maxn=310;</span><br><span class="line">ll n,k,ans,inv[maxn],f[maxn];</span><br><span class="line">ll C(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[y]%mod*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll A(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    inv[0]=f[0]=inv[1]=f[1]=1;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=((mod-mod/i)*inv[mod%i])%mod,f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=(inv[i]*inv[i-1])%mod,f[i]=(f[i]*f[i-1])%mod;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=k&amp;&amp;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+(C(n-1,i-1)*A(k,i)%mod))%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.nowcoder.net/n/c76751c0215344ff99357aaee5235851" target="_blank" rel="noopener">转载地址</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>DFS序</tag>
        <tag>dp</tag>
        <tag>树上dp</tag>
        <tag>连通块</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月14日题目精讲 Xorto</title>
    <url>/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/</url>
    <content><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14247" target="_blank" rel="noopener">传送</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p>
</blockquote>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；<br>第二行n个整数表示数组； 1&lt;=n&lt;=1000,0&lt;=数组元素&lt;100000。</p>
</blockquote>
<a id="more"></a>
<p>输出描述:<br>一行一个整数表示答案。<br>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>说明<br>([1,1],[2,2]),([1,1],[3,3]),([1,1],[2,3]),([1,2],[3,3]),([2,2],[3,3])</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>枚举？TLE√<br>暴力肯定过不了，我们可以先考虑只枚举一个区间[x,y]，这个区间可以通过前缀异或和得到。pre来存前缀<br>我们用[x,y]表示右边的区间，题目要求左右区间异或和为0，也就是问[x,y]左边有多少和它值一样的区间。<br>我们可以用a[i]来存，a[i]表示左边异或和为i区间个数，数组a反应的数量，i反映的是值。<br>先将区间[k,i]存进a中，再用a[ ]来查看左边有多少区间异或和值与右区间[i+1 , j]值相同。<br>因为a存的是数量，所以直接用ans+=a [ pre[i] ^ [j] ]</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]^x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) a[pre[i]^pre[k]]++;<span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) ans += a[pre[i]^pre[j]];<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>关于异或的题我最近做了个<br>CF282E    Sausage Maximization<br><a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">牛客网题目链接</a><br>异或的题，解法挺新颖，不过不知道为什么牛客网这里不能 提交？<br>原题是cf的<a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">cf题目链接</a><br><a href="https://blog.nowcoder.net/n/2369369adcb44ebcbaf9be0a1894aa4a" target="_blank" rel="noopener">我自己写的题解</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>前缀异或和</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月2日 月月查华华的手机</title>
    <url>/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23053" target="_blank" rel="noopener">牛客网链接</a></p>
<blockquote>
<p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。<br>月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。<br>现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>第一行输入一个字符串A表示华华的昵称。 第二行输入一个正整数N表示华华的推荐好友的个数。<br>接下来N行，每行输入一个字符串BiB_iBi​表示某个推荐好友的昵称。</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>输出N行，对于第i个推荐好友，如果华华可能向她搭讪，输出Yes，否则输出No。 注意大写，同时也要注意输出效率对算法效率的影响。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">noiauwfaurainairtqltqlmomomo</span><br><span class="line">8</span><br><span class="line">rain</span><br><span class="line">air</span><br><span class="line">tql</span><br><span class="line">ntt</span><br><span class="line">xiaobai</span><br><span class="line">oiiiooo</span><br><span class="line">orzcnzcnznb</span><br><span class="line">ooooo</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure>

<p>备注:<br><img src="https://img-blog.csdnimg.cn/20200402104928886.png" alt="在这里插入图片描述"><br><strong><em>题解：</em></strong><br>字符串问题<br>有两个解决方法，字典树和序列自动机都能做（我想到的）<br>这里就不讲字典树了<br>序列自动机：<br>序列自动机就是用一个数组next[i][j]来记录数组a第i位的字符j在i后第一次出现的坐标。<br>设串长为n,字符集大小为a，预处理时间复杂度为O(n*a)<br><a href="https://jozky.gitee.io/2020/04/02/序列自动机/" target="_blank" rel="noopener" title="序列自动机详细讲解">https://jozky.gitee.io/2020/04/02/序列自动机/</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=n;i;i--)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(int j=1;j&lt;=a;j++) next[i-1][j]=next[i][j];</span><br><span class="line">	next[i-1][s[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt; </span></span><br><span class="line"><span class="comment">#define forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">#define fore(n) for(int j=1;j&lt;=n;j++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int ma=1000004;</span><br><span class="line">char a[ma];</span><br><span class="line">int len;</span><br><span class="line">int w=0;</span><br><span class="line">int m;	</span><br><span class="line">bool f=1;</span><br><span class="line">int next[ma][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;(a+1);</span><br><span class="line">	int len=strlen(a+1);</span><br><span class="line">	<span class="keyword">for</span>(int i=len;i&gt;=1;i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(int j=0;j&lt;=25;j++) next[i-1][j]=next[i][j];</span><br><span class="line">		next[i-1][a[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;m;</span><br><span class="line">	char ch=getchar();</span><br><span class="line">	forr(m)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;(a+1);</span><br><span class="line">		len=strlen(a+1);</span><br><span class="line">		 w=0;</span><br><span class="line">		f=1;</span><br><span class="line">		fore(len)</span><br><span class="line">		&#123;</span><br><span class="line">			w=next[w][a[j]-<span class="string">'a'</span>];</span><br><span class="line">			<span class="keyword">if</span>(w==0)</span><br><span class="line">			&#123;</span><br><span class="line">				f=0;</span><br><span class="line">				cout&lt;&lt;<span class="string">"N0"</span>&lt;&lt;endl;</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(f!=0)cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>序列自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】7月8日 Alliances</title>
    <url>/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%888%E6%97%A5-Alliances/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13950" target="_blank" rel="noopener">来源：牛客网</a><br>@[toc]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">5</span>秒，其他语言<span class="number">10</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">262144</span>K，其他语言<span class="number">524288</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote>
<p>树国是一个有n个城市的国家，城市编号为1∼n。连接这些城市的道路网络形如一棵树，<br>即任意两个城市之间有恰好一条路径。</p>
</blockquote>
<a id="more"></a>
<blockquote>
<p>城市中有k个帮派，编号为1∼k。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。<br>当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。<br>shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p>
</blockquote>
<p><strong>输入描述:</strong></p>
<blockquote>
<p>输入的第一行包含一个整数n，代表树国中的城市数。  接下来n−1行，每行包含两个整数u和v，代表城市u和v之间存在一条道路。<br>接下来一行包含一个整数k，代表树国中的帮派数。<br>接下来k行，每行描述一个帮派。第i行的第一个整数c[i]代表第i个帮派占据的城市数，接下来c[i]个整数，代表被第i个帮派占据的城市。<br>接下来一行包含一个整数Q，代表询问数。<br>接下来Q行，每行描述一个询问。每行的前两个整数V和t[i]代表本次询问中的首都与需要考虑的帮派集合的大小。接下来t[i]个整数代表本次询问中需要考虑的帮派。.</p>
</blockquote>
<p><strong>输出描述:</strong></p>
<blockquote>
<p>对于每个询问，输出一行，包含一个整数，代表询问的答案。</p>
</blockquote>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>备注:</p>
<blockquote>
<p>对于30%的数据，1≤n,k,Q≤1000, 1≤每个帮派占据城市数之和≤1000, 1≤每个询问中考虑的帮派数之和≤1000  </p>
</blockquote>
<blockquote>
<p>对于60%的数据，1≤n,k,Q≤100000, 1≤每个帮派占据城市数之和≤100000, 1≤每个询问中考虑的帮派数之和≤100000</p>
</blockquote>
<blockquote>
<p>对于100%的数据，1≤n,k,Q≤500000, 1≤每个帮派占据城市数之和≤500000, 1≤每个询问中考虑的帮派数之和≤500000</p>
</blockquote>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>第一反应lca，<del>最近好多lca的题</del><br>题目本质就是求一个点（即题目中的首都）到lca（x,y）上的点（即被控制的城市）的最短路径<br>被控制的城市其实就形成了一个子树<br>分情况讨论：<br>1.城市不在被控制的子树里面（如图）<br>紫色是城市，橙色是被控制子树，那距离就是首都到子树的距离<br>sum=dep[首都]+dep[lca(城市x)]-dep[lca(城市x，首都)]<br>城市x就是lca（x,y）的值(x和y就是题目所给的帮派)<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302157028_20200709165342620.png" alt="在这里插入图片描述"><br>2.首都被控制<br>首都被控制分为直接控制（帮派点为首都）<br>或间接控制（首都在帮派之间的线路上）<br>那距离就是0</p>
<p><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302154981_20200709165347695.png" alt="在这里插入图片描述"><br>3.首都没被控制，但是首都在被控制的子树中<br>（首都的前驱被控制，后继没被控制）<br>对于这种情况我们就要找首都的的前驱后继点，这样好判断距离<br>可以用dfs序，因为dfs序就保存着各个点的顺序<br>然后可以用二分来降低复杂度<br>如果首都到LCA的路径上存在一个点x（x被占领），x！=lca，那么答案就是首都到最近一个符合这个条件的点<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302157049_20200709165408484.png" alt="在这里插入图片描述"><br><a href="https://blog.csdn.net/qq_35975367/article/details/105461878" target="_blank" rel="noopener">lca详细讲解</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/105369244" target="_blank" rel="noopener">dfs序详细讲解</a><br>为什么这些知识点我都会，但是我就不会做题。。哭o(╥﹏╥)o</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>写完再加上。。。（最近有点懒）</p>
<hr>
<p>好吧我放弃了，写完一直改，一直wa，难受自闭了<br><a href="https://blog.nowcoder.net/n/fe24264bae7d4673a3eb143cd3039c2d" target="_blank" rel="noopener">借鉴的大佬的代码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e6</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEG=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="comment">//链式前向星村边</span></span><br><span class="line"><span class="keyword">int</span> head[MAX_N],tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;edge[MAX_N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].nxt=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//求LCA</span></span><br><span class="line"><span class="keyword">int</span> fa[MAX_N][DEG];</span><br><span class="line"><span class="keyword">int</span> deg[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    deg[root]=<span class="number">0</span>;</span><br><span class="line">    fa[root][<span class="number">0</span>]=root;</span><br><span class="line">    que.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;DEG;i++)&#123;</span><br><span class="line">            fa[tmp][i]=fa[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[tmp];i!=<span class="number">-1</span>;i=edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[tmp][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">            deg[v]=deg[tmp]+<span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>]=tmp;</span><br><span class="line">            que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deg[u]&gt;deg[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> hu=deg[u],hv=deg[v];</span><br><span class="line">    <span class="keyword">int</span> tu=u,tv=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> det=hv-hu,i=<span class="number">0</span>;det;det&gt;&gt;=<span class="number">1</span>,i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(det&amp;<span class="number">1</span>)tv=fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tu==tv)<span class="keyword">return</span> tu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=DEG<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[tu][i]==fa[tv][i])<span class="keyword">continue</span>;</span><br><span class="line">        tu=fa[tu][i];</span><br><span class="line">        tv=fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[tu][<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求DFS序</span></span><br><span class="line"><span class="keyword">int</span> dfsn[MAX_N];</span><br><span class="line"><span class="keyword">int</span> pos[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dfst=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dfsn[v]=++dfst;</span><br><span class="line">    pos[dfst]=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i!=<span class="number">-1</span>;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(u==fa)<span class="keyword">continue</span>;</span><br><span class="line">        DFS(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=deg[u]+deg[v]<span class="number">-2</span>*deg[LCA(u,v)];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lc存每一个帮派的LCA</span></span><br><span class="line"><span class="comment">//g存每一个帮派的DFS序</span></span><br><span class="line"><span class="keyword">int</span> lc[MAX_N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAX_N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        addedge(u,v);</span><br><span class="line">        addedge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(<span class="number">1</span>);</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)lc[i]=x;</span><br><span class="line">            <span class="keyword">else</span> lc[i]=LCA(lc[i],x);</span><br><span class="line">            g[i].push_back(dfsn[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g[i].begin(),g[i].end());</span><br><span class="line">        <span class="comment">//cout&lt;&lt;lc[i]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"****"&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span> q,u,cnt;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lca=lc[t[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)lca=LCA(lca,lc[t[i]]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(LCA(lca,u)!=lca)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis(lca,u));</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=t[i];</span><br><span class="line">            <span class="keyword">auto</span> p=lower_bound(g[tmp].begin(),g[tmp].end(),dfsn[u]);</span><br><span class="line">            <span class="keyword">if</span>(p!=g[tmp].end())&#123;</span><br><span class="line">                ans=min(ans,dis(u,LCA(u,pos[*p])));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p!=g[tmp].begin())&#123;</span><br><span class="line">                ans=min(ans,dis(u,LCA(u,pos[*prev(p)])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>牛客网每日一题</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>dfs序</tag>
        <tag>lca</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】Shortest Path 4月3日题目精讲 DFS </title>
    <url>/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/</url>
    <content><![CDATA[<p>题号 NC13886<br><a href="https://ac.nowcoder.com/acm/problem/13886" target="_blank" rel="noopener">Shortest Path</a><br><a href="https://ac.nowcoder.com/acm/contest/10#description" target="_blank" rel="noopener">西南交通大学第十三届ACM决赛</a><br>题意：<br>一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？<br><strong>题解：</strong><br>如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式</p>
<a id="more"></a>
<p><img src="https://uploadfiles.nowcoder.com/files/20200404/543071257_1585932178570_20200404003717820.png" alt="在这里插入图片描述"><br>改变后路径更小，也就是说两两一组的点都不会覆盖其他点<br>那么每个点与其他点配对就有两者选择，一个与兄弟节点配对（中间跨过父亲点），另一个就是与父亲节点相连，这样选择肯定是最优的<br>如果这个节点所在的自树里有偶数个节点，那么他们内部配对就可以了（好像有什么怪怪的）<br>如果有奇数个节点，还有把父亲节点拉进来一起配对（这样才能组成偶数个）<br>来上代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx=1e4+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int head[maxx];</span><br><span class="line">int cnt=0;</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">	ll w,v,u,next;</span><br><span class="line">&#125;edge[maxx*2];</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">	edge[++cnt].u=u;</span><br><span class="line">	edge[cnt].v=v;</span><br><span class="line">	edge[cnt].w=w;</span><br><span class="line">	edge[cnt].next=head[u];</span><br><span class="line">	head[u]=cnt;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll u,ll f,ll w)</span><br><span class="line">&#123;</span><br><span class="line">	ll sum=1;</span><br><span class="line">	<span class="keyword">for</span>(int i=head[u];i;i=edge[i].next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(edge[i].v!=f)sum+=dfs(edge[i].v,u,edge[i].w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(sum%2)ans+=w;</span><br><span class="line">	<span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int T;</span><br><span class="line">	int n;</span><br><span class="line">	scanf(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">	<span class="keyword">for</span>(int i=1;i&lt;=T;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin&gt;&gt;n;</span><br><span class="line">		memset(head,0,sizeof(head));</span><br><span class="line">		cnt=0;</span><br><span class="line">		ans=0;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(int i=1;i&lt;n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			scanf(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">			addt(x,y,z);</span><br><span class="line">			addt(y,x,z); </span><br><span class="line">		&#125;</span><br><span class="line">		dfs(1,0,0);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">//树上dfs</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>树上dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】合集</title>
    <url>/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C"><a href="#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C" class="headerlink" title="2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C"></a>2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/">题解</a></p>
<h2 id="2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮"><a href="#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮"></a>2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">题解</a></p>
<a id="more"></a>
<h2 id="2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛"><a href="#2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛" class="headerlink" title="2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛"></a>2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/">题解</a></p>
<h2 id="2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5"><a href="#2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5" class="headerlink" title="2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5"></a>2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5</h2><p><a href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">题解</a></p>
<h2 id="2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛"><a href="#2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛" class="headerlink" title="2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛"></a>2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛</h2><p><a href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/">题解</a></p>
<h2 id="2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11"><a href="#2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11" class="headerlink" title="2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11"></a>2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/">题解</a></p>
<h2 id="2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12"><a href="#2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12" class="headerlink" title="2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12"></a>2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12</h2><p><a href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/">题解</a></p>
<h2 id="2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛"><a href="#2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛" class="headerlink" title="2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛"></a>2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛</h2><p><a href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/">题解</a></p>
<h2 id="2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛"><a href="#2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛" class="headerlink" title="2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛"></a>2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/">题解</a></p>
<h2 id="2020年4月7日-NC13611-树-牛客练习赛1"><a href="#2020年4月7日-NC13611-树-牛客练习赛1" class="headerlink" title="2020年4月7日 NC13611 树 牛客练习赛1"></a>2020年4月7日 NC13611 树 牛客练习赛1</h2><p><a href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/">题解</a></p>
<h2 id="2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮"><a href="#2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮" class="headerlink" title="2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮"></a>2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮</h2><p><a href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/">题解</a></p>
<h2 id="2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05"><a href="#2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05" class="headerlink" title="2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05"></a>2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05</h2><p><a href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/">题解</a></p>
<h2 id="2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮"><a href="#2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮"></a>2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/16/牛客网-【每日一题】4月10日-二分图染色-弱化版/">题解</a></p>
<h2 id="2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54"><a href="#2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54" class="headerlink" title="2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54"></a>2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54</h2><p><a href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/">题解</a></p>
<h2 id="2020年4月14日-NC14247-Xorto-Wannafly挑战赛1"><a href="#2020年4月14日-NC14247-Xorto-Wannafly挑战赛1" class="headerlink" title="2020年4月14日 NC14247 Xorto Wannafly挑战赛1"></a>2020年4月14日 NC14247 Xorto Wannafly挑战赛1</h2><h2 id="2020年4月15日-NC14248-Treepath-Wannafly挑战赛1"><a href="#2020年4月15日-NC14248-Treepath-Wannafly挑战赛1" class="headerlink" title="2020年4月15日 NC14248 Treepath Wannafly挑战赛1"></a>2020年4月15日 NC14248 Treepath Wannafly挑战赛1</h2><h2 id="2020年4月16日-NC14731-逆序对-Wannafly挑战赛6"><a href="#2020年4月16日-NC14731-逆序对-Wannafly挑战赛6" class="headerlink" title="2020年4月16日 NC14731 逆序对 Wannafly挑战赛6"></a>2020年4月16日 NC14731 逆序对 Wannafly挑战赛6</h2><h2 id="未完再续。。。"><a href="#未完再续。。。" class="headerlink" title="未完再续。。。"></a>未完再续。。。</h2>]]></content>
      <categories>
        <category>比赛</category>
      </categories>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月9日题目精讲 Running Median</title>
    <url>/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/</url>
    <content><![CDATA[<p>@[TOC]</p>
<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://ac.nowcoder.com/acm/problem/50940" target="_blank" rel="noopener">–&gt;链接&lt;—</a></p>
<blockquote>
<p>时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit<br> IO Format:%lld</p>
</blockquote>
<p>题目描述 </p>
<blockquote>
<p>For this problem, you will write a program that reads in a sequence of<br>32-bit signed integers. After each odd-indexed value is read, output<br>the median (middle value) of the elements received so far.</p>
</blockquote>
<a id="more"></a>
<p>输入描述:</p>
<blockquote>
<p>The first line of input contains a single integerP(1≤P≤1000), which is the number of data sets that follow. The<br>first line of each data set contains the data set number, followed by<br>a space, followed by an odd decimal integer (1≤M≤9999), giving the total number of signed integers to be<br>processed. The remaining line(s) in the dataset consists of the<br>values, 10 per line, separated by a single space. The last line in the<br>dataset may contain less than 10 values.</p>
</blockquote>
<p>输出描述:</p>
<blockquote>
<p>For each data set the first line of output contains the data set<br>number, a single space and the number of medians output (which should<br>be one-half the number of input values plus one). The output medians<br>will be on the following lines, 10 per line separated by a single<br>space. The last line may have less than 10 elements, but at least 1<br>element. There should be no blank lines in the output.</p>
</blockquote>
<p>示例1<br>输入<br>3<br>1 9<br>1 2 3 4 5 6 7 8 9<br>2 9<br>9 8 7 6 5 4 3 2 1<br>3 23<br>23 41 13 22 -3 24 -31 -11 -8 -7<br>3 5 103 211 -311 -45 -67 -73 -81 -99<br>-33 24 56<br>输出<br>1 5<br>1 2 3 4 5<br>2 5<br>9 8 7 6 5<br>3 12<br>23 23 22 22 13 3 5 5 3 -3<br>-7 -3</p>
<h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你m个数，一次输入，每当输入的个数为奇数时，输出按大小排列最中间的数<br>比如1 5 6 7 8<br>一开始输入1，输出1<br>然后输入1 5，不输出<br>输入1 5 6，输出5<br>输入1 5 6 7，不输出<br>输入1 5 6 7 8，输出6</p>
<h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>可以用堆来做<br>w1为大堆，w1用于存放小值<br>w2为小堆，w2存放大值<br>比如上面那个例子1 5 6 7 8<br>奇数位存在w1，偶数存在w2<br>如果w1.top()&gt;w2.top(),就是w1的最大比w2的最小值大，就将这两个值互换，始终保证，w1的值比w2的任意一个都小，这样无论数据怎么读入，w1的最大值始终都是最中间的数<br>看下面模拟：<br>第一轮：<br>w1:1<br>w2：0<br>二：<br>w1:1<br>w2:5<br>三：<br>w1:1 6<br>w2:5<br>6&gt;5<br>w1:1 5<br>w2:6<br>四<br>w1:1 5<br>w2: 7 6<br>五<br>w1:1 5 8<br>w2: 7 6<br>8&gt;6<br>w1:1 5 6<br>w2; 7 8<br>这样每奇数轮，w1的top位就是答案</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;w1;<span class="comment">//默认为大堆，从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;w2;<span class="comment">//默认为小堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">  <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p,m,x;</span><br><span class="line">    <span class="keyword">int</span> minn,maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;m;</span><br><span class="line">        case1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p,m/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)w1.push(x);</span><br><span class="line">            <span class="keyword">else</span> w2.push(x);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                minn=w1.top();</span><br><span class="line">                maxx=w2.top();</span><br><span class="line">                <span class="keyword">if</span>(minn&gt;maxx)</span><br><span class="line">                &#123;</span><br><span class="line">                    w1.pop();</span><br><span class="line">                    w2.pop();</span><br><span class="line">                    w1.push(maxx);</span><br><span class="line">                    w2.push(minn);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(case1!=<span class="number">0</span>&amp;&amp;case1%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                case1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==m)<span class="built_in">cout</span>&lt;&lt;w1.top();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,w1.top());</span><br><span class="line">                case1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(!w1.empty())w1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!w2.empty())w2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（这个题的格式我一开始一直没注意。。。）</p>
<h2 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h2><p>我看很多人都是这么做的，但是只能过50%的数据。。包括我自己<br>我看了清楚姐姐的代码稍微改一下：<br>我们在读入一个数后，直接与w1.top比较，小于就存进去，大了就存w2里<br>当w1的数量多了，就把堆顶拿出给w2（小根堆）<br>w2多了就给大根堆<br>这样维护出来其实和上面的方法差不多<br>因为总数是奇数，两个堆数量一定不一样，多的那方，堆顶就是答案<br>代码：<br>清楚阿姨（<del>狗头</del> ）代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//小根堆 ，存较大的一半的数</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">//大根堆 ，存较小的一半的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty()) q2.pop();  <span class="comment">//优先队列没有clear函数，要一个一个弹出</span></span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m ,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m, (n+<span class="number">1</span>)/ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &lt;= q1.top()) q1.push(x); <span class="comment">//如果当前值比大根堆堆顶小，说明在小的这二分之一，塞进大根堆</span></span><br><span class="line">            <span class="keyword">else</span>  q2.push(x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> num1= q1.size();</span><br><span class="line">            <span class="keyword">int</span> num2= q2.size();</span><br><span class="line">            <span class="keyword">if</span> (num1 - num2 &gt; <span class="number">1</span>)   <span class="comment">//大根堆里面元素多了，把堆顶拿出来塞近小根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.top());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(num2 - num1 &gt;<span class="number">1</span>) <span class="comment">//小根堆里面元素多了，把堆顶拿出来塞近大根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.top());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//目前的元素个数是奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                num1 = q1.size();</span><br><span class="line">                num2 = q2.size();</span><br><span class="line">                <span class="keyword">if</span>(num1 &gt; num2) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q1.top()); <span class="comment">//中位数在大根堆</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, q2.top());           <span class="comment">//中位数在小根堆</span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">19</span> &amp;&amp; i!=n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>身体训练 </title>
    <url>/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/B" target="_blank" rel="noopener">牛客网</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v<br>米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v</p>
<a id="more"></a> 
<p>米/秒。每个人最初的最高速度为c[i] 米/秒，每轮衰减d[i]<br>米/秒，也就是说，如果i是第j个跑的，那么他的速度就是c[i]-(j-1)*d[i] 米/秒。<br>n个人初始以随机的顺序排列，每种顺序的概率完全相等，跑完一轮（每个人都追到排头一次，序列恢复原样）的期望需要的时间是多少？</p>
</blockquote>
<p>输入描述:</p>
<blockquote>
<p>第一行整数n（&lt;=1000）, 实数v(&lt;=100) , 实数u(&lt;=10) 第二行n个实数每个人的速度c<a href="<=50000">i</a><br>第三行n个实数值每个人衰减量d<a href="<=10">i</a></p>
<p>输入数据保证每个人的速度不会衰减到&lt;=v</p>
</blockquote>
<p>输出描述:</p>
<p>答案保留3位小数。</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">37.618</span> <span class="number">0.422</span></span><br><span class="line"></span><br><span class="line"><span class="number">72.865</span> <span class="number">126.767</span> <span class="number">202.680</span> <span class="number">106.102</span> <span class="number">99.516</span> <span class="number">134.418</span> <span class="number">167.952</span> <span class="number">173.646</span> <span class="number">120.210</span> <span class="number">136.571</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.941</span> <span class="number">3.664</span> <span class="number">7.363</span> <span class="number">4.161</span> <span class="number">0.246</span> <span class="number">8.046</span> <span class="number">5.521</span> <span class="number">7.473</span> <span class="number">7.178</span> <span class="number">5.649</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0.815</span></span><br></pre></td></tr></table></figure>
<p>题解：<br>因为除了最后一个人，其他人速率相同，那么就可以把大家都看做静止的，最后一个人的速度就是V（原本）-V（其他人的速度），可以理解成相对速度<br>题目问跑完一轮，说明每个人在每个位置都会经历一遍。虽然每个快递员位置未定，在每个位置上概率都是1/n,但是无论是什么位置，快递员要跑的相对路长是一定的，都是u<em>n。<br>（相对路长就是在相对时间内跑的距离，大家都是静止的，一共n个人，最后一名前面有n-1个人，他要从最后跑到比排头还远u，跨过了n个间隙，距离是u</em>n）<br>如果i是第j个跑的，那么他的速度就是c[i]-(j-1)<em>d[i] 米/秒。v是其他人的速度<br>相对速度就是c[i]-(j-1)</em>d[i]-v<br>距离有了速度有了，相除就可以求时间<br>可以求出每个快递员跑过每个位置所需要的的时间，累加起来就可以<br>啥是期望？数学期望(mean)是试验中每次可能结果的概率乘以其结果的总和<br>所以最后再乘以概率 1/n</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> c[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> v,u,sum=<span class="number">0</span>; </span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v&gt;&gt;u;</span><br><span class="line">	forr(n)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">	forr(n)<span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		&#123;</span><br><span class="line">			sum+=u/( c[i] - v - ( j<span class="number">-1</span> ) * d[i] );</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.3f"</span>,sum);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网【每日一题】4月8日题目精讲 黑白树</title>
    <url>/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13249" target="_blank" rel="noopener">试题链接</a></p>
<blockquote>
<p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld</p>
</blockquote>
<p>题目描述</p>
<blockquote>
<p>一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。<br>你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。</p>
</blockquote>
<a id="more"></a>

<p>输入描述:</p>
<blockquote>
<p>第一行一个整数n (1 ≤ n ≤ 10^5^) 接下来n-1行，每行一个整数，依次为2号点到n号点父亲的编号。 最后一行n个整数为k[i]<br>(1 ≤ k[i] ≤ 10^5^)</p>
<p>样例解释:<br> 对节点3操作，导致节点2与节点3变黑 对节点4操作，导致节点4变黑 对节点1操作，导致节点1变黑</p>
</blockquote>
<p>输出描述:</p>
<p>一个数表示最少操作次数</p>
<p>示例1<br>输入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>题解：<br>一开始以为是红黑树的姐妹黑白树。。<br>求出最少的操作，用dfs</p>
<p>我们要不断更新染色的最远距离，还要把子节点的染色范围更新的父亲节点<br>比如1-&gt;2-&gt;3-.&gt;4-&gt;5-&gt;6-&gt;7<br>f[2]=5,f[3]=2<br>2节点就可以直接染色到6<br>操作完2之后，如果3就已经被染色了，如果3能染色的范围比fa[ 2 ]-1（因为2已经染色了本身，所以减一）还大，那染色范围可以更远<br>如果fa[3]&lt;fa[2]-1，就把f3的最远距离更新到fa[2]-1<br>总结就是fa[fa]=max（ fa [ fa ] , fa [ son ] - 1 ）<br>fa=0说明这个点无法被处理到<br>因为染色都是从下向上的。如果一个节点没办法被它子树的节点染色，那这个节点的父亲节点也没办法将它染色，他只能自己染色了</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100004</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;w[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w[x].size();j++)</span><br><span class="line">	&#123;</span><br><span class="line">		dfs(w[x][j]);</span><br><span class="line">		fa[x]=max( fa[ w[x][j] ]<span class="number">-1</span> , fa[x] );</span><br><span class="line">		a[x]=max( a[ w[x][j] ]<span class="number">-1</span> , a[x] );</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(fa[x]==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		sum++;</span><br><span class="line">		fa[x]=a[x];</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n,m;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">	forr(n<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">		w[m].push_back(i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	forr(n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网每日一题</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次cf之旅</title>
    <url>/2020/04/22/%E7%AC%AC%E4%B8%80%E6%AC%A1cf%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>之前一直想打cf，但都感觉自己太弱了，而且没有科学上网的途径。。。<br>后来知道今天有Codeforces Round #636 (Div. 3)，说不是很难，决定参加试试<br>网太卡（无奈），实在是不稳定，没办法<br>感觉前三个题目还是挺简单的，思维题，多活动大脑就能想明白。后三就还没看。。网卡，过夜，明天一早有课，最终选择放弃(笑哭）<br>还有不知道dev怎么了突然抽筋了，关键时候上不了场，还是codeblock救的场</p>
<a id="more"></a>
<p><img src="https://img-blog.csdnimg.cn/20200421235933360.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200422000347503.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200422000415259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>逆元的求法</title>
    <url>/2020/07/04/%E9%80%86%E5%85%83%E7%9A%84%E6%B1%82%E6%B3%95/</url>
    <content><![CDATA[<p>逆元：<br>对于a和p，若 a * inv(a) % p ≡ 1，则称inv(a)为a%p的逆元。其中p为质数<br>逆元就是在mod下，不能直接除以一个数，而要乘以他的逆元<br>a * inv(a) = 1 (mod p)<br>x / a可以改成 x * inv(a) % p</p>
<a id="more"></a> 
<p>@[toc]</p>
<h2 id="方法一-扩展欧几里得"><a href="#方法一-扩展欧几里得" class="headerlink" title="方法一.扩展欧几里得"></a>方法一.扩展欧几里得</h2><p>a * inv(a) = 1 (mod p)<br>可以变形成 a * inv(a) +k * p = 1(前提是a和p要互素)<br>可以用扩欧的公式来计算<br>时间复杂度:O(logn)<br>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">		y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	ll gcd=exgcd(a,mod,x,y);</span><br><span class="line">	<span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法二-费马小定理-欧拉定理"><a href="#方法二-费马小定理-欧拉定理" class="headerlink" title="方法二.费马小定理+欧拉定理"></a>方法二.费马小定理+欧拉定理</h2><p>费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)^ ≡ 1（mod p），进一步可以推出a^p-2^ * a ≡ 1 (mod p)<br>a^p-2^就是a在mod p意义下的逆元<br>欧拉函数：a^φ(n)^≡1 (mod n) ，其中 gcd(a,n)=1<br>若n为素数，φ(n)=n-1<br>时间复杂度 O(log mod)<br>适用范围：在mod是素数的时候使用，比扩欧快</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	ll base=a;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*base%mod;</span><br><span class="line">		base=base*base%mod;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> poww(a,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法三-递推求逆元"><a href="#方法三-递推求逆元" class="headerlink" title="方法三:递推求逆元"></a>方法三:递推求逆元</h2><p>时间复杂度为O（n）<br>使用条件：mod为不是很大的素数，且需要多次调用</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		inv[i]=((p-p/i)*inv[p%i]%p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>相反数</title>
    <url>/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="https://ac.nowcoder.com/acm/contest/5203/A" target="_blank" rel="noopener">传送</a></p>
<h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一个数加上他的相反数</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况</p>
<a id="more"></a> 
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">  	<span class="keyword">if</span>(s[i]==<span class="string">'0'</span>&amp;&amp;f==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">  	f=<span class="number">1</span>;</span><br><span class="line">	sum2=sum2*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum+sum2;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
</search>
