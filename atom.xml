<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-04-05T11:56:01.376Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客每日一题3.31 城市网络</title>
    <link href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    <id>http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</id>
    <published>2020-04-05T11:42:46.000Z</published>
    <updated>2020-04-05T11:56:01.376Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13331" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><blockquote><p>题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。<br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。</p></blockquote><a id="more"></a><blockquote><p>在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v<br>），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p></blockquote><p>输入描述:</p><blockquote><p>第一行，两个正整数 n , q (2 ≤ n ≤ 10^5^ , 1 ≤ q ≤ 10^5^)。 第二行，n 个正整数 a_i (1 ≤<br>a_i ≤ 10^5) 描述每个城市售卖的珠宝的价值。 接下来 n-1 行，每行描述一条道路 x , y (1 ≤ x,y ≤<br>n)，表示有一条连接 x 和 y 的道路。 接下来 q 行，每行描述一次行程 u , v , c (1 ≤ u,v ≤ n , 1 ≤ c<br>≤ 10^5^)。</p></blockquote><p>输出描述:</p><blockquote><p>对于每次行程输出一行，为所购买次数。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3 5 1 2 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 2 1</span><br><span class="line">4 2 2</span><br><span class="line">4 2 3</span><br><span class="line">5 1 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>题解:<br>毋庸置疑就是用倍增来做<br>那什么是倍增呢？<br>（先挖个坑，有空做个倍增的讲解）<br>递推式fa[i][j] = fa[fa[i][j-1]][j - 1],只要倍增得到fa[i][0]就行，因为有了这个后面都可以推出<br>fa[i][j] 代表i节点往上走2^j的距离，且比当前大的点<br>每次查询时，在所有需要问的点加一条新点，连在u的下方，新点的权值就是询问的初始权值，从这个新点往上倍增就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">const int maxn=2e5+2;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int fa[maxn][23];</span><br><span class="line">int n,q;</span><br><span class="line">int to[maxn];</span><br><span class="line">vector&lt;int&gt; W[2*maxn];</span><br><span class="line">void dfs(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">int pos=f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=21;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[pos][i]&amp;&amp;a[fa[pos][i]]&lt;=a[u])</span><br><span class="line">pos=fa[pos][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[pos]&gt;a[u])fa[u][0]=f;</span><br><span class="line"><span class="keyword">else</span> fa[u][0]=fa[pos][0];</span><br><span class="line"><span class="keyword">for</span>(int i=1;fa[fa[u][i-1]][i-1];i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i-1]][i-1];</span><br><span class="line">&#125;</span><br><span class="line">dis[u]=dis[f]+1;</span><br><span class="line"><span class="keyword">for</span>(int v=0;v&lt;W[u].size();v++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(W[u][v]==f)<span class="built_in">continue</span>;</span><br><span class="line">dfs(W[u][v],u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int a;</span><br><span class="line">  int b;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        W[a].push_back(b);</span><br><span class="line">        W[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i =1; i &lt;= q ; ++i)&#123;//增加新点</span><br><span class="line">        int aa,b,c;</span><br><span class="line">        scanf(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;b,&amp;c);</span><br><span class="line">        W[n+i].push_back(aa);</span><br><span class="line">        W[aa].push_back(i+n);</span><br><span class="line">        a[n+i] = c;</span><br><span class="line">        to[n+i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">   int sum = 0; </span><br><span class="line">   int pos;</span><br><span class="line">    <span class="keyword">for</span>(int i = n+1; i &lt;= n+q; ++i)&#123;</span><br><span class="line">       pos=i;</span><br><span class="line">      sum=0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 21; j &gt;= 0; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[fa[pos][j]] &gt;= dis[to[i]]) &#123;</span><br><span class="line">                sum += (1 &lt;&lt; j);</span><br><span class="line">pos= fa[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13331&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。&lt;br&gt;你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="倍增" scheme="http://Jozky.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>清明追思家国永念</title>
    <link href="http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/"/>
    <id>http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/</id>
    <published>2020-04-04T14:59:20.000Z</published>
    <updated>2020-04-04T15:08:57.094Z</updated>
    
    <content type="html"><![CDATA[<p>我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行<img src="https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>本来想睡觉，企鹅群不小心看见一些发言气醒了。</p><p>4月4日默哀是形式主义?</p><p>你知道什么是形式主义吗?这种公共活动都是形式主义?死去的同胞、牺牲的医护都配不上，那谁还配得上这样的国礼?这算哪门子形式?</p><p>你可以说，我觉得宣传口的工作不够到位;你也可以说，我觉得现在才发布通知过于仓促;你还可以说，禁止的范围有待商榷。</p><p>无动于衷不是罪过，没有感同身受不是罪过，做不到泪流满面不是罪过，私下继续娱乐活动也不是罪过。你可以不爱听歌功颂德的文本，可以用自己的方式怀缅，可以用其他途径玩得.昏天黑地。</p><p>娱乐至死的时代，只有无聊才让人如临大敌，都懂。</p><p>做了不代表尊重，没做也不代表不尊重。</p><p>没有卫兵站在你家里用枪抵着你的后脑勺让你哭天抢地，没有条子叔叔把看电视打游戏听音乐的人逮起来，也没有人让你排着长队对着什么东西跪地哀嚎。事实上，没有人强迫你。只是有一点，自身的态度和对外界的要求要-致。若是不以流程怀念，就不要对着默哀的人喊你们是一群被形式主义迫害的粉红，缄默到底。若是以流程怀缅，也不必逼迫他人做超出公报内容的事，真挚只能自发。</p><p>你可以不立正，可以不起床。但是在鸣笛的那几分钟里，你必须清楚，你还活着，没有失去年长的亲人、远方的朋友是因为谁。你也得清楚，这样的祭奠，那些人配得上。<br>———转载<br><img src="https://img-blog.csdnimg.cn/20200404230406288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200404230410721.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行&lt;img src=&quot;https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】Shortest Path 4月3日题目精讲 DFS </title>
    <link href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/"/>
    <id>http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/</id>
    <published>2020-04-04T14:53:04.000Z</published>
    <updated>2020-04-04T14:55:17.159Z</updated>
    
    <content type="html"><![CDATA[<p>题号 NC13886<br><a href="https://ac.nowcoder.com/acm/problem/13886" target="_blank" rel="noopener">Shortest Path</a><br><a href="https://ac.nowcoder.com/acm/contest/10#description" target="_blank" rel="noopener">西南交通大学第十三届ACM决赛</a><br>题意：<br>一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？<br><strong>题解：</strong><br>如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式</p><a id="more"></a><p><img src="https://uploadfiles.nowcoder.com/files/20200404/543071257_1585932178570_20200404003717820.png" alt="在这里插入图片描述"><br>改变后路径更小，也就是说两两一组的点都不会覆盖其他点<br>那么每个点与其他点配对就有两者选择，一个与兄弟节点配对（中间跨过父亲点），另一个就是与父亲节点相连，这样选择肯定是最优的<br>如果这个节点所在的自树里有偶数个节点，那么他们内部配对就可以了（好像有什么怪怪的）<br>如果有奇数个节点，还有把父亲节点拉进来一起配对（这样才能组成偶数个）<br>来上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx=1e4+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int head[maxx];</span><br><span class="line">int cnt=0;</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">ll w,v,u,next;</span><br><span class="line">&#125;edge[maxx*2];</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">edge[++cnt].u=u;</span><br><span class="line">edge[cnt].v=v;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll u,ll f,ll w)</span><br><span class="line">&#123;</span><br><span class="line">ll sum=1;</span><br><span class="line"><span class="keyword">for</span>(int i=head[u];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v!=f)sum+=dfs(edge[i].v,u,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum%2)ans+=w;</span><br><span class="line"><span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">int n;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=T;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(head,0,sizeof(head));</span><br><span class="line">cnt=0;</span><br><span class="line">ans=0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addt(x,y,z);</span><br><span class="line">addt(y,x,z); </span><br><span class="line">&#125;</span><br><span class="line">dfs(1,0,0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">//树上dfs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题号 NC13886&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shortest Path&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10#description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西南交通大学第十三届ACM决赛&lt;/a&gt;&lt;br&gt;题意：&lt;br&gt;一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？&lt;br&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br&gt;如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
  </entry>
  
  <entry>
    <title>About Me</title>
    <link href="http://jozky.top/2020/04/04/About-Me/"/>
    <id>http://jozky.top/2020/04/04/About-Me/</id>
    <published>2020-04-04T08:51:12.000Z</published>
    <updated>2020-04-04T14:16:41.355Z</updated>
    
    <content type="html"><![CDATA[<ul><li>A acmer, live in liaocheng,China</li><li>70%山东+20%四川+10%深圳=Me<br>姓名：Jozky<br>现居：聊城<br>大学：QDU<br>QQ:2830872914<br><img src="https://img-blog.csdnimg.cn/20200404170050150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;A acmer, live in liaocheng,China&lt;/li&gt;
&lt;li&gt;70%山东+20%四川+10%深圳=Me&lt;br&gt;姓名：Jozky&lt;br&gt;现居：聊城&lt;br&gt;大学：QDU&lt;br&gt;QQ:2830872914&lt;br&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="介绍" scheme="http://Jozky.top/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛60--斩杀线计算大师</title>
    <link href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/"/>
    <id>http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/</id>
    <published>2020-04-02T12:57:47.000Z</published>
    <updated>2020-04-04T15:08:57.805Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4853/D" target="_blank" rel="noopener">题目传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,<br>64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。<br>数据保证一定存在解。如果存在多组解，输出任意一组。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>一行四个整数分别表示a,b,c,k</p></blockquote><p>输出描述:</p><blockquote><p>一行输出三个整数分别表示x,y,z</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 20</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure><p>备注:<br>1 ≤ a , b , c ≤ 1e5<br>0 ≤ k ≤ 1e12</p><ul><li>题意：</li></ul><p>就是多少个a+多少个b+多少个c=k<br>问你这个“多少个”分别是什么</p><p> <strong>题解</strong></p><ol><li>方法一</li></ol><p>把题目改成公式形式就是<br>ax+by+cz=k<br>没错，其实就是exgcd，只不过exgcd是ax+by=k<br>你把咱们这个式子再变变形<br>就能得到：<br>a x + b y = k - c * z<br>而这个z我们可以枚举<br>那就是a x + b y = k - c * i<br>题目说了肯定有解，那放心枚举i就完事了<br>把后面这部分-c<em>i当做整体M<br>ax+by=M<br>然后就是exgcd的步骤<br>用exgcd求出x0,y0<br>a</em>x0+b<em>y0=GCD(a,b)<br>两边同时除以gcd（a，b）<br>(gcd(a,b)我们用w代替)<br>两边除以w，再乘c<br>a</em>x0+b<em>y0-gcd(a,b)+b</em>y*c/gcd(a,b)=c</p><p>如果w=1<br>x = x0 + b *  t<br>y = y0 - a *  t<br>且对任一正数t，皆成立<br>根据这个我们就可以求出方程所有解<br>t = b / w<br>x= ( x % t + t ) % t<br><del>有空专门整理一下exgcd原理和博客</del> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod =1e9+3;</span><br><span class="line">ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)</span><br><span class="line">&#123;</span><br><span class="line">x=1;</span><br><span class="line">y=0;</span><br><span class="line"><span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll d;</span><br><span class="line">d=exgcd(b,a%b,y,x);</span><br><span class="line">y=y<span class="_">-a</span>/b*x;</span><br><span class="line"><span class="built_in">return</span> d;</span><br><span class="line">&#125;//exgcd模板 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll a,b,c,k,x,y;</span><br><span class="line">scanf(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(ll i=0;i&lt;k/c;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll ans=(k-i*c);//去掉c*i的剩余部分</span><br><span class="line">ll w = exgcd(a,b,x,y);</span><br><span class="line"><span class="keyword">if</span>(ans%w)<span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">x= x * ans / w;</span><br><span class="line">y= y * ans / w;</span><br><span class="line"></span><br><span class="line">x=( x % ( b / w ) + ( b / w ) ) % ( b / w );</span><br><span class="line">y= ( ans - x * a ) / b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&gt;=0&amp;&amp;y&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二</li></ol><p>公式还有个变形方式：<br>k-ax-by=cz<br>(k-ax-by)/c=z<br>也就是( k - a x - b y ) % c = = 0<br> ( k - a i - b j ) % c = = 0<br> 枚举i和j就ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(j)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>( k - a i - b j ) % c = = 0</span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>曾经noip好像考过ecgcd裸题感兴趣可以做做</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4853/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。&lt;br&gt;数据保证一定存在解。如果存在多组解，输出任意一组。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="exgcd" scheme="http://Jozky.top/tags/exgcd/"/>
    
  </entry>
  
  <entry>
    <title>序列自动机</title>
    <link href="http://jozky.top/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/"/>
    <id>http://jozky.top/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/</id>
    <published>2020-04-02T05:28:45.000Z</published>
    <updated>2020-04-04T14:52:31.131Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>给你a和b两个字符串，问b是不是a的子序列？</p><ul><li>题解：<br><a href="https://ac.nowcoder.com/discuss/396686" target="_blank" rel="noopener">参考题解</a><br>注意看，子序列不是子串，两者含义不一样</li></ul><blockquote><p>一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S<br>通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。</p></blockquote><a id="more"></a><p>可以理解成：abc是abcd的子串，abc是adbewc的子序列，而非子串<br>求子串可以用kmp<br>那求子序列就用今天要讲的序列自动机<br>字符串A：abcdefgh<br>字符串B：aez<br>当a匹配过后，再去枚举后面的bcd没有意义，因为我们要找的是A中是否要aez三个字符，并且是这样的顺序，无须是连着的。如果我们能在a之后直接跳到a后面的一个e，再跳到e后面第一个z，等到子串B遍历完，或者在a中找不到了，我们就可以结束啦。<br>注意：我们在往后跳找字母时，比如a后面有很多个e，那么我们选第一个，因为如果第一个不行的话，那第二个第三个也白瞎，我们选的越往前其实选择空间就越大<br>仔细想想怎么能实现跳跃查找这个呢：<br>开个数组next[i][j]表示主串第i个字母之后的第一个‘a’+j的坐标，<br>next的维护只需要从后向前扫描主串，到第i位时维护一个数组last[j]，j表示对应的‘a’~‘z’，last反映的是最靠前的字母j在哪里，然后把值赋给next就ok了<br>这样查找时顺着走就可以了<br>每次匹配B复杂度是O（|B|），<br>总复杂度O(26|A|+|B|)，因为A要用26个字母都循环一遍所以是26|A|<br>可以通过下图理解<br><img src="https://img-blog.csdnimg.cn/20200402131626533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6 + 10;</span><br><span class="line">int n, t, next[maxn][30];</span><br><span class="line">char s[maxn], str[maxn];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">scanf(<span class="string">"%s"</span>, s+1);</span><br><span class="line">int len = strlen(s+1);</span><br><span class="line"><span class="keyword">for</span>(int i=len; i; i--) &#123;</span><br><span class="line"><span class="keyword">for</span>(int j=0; j&lt;26; j++) </span><br><span class="line">&#123;</span><br><span class="line">next[i-1][j] = next[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next[i-1][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">scanf(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">scanf(<span class="string">"%s"</span>, str);</span><br><span class="line">int lenc = strlen(str), f = 0;</span><br><span class="line">int now=0;</span><br><span class="line"><span class="keyword">for</span>(int i=0; i&lt;lenc; i++)&#123;</span><br><span class="line">now = next[now][str[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(!now) &#123;</span><br><span class="line">f = 1;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f) puts(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">else</span> puts(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：&lt;br&gt;给你a和b两个字符串，问b是不是a的子序列？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题解：&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/discuss/396686&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考题解&lt;/a&gt;&lt;br&gt;注意看，子序列不是子串，两者含义不一样&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S&lt;br&gt;通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="序列自动机" scheme="http://Jozky.top/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月2日 月月查华华的手机</title>
    <link href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/"/>
    <id>http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/</id>
    <published>2020-04-02T05:20:40.000Z</published>
    <updated>2020-04-04T14:55:19.468Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23053" target="_blank" rel="noopener">牛客网链接</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述</p><blockquote><p>月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。<br>月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。<br>现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行输入一个字符串A表示华华的昵称。 第二行输入一个正整数N表示华华的推荐好友的个数。<br>接下来N行，每行输入一个字符串BiB_iBi​表示某个推荐好友的昵称。</p></blockquote><p>输出描述:</p><blockquote><p>输出N行，对于第i个推荐好友，如果华华可能向她搭讪，输出Yes，否则输出No。 注意大写，同时也要注意输出效率对算法效率的影响。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">noiauwfaurainairtqltqlmomomo</span><br><span class="line">8</span><br><span class="line">rain</span><br><span class="line">air</span><br><span class="line">tql</span><br><span class="line">ntt</span><br><span class="line">xiaobai</span><br><span class="line">oiiiooo</span><br><span class="line">orzcnzcnznb</span><br><span class="line">ooooo</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>备注:<br><img src="https://img-blog.csdnimg.cn/20200402104928886.png" alt="在这里插入图片描述"><br><strong><em>题解：</em></strong><br>字符串问题<br>有两个解决方法，字典树和序列自动机都能做（我想到的）<br>这里就不讲字典树了<br>序列自动机：<br>序列自动机就是用一个数组next[i][j]来记录数组a第i位的字符j在i后第一次出现的坐标。<br>设串长为n,字符集大小为a，预处理时间复杂度为O(n*a)<br><a href="https://jozky.gitee.io/2020/04/02/序列自动机/" target="_blank" rel="noopener" title="序列自动机详细讲解">https://jozky.gitee.io/2020/04/02/序列自动机/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=n;i;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=1;j&lt;=a;j++) next[i-1][j]=next[i][j];</span><br><span class="line">next[i-1][s[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt; </span></span><br><span class="line"><span class="comment">#define forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">#define fore(n) for(int j=1;j&lt;=n;j++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int ma=1000004;</span><br><span class="line">char a[ma];</span><br><span class="line">int len;</span><br><span class="line">int w=0;</span><br><span class="line">int m;</span><br><span class="line">bool f=1;</span><br><span class="line">int next[ma][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;(a+1);</span><br><span class="line">int len=strlen(a+1);</span><br><span class="line"><span class="keyword">for</span>(int i=len;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=0;j&lt;=25;j++) next[i-1][j]=next[i][j];</span><br><span class="line">next[i-1][a[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char ch=getchar();</span><br><span class="line">forr(m)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;(a+1);</span><br><span class="line">len=strlen(a+1);</span><br><span class="line"> w=0;</span><br><span class="line">f=1;</span><br><span class="line">fore(len)</span><br><span class="line">&#123;</span><br><span class="line">w=next[w][a[j]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(w==0)</span><br><span class="line">&#123;</span><br><span class="line">f=0;</span><br><span class="line">cout&lt;&lt;<span class="string">"N0"</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f!=0)cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/23053&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。&lt;br&gt;月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。&lt;br&gt;现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="序列自动机" scheme="http://Jozky.top/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Recordering the Cows</title>
    <link href="http://jozky.top/2020/04/01/Recordering-the-Cows/"/>
    <id>http://jozky.top/2020/04/01/Recordering-the-Cows/</id>
    <published>2020-04-01T14:05:21.000Z</published>
    <updated>2020-04-04T14:52:30.270Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4860/B" target="_blank" rel="noopener">牛客网传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>Farmer John’s N cows (1 &lt;= N &lt;= 100), conveniently numbered 1..N, are<br>standing in a row. Their ordering is described by an array A, where<br>A(i) is the number of the cow in position i. Farmer John wants to<br>rearrange them into a different ordering for a group photo, described<br>by an array B, where B(i) is the number of the cow that should end up<br>in position i.</p></blockquote><a id="more"></a><blockquote><p>For example, suppose the cows start out ordered as follows:</p><p>A = 5 1 4 2 3</p><p>and suppose Farmer John would like them instead to be ordered like<br>this:</p><p>B = 2 5 3 1 4</p><p>To re-arrange themselves from the “A” ordering to the “B” ordering,<br>the cows perform a number of “cyclic” shifts. Each of these cyclic<br>shifts begins with a cow moving to her proper location in the “B”<br>ordering, displacing another cow, who then moves to her proper<br>location, displacing another cow, and so on, until eventually a cow<br>ends up in the position initially occupied by the first cow on the<br>cycle. For example, in the ordering above, if we start a cycle with<br>cow 5, then cow 5 would move to position 2, displacing cow 1, who<br>moves to position 4, displacing cow 2, who moves to position 1, ending<br>the cycle. The cows keep performing cyclic shifts until every cow<br>eventually ends up in her proper location in the “B” ordering. Observe<br>that each cow participates in exactly one cyclic shift, unless she<br>occupies the same position in the “A” and “B” orderings.</p><p>Please compute the number of different cyclic shifts, as well as the<br>length of the longest cyclic shift, as the cows rearrange themselves.</p></blockquote><p>输入描述:</p><blockquote><ul><li><p>Line 1: The integer N.</p></li><li><p>Lines 2..1+N: Line i+1 contains the integer A(i).</p></li><li><p>Lines 2+N..1+2N: Line 1+N+i contains the integer B(i)</p></li></ul></blockquote><p>输出描述:</p><blockquote><ul><li>Line 1: Two space-separated integers, the first giving the number of cyclic shifts and the second giving the number cows involved in the<br>longest such shift.  If there are no cyclic shifts, output -1 for the<br>second number.</li></ul></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p><strong>题意：</strong><br>比如样例：通过移动A，将A=B<br>A     5 1 4 2 3<br>B   2 5 3 1 4<br>id   1 2 3 4 5<br>首先A中5要到1的位置（id=2），然后1移动到2的位置上（id=4），2要移动到5的位置上上（id=1）就是一个环，5-&gt;1-&gt;2-&gt;5，移动次数为3（也就是环的长度），除此之外还有4-&gt;3-&gt;4,移动次数为2，问将A通过移动转化成B的过程中，最长移动次数（即最长的环）是多少？环的数量是多少？<br><strong>题解：</strong><br><strong>（第一二个代码讲述的是我做错的过程，正解在是第三个）</strong><br><del>这题是我难以忘记的痛o(╥﹏╥)o</del><br><img src="https://img-blog.csdnimg.cn/20200330140321589.png" alt="在这里插入图片描述">看完这个题第一反应是noip考过的信息传递，所以一开始就用并查集来做，father[A[id]]=B[id]（就是id相对于A的父亲节点是B），因为一定能成环，所以就找一共多少个环，并求出最长环的长度<br>然而。。。。<img src="https://img-blog.csdnimg.cn/20200330140749959.png" alt="在这里插入图片描述"><br>我调了一阵子也但还是段错误，我换了个oj测评一下，然后就就AC了。。。玄学（<del>可能这个oj数据弱</del> ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">int b[194000];</span><br><span class="line">int father[10003];</span><br><span class="line">bool f[100004];</span><br><span class="line">int maxx=0;</span><br><span class="line">void unionn(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    father[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x,int z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;//如果这个数在A中与B中位置相同，不需要交换</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;//如果这个数曾经被查询过</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;//如果这个环第一次被查询</span><br><span class="line">    z++;//z只有0和非0，来表示这个数之前是否被查询过</span><br><span class="line">    f[x]=1;</span><br><span class="line">    maxx=max(maxx,z);</span><br><span class="line">    find(father[x],z);//不断地向后查找5-&gt;1-&gt;2</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">        unionn(a[j],b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i,0))ant++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我痛定思痛，感觉是因为自身递归导致段错误，又改了一个思路，在寻找根节点并压缩路径的时候，顺便用dis来记录路径的长度，然后统计出最长的路径。<br>结果没段错误，但。。。wa了。。唉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">bool f[10034];//标记这个点所在的环是否被查询过</span><br><span class="line">int dis[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//  father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        int last=father[x];</span><br><span class="line">        father[x]=find(father[x]);</span><br><span class="line">        dis[x]+=dis[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line">void unionn(int aa,int bb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">    int x=find(aa);</span><br><span class="line">    int y=find(bb);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        father[x]=y;</span><br><span class="line">        dis[aa]=dis[bb]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);//更新最长边</span><br><span class="line">&#125;</span><br><span class="line">//int find(int x,int z)</span><br><span class="line">//&#123;</span><br><span class="line">//  <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;</span><br><span class="line">//  z++;</span><br><span class="line">//  f[x]=1;</span><br><span class="line">//  maxx=max(maxx,z);</span><br><span class="line">//  find(father[x],z);</span><br><span class="line">//&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">        <span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;//多少个环</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        unionn(a[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ant++;</span><br><span class="line">            f[father[i]]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我冷静一会后，重新思考，感觉把题越想越复杂了<br>样例：<br>A 5 1 4 2 3<br>B 2 5 3 1 4<br>f[]来标记id是否被查询过<br>我们用fa和fb来记录A和B中数的id位置，然后在union时,通过father[]来让 A中的点对应B的位置相互指向，A中id=1的5指向id=2的1，father[5]=1,依次类推<br>A    ——-&gt;5 1 4 2 3<br>fa——-&gt;2 4 5 3 1<br>B——–&gt;2 5 3 1 4<br>fb——–&gt;4 1 3 5 2<br>father—&gt;2 4 5 1 3<br>在查找时for(i-&gt;n),查询该点i后，接着查与这点i相连的点father[i]，并用f[]标记，ans记录长度，如果相连的点&gt;2(也就是这个点不是指向自己)，统计最长环长，并记录换的数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">int fa[10034];</span><br><span class="line">int fb[10034];</span><br><span class="line">int f[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">int ans;</span><br><span class="line">int id;</span><br><span class="line">int tot=0;</span><br><span class="line">int w=0;</span><br><span class="line">int find()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">ans=0;</span><br><span class="line"><span class="keyword">while</span>(f[id]==0)</span><br><span class="line">&#123;</span><br><span class="line">f[id]=1;</span><br><span class="line">ans++;</span><br><span class="line">id=father[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">tot=max(ans,tot);</span><br><span class="line">w++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">fa[a[i]]=i;</span><br><span class="line">fb[b[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">father[fa[a[i]]]=fb[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">//void unionn(int aa,int bb)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">//int x=find(aa);</span><br><span class="line">//int y=find(bb);</span><br><span class="line">//<span class="keyword">if</span>(x!=y)</span><br><span class="line">//&#123;</span><br><span class="line">//father[x]=y;</span><br><span class="line">//dis[aa]=dis[bb]+1;</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">//<span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">if</span>(tot==0)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">//<span class="built_in">return</span> 0;</span><br><span class="line">//&#125;</span><br><span class="line">//int ant=0;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//</span><br><span class="line">//unionn(a[i],b[i]);</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">//&#123;</span><br><span class="line">//ant++;</span><br><span class="line">//f[father[i]]=1;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">init1();</span><br><span class="line"><span class="keyword">if</span>(find()==0)cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;w&lt;&lt;<span class="string">" "</span>&lt;&lt;tot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于做出来了。。。我太菜了o(╥﹏╥)o</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4860/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Farmer John’s N cows (1 &amp;lt;= N &amp;lt;= 100), conveniently numbered 1..N, are&lt;br&gt;standing in a row. Their ordering is described by an array A, where&lt;br&gt;A(i) is the number of the cow in position i. Farmer John wants to&lt;br&gt;rearrange them into a different ordering for a group photo, described&lt;br&gt;by an array B, where B(i) is the number of the cow that should end up&lt;br&gt;in position i.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://Jozky.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>牛客网2020愚人节比赛</title>
    <link href="http://jozky.top/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/"/>
    <id>http://jozky.top/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/</id>
    <published>2020-04-01T14:01:50.000Z</published>
    <updated>2020-04-04T14:52:31.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="牛客2020年愚人节比赛2020-4-1-21-32-11"><a href="#牛客2020年愚人节比赛2020-4-1-21-32-11" class="headerlink" title="牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 "></a>牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 </h2><p><del>欢乐的一晚上</del><br><a href="https://ac.nowcoder.com/acm/contest/4863#question" target="_blank" rel="noopener">题目链接</a><br>其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感<br><img src="https://img-blog.csdnimg.cn/20200401211211311.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211308221.png" alt="在这里插入图片描述">不知道这是哪位哥的，心疼一下</p><a id="more"></a><p><strong>题解</strong><br>注：一下题解没必要较劲，欢乐局而已<br>对不对无所谓，换了最重要奥<br>A题rand36：<br>我试了好几个数，最后3过了，以为答案3，结果发现答案是随机的，看命了有人一下就过。。。<br>B寻宝游戏：<br>要找的宝贝就在宝藏图上，输出题目中图的地址就ac了<br>C老铁安排上：<br>看图是什么手机？老年机，所以是九字输入法，字母按照九字输入法的对应数字<br>D神奇的字母<br>输出题目中的样例<br>“一个字符，表示神奇的字母（范围从’a’到’z’，保证小写）。”<br>即可<br>E return1；<br>不会（笑哭）貌似场上唯一一个没人做出来的题<br>F 抬头，答案在天上<br>天上就是指你浏览器的上面，也就是网址，按照顺序对应相应的数字<br>G抬头在地上<br>就是看字地下的标点符号，你会发现有个标点符号是超链接，输出超链接地址即可<br>H园<br>问你能套多少园，可没说不能套娃哦<del>，n是几就能套几个<br>I牛客搜索题<br>这里面最扯的题（个人感觉<img src="https://img-blog.csdnimg.cn/20200401212525727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">）<br>J签到题<br>不会（笑哭）<br>K四万像素五角星<br>有个大佬手打出来了。。。<br>L positive-integer<br>经过证明<br>n=1时，输出1；<br>其他输出0<br>证明过程嘛。。。（</del>多尝试几次就OK了，不怕失败，都wa了多少次了）~~<br>好像官方出题解了，看官方题解吧<br><a href="https://ac.nowcoder.com/discuss/396514?type=101&order=0&pos=5&page=1" target="_blank" rel="noopener">题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;牛客2020年愚人节比赛2020-4-1-21-32-11&quot;&gt;&lt;a href=&quot;#牛客2020年愚人节比赛2020-4-1-21-32-11&quot; class=&quot;headerlink&quot; title=&quot;牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 &quot;&gt;&lt;/a&gt;牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 &lt;/h2&gt;&lt;p&gt;&lt;del&gt;欢乐的一晚上&lt;/del&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4863#question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211211311.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;)&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;)&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211308221.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;不知道这是哪位哥的，心疼一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="欢乐局" scheme="http://Jozky.top/tags/%E6%AC%A2%E4%B9%90%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2020-04-01T02:13:38.008Z</published>
    <updated>2020-04-04T14:49:51.246Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 32768K  其他语言 65536K<br> 64bit IO Format:%lld</p><p><a href="https://ac.nowcoder.com/acm/problem/50528" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">洛谷</a><br> <strong>题目描述</strong><br>给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：</p></blockquote><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200329120250163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>你的任务是找出窗体在各个位置时的最大值和最小值。</p></blockquote><p>输入描述:</p><blockquote><p>第1行：两个整数N和K； 第2行：N个整数，表示数组的N个元素(≤2×10^9^)；</p></blockquote><p>输出描述:</p><blockquote><p>第一行为滑动窗口从左向右移动到每个位置时的最小值，每个数之间用一个空格分开；<br>第二行为滑动窗口从左向右移动到每个位置时的最大值，每个数之间用一个空格分开。</p></blockquote><p>示例1<br>输入<br>8 3<br>1 3 -1 -3 5 3 6 7<br>输出<br>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7<br>备注:<br>对于20%的数据，K≤N≤1000；<br>对于50%的数据，K≤N≤10^5^<br>对于100%的数据，K≤N≤10^6^<br><strong>题解：</strong><br>老题了。。<br>（<del>想起来我当年逝去的OI梦</del> ）</p><p>赶紧从洛谷找到以前的代码<br>就是单调队列的模板题<br><del>手写就完事了</del> </p><p>构造一个单调队列，<br>我们来模拟下过程：<br>（以求最小为例）<br>head指向头，tail指向尾<br>a[]是我们一开始存放的数<br>mi存放的是最小值的坐标（即 i ）<br>i是指向数组a当前位置<br>m=3<br>例如 1 3 -1<br>坐标 1 2  3<br>1和3顺利存入mi中（存的是坐标）mi={1,2}；<br>读入-1时与前面的进行比较，-1&lt;3然后tail–，-1&lt;1,tail–,直到整个区间都比完（也就是tail大于head时），或者是出现比-1还小的数x，tail就在x的位置停下来。然后将-1的坐标存入到mi[++tail]中,说明从tail之后没有比-1还小的了.<br>m=3<br>例如1 2 4 5 4<br>如果读入的数没有比之前小的，就依次读入mi中，mi=[1,2,3],head=1;当i=4时,就超出m的范围时（mi[head]+m&lt;=i），就将区间向后移动（head++，头向后移动，整个区间也跟着移动），随着输出（将多的输出来）<br>然后一直循环就可以了。<br>head指的是mi，mi反应的是当前最小值在a中的坐标<br>也可以写两个数组来一个表示单调队列，一个表示对应的在原列表里的序号，我这就用了一个。<br>（话说线段树也可以做）<br><del>讲的我自己也有点乱，明白但是讲不大出来，结合者代码看吧</del> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+3;</span><br><span class="line">int a[maxn];</span><br><span class="line">int ma[maxn];</span><br><span class="line">int mi[maxn]; </span><br><span class="line">void min(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int head=1;</span><br><span class="line">int tail=0;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;mi[head]+m&lt;=i)</span><br><span class="line">head++;//向后移动head</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&lt;a[mi[tail]])</span><br><span class="line">tail--;//向前移动tail</span><br><span class="line"></span><br><span class="line">tail++;</span><br><span class="line">mi[tail]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[mi[head]]&lt;&lt;<span class="string">" "</span>;//如果元素超出就输出当前区域最小</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void max(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int head=1;</span><br><span class="line">int tail=0;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;ma[head]+m&lt;=i)head++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&gt;a[ma[tail]])tail--;</span><br><span class="line">tail++;</span><br><span class="line">ma[tail]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[ma[head]]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(n)cin&gt;&gt;a[i];</span><br><span class="line">min(n,m);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">max(n,m);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt; 空间限制：C/C++ 32768K  其他语言 65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50528&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;br&gt; &lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="单调队列" scheme="http://Jozky.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
