<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-07-18T03:52:08.406Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小小粉刷匠</title>
    <link href="http://jozky.top/2020/07/18/%E5%B0%8F%E5%B0%8F%E7%B2%89%E5%88%B7%E5%8C%A0/"/>
    <id>http://jozky.top/2020/07/18/%E5%B0%8F%E5%B0%8F%E7%B2%89%E5%88%B7%E5%8C%A0/</id>
    <published>2020-07-18T03:49:29.000Z</published>
    <updated>2020-07-18T03:52:08.406Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16129" target="_blank" rel="noopener">来源：牛客网：</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">32768</span>K，其他语言<span class="number">65536</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>“lalala,我是一个快乐的粉刷匠”,小名一边快活地唱着歌,一边开心地刷着墙”,兴致突然被打断,”小名,你今天如果刷不完这一栋楼的墙，那么你就等着被炒鱿鱼吧”,老板声嘶力竭的吼着。</p></blockquote><a id="more"></a><blockquote><p>苦恼的小名因为不想被炒鱿鱼,所以希望尽量快地刷完墙,由于他本人的数学基础很差,他现在请你来帮助他计算最少完成每一堵墙需要刷多少次。每一面墙有n个段,对于每个段指定一个目标颜色ci。刚开始的时候所有的墙壁为白色,我们现在有一个刷子,刷子长度为k,刷子每次可以选择一种颜色,然后选择段数为(1～k)连续的墙段刷成选择的一种颜色。我们现在想要知道，为了把墙变成目标颜色，最少刷多少次(保证指定的目标颜色一定不为白色)。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>对于每一个案例,我们第一行包括两个整数n,k(1&lt;=n&lt;=100,1&lt;=k&lt;=50,k&lt;n),表示墙的长度为n,刷子的长度为k。第二行输入n个整数(c1c2…cn),(1&lt;=ci&lt;=256),表示对于墙的每一段指定的颜色。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出一个数,表示小名最少刷多少次。</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>示例2<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>区间dp<br>首先上一个区间dp的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">dp[i][j]是从1到n</span></span><br><span class="line"><span class="comment">初始化dp[i][i]=1,或者其他的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++)&#123;<span class="comment">//枚举长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;<span class="comment">//枚举起点i</span></span><br><span class="line">            <span class="keyword">int</span> j=i+len<span class="number">-1</span>;<span class="comment">//枚举终点j</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i; k&lt;j; k++)&#123;<span class="comment">//找断点k的位置,可随实际情况修改</span></span><br><span class="line">            <span class="comment">//将区间[i,j],拆成[i,k][k+1,j]</span></span><br><span class="line">            ......</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>dp[i][j]表示第i个位置到第j个位置所需要最小步数<br>dp[i][i]初始化为1,dp[i][j]=dp[i+1][j]+1<br>题目是有限制ank，每次画的长度为k<br>第一种情况：<br>ank&gt;len,（len为我们当前枚举的长度），我们可以直接画完，我们在枚举断点k时，先判断a[i]==a[k]，如果相等有<br>dp[i][j]=min(dp[i][j],dp[i+1][k]+dp[k+1][j])，最少操作次数就是讲第i个与第k个一起涂，所以区间[i,j]中做端点i就不用考虑了<br>第二种：<br>当len&gt;ank时，我们的刷子长度不够，所以直接将区间拆分即可<br>dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j])<br>区间dp多为此套路</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">140</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,ank;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;ank;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>;len&lt;=n;len++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">dp[i][j]=dp[i+<span class="number">1</span>][j]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(j&gt;n)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(ank&gt;=len)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==a[k])dp[i][j]=min(dp[i][j],dp[i+<span class="number">1</span>][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=i+<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[<span class="number">1</span>][n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16129&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;32768&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;65536&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“lalala,我是一个快乐的粉刷匠”,小名一边快活地唱着歌,一边开心地刷着墙”,兴致突然被打断,”小名,你今天如果刷不完这一栋楼的墙，那么你就等着被炒鱿鱼吧”,老板声嘶力竭的吼着。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="区间dp" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月14日题目精讲-压缩</title>
    <link href="http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E5%8E%8B%E7%BC%A9/"/>
    <id>http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E5%8E%8B%E7%BC%A9/</id>
    <published>2020-07-18T03:49:18.000Z</published>
    <updated>2020-07-18T03:51:51.718Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20252" target="_blank" rel="noopener">来源：牛客网：</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">262144</span>K，其他语言<span class="number">524288</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。 压缩后的字符串除了小<br>写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没<br>有M，则从串的开始算起）开始的解压结果（称为缓冲串）。 </p></blockquote><a id="more"></a><blockquote><p>bcdcdcdcd可以压缩为bMcdRR，下面是解压缩的过程<br><img src="https://uploadfiles.nowcoder.com/files/20200715/543071257_1594784198516_20200715102805336.png" alt="在这里插入图片描述"><br>另一个例子是abcabcdabcabcdxyxyz可以被压缩为abcRdRMxyRz。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>输入仅一行，包含待压缩字符串，仅包含小写字母，长度为n。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出仅一行，即压缩后字符串的最短长度。</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdcdcdcdxcdcdcdcd</span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我们先考虑没有M的影响<br>dp[i][j]表示字符串i到j的最短压缩长度<br>区间dp，我们可以得到：<br>第一种：没有相等子串的一般情况时<br>转移dp [ l ] [ r ] = min ( dp [ l ] [ i ] + dp [ i + 1 ] [ r ] ) (l&lt;=i&lt;=r)<br>第二种：子串长度是偶数，且可以拆分成两个相等的子串时，此时我们可以进行压缩,<br>mid=（l+r）&gt;&gt;1,<br>mid+1到r这一段就可以被一个字符R代替<br>转移dp[l][r]=min(dp[l][r],f[l][mid]+1)<br>当考虑有M时，R匹配总是与最近的M匹配<br>我们可以给状态加一维：<br>dp[l][r][0/1]表示原串l到r在区间内是否有M的最短长度<br>如果当前区间左一半和右一半相等且中间没有M，我们可以把后一半换成R（和上面讲的情况一样）<br>dp[l][r][0]=min(dp[l][r][0],dp[l][i][0]+(r-i))(l&lt;=i&lt;=r)</p><p>当区间内有M时，就需要将区间分成M之前和之后两部分压缩，因为R只能匹配最近的M，M之前的就管不了了<br>然后看拆分后的区间的各自情况（看拆分后的区间是有M好还是没M好），记得要+1，因为多加了一个字符M<br>dp[l][r][1]=min ( dp [l] [r] [1] , min ( dp[l][i][1] , dp[l][i][0] ) +1)<br>(l&lt;=i&lt;r)i枚举的是M的位置<br>以上两步都算是正常情况<br>当区间[l,r]可以拆分成两个相等的部分[l,mid],[mid+1,r]时，<br>dp[l][r][0]=min(dp[l][r][0],dp[l][mid][0]+1)<br>最后答案就是取最小值min(dp[1][n][0],dp[1][n][1])</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">85</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> s=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch))&#123;s=(s&lt;&lt;<span class="number">3</span>)+(s&lt;&lt;<span class="number">1</span>)+ch<span class="number">-48</span>;ch=getchar();&#125;</span><br><span class="line"><span class="keyword">return</span> s*f;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//检验左右区间是否相等 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=mid;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]!=s[mid+i-l+<span class="number">1</span>])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> leng=s.length();</span><br><span class="line"> s=<span class="string">" "</span>+s;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">1</span>;len&lt;=leng;++len)&#123;<span class="comment">//从头开始枚举长度 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+len<span class="number">-1</span>&lt;=leng;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=i+len<span class="number">-1</span>;</span><br><span class="line">            dp[i][j][<span class="number">0</span>]=dp[i][j][<span class="number">1</span>]=len;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=i;k&lt;=j;++k)&#123;<span class="comment">//从k将区间分为两部分 </span></span><br><span class="line">                dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],dp[i][k][<span class="number">0</span>]+j-k);</span><br><span class="line">                dp[i][j][<span class="number">1</span>]=min(dp[i][j][<span class="number">1</span>],min(dp[i][k][<span class="number">1</span>],dp[i][k][<span class="number">0</span>])+min(dp[k+<span class="number">1</span>][j][<span class="number">0</span>],dp[k+<span class="number">1</span>][j][<span class="number">1</span>])+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;check(i,j))<span class="comment">//如果是偶数，且左右两区间相等</span></span><br><span class="line">dp[i][j][<span class="number">0</span>]=min(dp[i][j][<span class="number">0</span>],dp[i][(i+j)&gt;&gt;<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;min(dp[<span class="number">1</span>][leng][<span class="number">0</span>],dp[<span class="number">1</span>][leng][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20252&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;262144&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;524288&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。 压缩后的字符串除了小&lt;br&gt;写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没&lt;br&gt;有M，则从串的开始算起）开始的解压结果（称为缓冲串）。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="区间dp" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月13日题目精讲-Kingdom</title>
    <link href="http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8813%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Kingdom/"/>
    <id>http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8813%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Kingdom/</id>
    <published>2020-07-18T03:49:04.000Z</published>
    <updated>2020-07-18T03:51:54.507Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19810" target="_blank" rel="noopener">【每日一题】7月13日题目精讲—Kingdom</a><br>@[toc]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">2</span>秒，其他语言<span class="number">4</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>X王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个官员是这个上司的下属。上司的编号总比下属小。<br>我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力是1。国王的影响力总是n。</p></blockquote><a id="more"></a><blockquote><p>任何一位有下属的官员总是选择他的下属中影响力最高的作为他的心腹（有若干下属影响力相同的话则会选择编号最小的）。<br>一位官员得到一条消息后，他就要把消息传达给国王。我们定义一位官员的花费为他将消息传达给国王的花费。国王自己的花费为0。如果一位官员是他上司的心腹，则他的花费等于他上司的花费，否则他的花费为他上司的花费加1。<br>由于时代和平，消息并不需要传递的太快。我们希望你决定每位官员（除了国王）的上司，使得所有官员的花费之和尽量大。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>一个整数n（1≤ n≤ 8000）表示包括国王在内的官员的总数。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一个整数表示最大的花费之和。</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>借鉴自<a href="https://blog.nowcoder.net/n/faa0c6366d684b3c8598075f4ba2aa35" target="_blank" rel="noopener">题解</a><br>重儿子：父亲节点的所有儿子中子树结点数目最多（size最大）的结点<br>假设n个节点的排列情况如图所示<br><img src="https://uploadfiles.nowcoder.com/files/20200714/543071257_1594738566370_20200714221945132.png" alt="在这里插入图片描述"><br>树根是root，下面是k个子树<br>ans[n]为n个节点的数所得的最优解<br>根据题意我们知道点x的心腹就是点x的重儿子<br>如果重儿子所在子树A，我们将重儿子的子树a与x点分离，看做独立部分，那么子树a的最优解就是ans[sumA]<br>我们再把子树a连接到x点，因为子树a是重儿子，重儿子的边到父节点木有影响，所以最优解还是ans[sumA]<br>如果子树A不是重儿子，我们也是先分离看，最优解是ans[sumA],然后连接x点，因为不是重儿子（即心腹），根据题意花费要加一，相当于子树A中的节点都要加一，加了sumA个1，最优解就是ans[sumA]+sumA<br>可以结合下图理解理解<br>如果重儿子所在子树是A，其他点就不是重儿子，所得结论：<br>ans[n]=(ans[sum1]+ans[sum2]+…ans[sumA]…+ans[sumk])+(n−sumA−1)<br><img src="https://uploadfiles.nowcoder.com/files/20200714/543071257_1594738566399_20200714221740634.png" alt="在这里插入图片描述"><br>然后我们用dp[i][j]表示i个节点组成的多个树，且最多节点的那棵树节点数不超过j<br>（该图选自参考题解）<br><img src="https://uploadfiles.nowcoder.com/files/20200714/543071257_1594738566383_20200714223119113.png" alt="在这里插入图片描述"><br>我们现在要用到ans和dp两个数组<br>根据图片可得：dp[n−sumX−1][sumX]+（n−sumX−1）+ans[sumX]<br>这样ans[n]取最大值即可<br>ans[n]=dp[n−1−sumX][sumX]+（n−1−sumX）+ans[sumX]，且1&lt;=sumX&lt;n<br>dp[i][j]表示i个节点组成的多个树，且最多节点的那棵树节点数不超过j，分为两种情况：<br>dp[i][j]=dp[i][j-1]//节点数是i，最大树节点不超过j-1也肯定不超过j<br>dp[i][j]=dp[i-x][j]+ans[x]//一颗节点数为x的树和一个节点总数为i-x的森林，合成一个节点数为i的森林，最大节点依旧小于j<br>两种情况取最小值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=max(ans[i],ans[j]+dp[i-j<span class="number">-1</span>][j]+(i-j<span class="number">-1</span>));<span class="comment">//求出i个节点的树的最优解 </span></span><br><span class="line"><span class="comment">//重儿子所在子树节点数为j</span></span><br><span class="line"><span class="comment">//非重儿子所在子树节点个数总和为i-j-1 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//有点像完全背包 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=i)</span><br><span class="line"> dp[j][i]=max(dp[j][i<span class="number">-1</span>],dp[j-i][i]+ans[i]);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">dp[j][i]=dp[j][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19810&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【每日一题】7月13日题目精讲—Kingdom&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1048576&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;2097152&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;X王国有n位官员，编号从1到n。国王是1号官员。除了国王以外，每个官员都有一个上司。我们称这个官员是这个上司的下属。上司的编号总比下属小。&lt;br&gt;我们定义一个官员的影响力为他所有下属的影响力之和再加1。例如，一个没有下属的官员的影响力是1。国王的影响力总是n。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>关于__int128高精度运算</title>
    <link href="http://jozky.top/2020/07/18/%E5%85%B3%E4%BA%8E-int128%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/"/>
    <id>http://jozky.top/2020/07/18/%E5%85%B3%E4%BA%8E-int128%E9%AB%98%E7%B2%BE%E5%BA%A6%E8%BF%90%E7%AE%97/</id>
    <published>2020-07-18T03:46:54.000Z</published>
    <updated>2020-07-18T03:48:24.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/ECJTUACM-873284962/p/9198885.html" target="_blank" rel="noopener">参考文章</a><br>使用__int128可以实现高精度运算，但是这种大整数无法使用函数printf输出结果，所以需要手写输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> __int128 <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'-'</span>)</span><br><span class="line">            f=<span class="number">-1</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(__int128 x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">9</span>)</span><br><span class="line">        write(x/<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __int128 a = read();</span><br><span class="line">    __int128 b = read();</span><br><span class="line">    write(a + b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/ECJTUACM-873284962/p/9198885.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文章&lt;/a&gt;&lt;br&gt;使用__int128可以实现高精度运算，但是这种大整
      
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="高精度" scheme="http://Jozky.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月10日精讲-矩阵取数游戏</title>
    <link href="http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8810%E6%97%A5%E7%B2%BE%E8%AE%B2-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/"/>
    <id>http://jozky.top/2020/07/18/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%8810%E6%97%A5%E7%B2%BE%E8%AE%B2-%E7%9F%A9%E9%98%B5%E5%8F%96%E6%95%B0%E6%B8%B8%E6%88%8F/</id>
    <published>2020-07-18T03:46:47.000Z</published>
    <updated>2020-07-18T03:47:43.756Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16645" target="_blank" rel="noopener">来源：牛客网：</a><br>@[toc]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">262144</span>K，其他语言<span class="number">524288</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的n*m的矩阵，矩阵中的每个元素aij均为非负整数。游戏规则如下：<br>1.每次取数时须从每行各取走一个元素，共n个。m次后取完矩阵所有元素；<br>2.每次取走的各个元素只能是该元素所在行的行首或行尾；<br>3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 * 2^i^，其中i表示第i次取数（从1开始编号）；<br>4.游戏结束总得分为m次取数得分之和。 帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。</p></blockquote><a id="more"></a><p><strong>输入描述:</strong></p><blockquote><p>第1行为两个用空格隔开的整数n和m。 第2~n+1行为n*m矩阵，其中每行有m个用单个空格隔开的非负整数。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出一个整数，即输入矩阵取数后的最大得分。</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">82</span></span><br></pre></td></tr></table></figure><p>说明<br>第1次：第1行取行首元素，第2行取行尾元素，本次得分为1 * 2^1^ + 2 * 2^1^ = 6<br>第2次：两行均取行首元素，本次得分为2 * 22 + 3 * 22 = 20<br>第3次：得分为3 * 23 + 4 * 23 = 56。<br>总得分为6 + 20 + 56 = 82<br>示例2<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">122</span></span><br></pre></td></tr></table></figure><p>示例3<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">10</span></span><br><span class="line"><span class="number">96</span> <span class="number">56</span> <span class="number">54</span> <span class="number">46</span> <span class="number">86</span> <span class="number">12</span> <span class="number">23</span> <span class="number">88</span> <span class="number">80</span> <span class="number">43</span></span><br><span class="line"><span class="number">16</span> <span class="number">95</span> <span class="number">18</span> <span class="number">29</span> <span class="number">30</span> <span class="number">53</span> <span class="number">88</span> <span class="number">83</span> <span class="number">64</span> <span class="number">67</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">316994</span></span><br></pre></td></tr></table></figure><p>备注:<br>60%的数据满足：1 ≤ n, m ≤ 30, 答案不超过1016<br>100%的数据满足：1 ≤ n, m ≤ 80, 0 ≤ aij ≤ 1000</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>每一行都进行的相同操作，且每一行的操作都互不影响，所以我们可以一行一行的考虑，算出每一行的最佳情况然后求和<br>这样就降低难度维度<br>先看第一行，只能在行首行尾取，如果我们要知道区间[1,m]的最佳情况，就要知道[1,m-1]和[2,n]的最优解，因为是由他俩推过去的，依次类推<br>dp[i][j]表示i到j区间的最优解<br>dp[i][j]=min(dp[i+1][j]+2^k^ *a[i] ，dp[i][j-1] +2^k^ *a[j])<br>由内向外扩展的过程<br>区间长度为n时k取1，长度每缩短一次k++，（相当于第k次取）</p><p>因为我们乘以2是依次增多的，所以每次都乘以2<br>本题是需要高精度的，当然也可以使用__int128 +快读快输 （<del>黑魔法</del>） </p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _t __int128</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">_t</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">_t</span> x=<span class="number">0</span>,f=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">'-'</span>)f=<span class="number">1</span>;</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>)</span><br><span class="line">&#123;</span><br><span class="line">x=x*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">x=-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">9</span>)put(x/<span class="number">10</span>);</span><br><span class="line"><span class="built_in">putchar</span>(x%<span class="number">10</span>+<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">_t</span> n,m,res;</span><br><span class="line"><span class="keyword">_t</span> a[<span class="number">103</span>][<span class="number">103</span>],dp[<span class="number">103</span>][<span class="number">104</span>];</span><br><span class="line"><span class="function"><span class="keyword">_t</span> <span class="title">cul</span><span class="params">(<span class="keyword">_t</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">_t</span> len=<span class="number">1</span>;len&lt;=m;len++)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">_t</span> l=<span class="number">1</span>,r=l+len<span class="number">-1</span>;r&lt;=m;l++,r=l+len<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">dp[l][r]=max(dp[l+<span class="number">1</span>][r]+b[l],dp[l][r<span class="number">-1</span>]+b[r]);</span><br><span class="line">dp[l][r]=<span class="number">2</span>*dp[l][r];</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> dp[<span class="number">1</span>][m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read(),m=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">a[i][j]=read();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">res+=cul(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">put(res);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16645&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;262144&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;524288&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的n*m的矩阵，矩阵中的每个元素aij均为非负整数。游戏规则如下：&lt;br&gt;1.每次取数时须从每行各取走一个元素，共n个。m次后取完矩阵所有元素；&lt;br&gt;2.每次取走的各个元素只能是该元素所在行的行首或行尾；&lt;br&gt;3.每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 * 2^i^，其中i表示第i次取数（从1开始编号）；&lt;br&gt;4.游戏结束总得分为m次取数得分之和。 帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="区间dp" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="高精度" scheme="http://Jozky.top/tags/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>一起开心2020暑假训练第二周 图论（模板题）</title>
    <link href="http://jozky.top/2020/07/13/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%832020%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%BA%8C%E5%91%A8-%E5%9B%BE%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%89/"/>
    <id>http://jozky.top/2020/07/13/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%832020%E6%9A%91%E5%81%87%E8%AE%AD%E7%BB%83%E7%AC%AC%E4%BA%8C%E5%91%A8-%E5%9B%BE%E8%AE%BA%EF%BC%88%E6%A8%A1%E6%9D%BF%E9%A2%98%EF%BC%89/</id>
    <published>2020-07-13T08:29:34.000Z</published>
    <updated>2020-07-13T08:30:38.764Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://vjudge.net/contest/381143#problem" target="_blank" rel="noopener">比赛链接：</a><br>@[toc]</p><a id="more"></a><h2 id="A-HDU-1285-一"><a href="#A-HDU-1285-一" class="headerlink" title="A HDU 1285 一"></a>A HDU 1285 一</h2><p>拓扑排序模板题，记录每个点的入度，然后按照入度大小以及顺序进行输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>[<span class="number">517</span>][<span class="number">517</span>];</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">517</span>];</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topo</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==<span class="number">0</span>)</span><br><span class="line">            q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(c!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">            c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">map</span>[v][i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            in[i]--;</span><br><span class="line">            <span class="keyword">if</span>(!in[i])</span><br><span class="line">                q.push(i);</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,i,j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">map</span>,<span class="number">0</span>,<span class="keyword">sizeof</span> <span class="built_in">map</span>);</span><br><span class="line">        <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span> in);</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">map</span>[i][j])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">map</span>[i][j]=<span class="number">1</span>;</span><br><span class="line">            in[j]++;</span><br><span class="line">        &#125;</span><br><span class="line">        topo(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-HDU-1863-起"><a href="#B-HDU-1863-起" class="headerlink" title="B    HDU 1863    起"></a>B    HDU 1863    起</h2><p>最小生成树模板题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">32</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x)<span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">total=<span class="number">0</span>;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u=find(edge[i].u);</span><br><span class="line"><span class="keyword">int</span> v=find(edge[i].v);</span><br><span class="line"><span class="keyword">if</span>(u==v)<span class="keyword">continue</span>;</span><br><span class="line">sum+=edge[i].w;</span><br><span class="line">fa[u]=v;</span><br><span class="line">total++;</span><br><span class="line"><span class="keyword">if</span>(total==n<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)fa[i]=i;</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line">sort(edge+<span class="number">1</span>,edge+<span class="number">1</span>+m,cmp);</span><br><span class="line">Kruskal();</span><br><span class="line"><span class="keyword">if</span>(total==n<span class="number">-1</span>)<span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"?"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-POJ-2387-开"><a href="#C-POJ-2387-开" class="headerlink" title="C    POJ 2387    开"></a>C    POJ 2387    开</h2><p>最短路模板，从n 到 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">500005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,num_edge=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn],head[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> next,to,dis;</span><br><span class="line">&#125;edge[maxm]; <span class="comment">//结构体表示静态邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span> <span class="comment">//邻接表建图</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//以下是数据结构书上的标准代码，不懂翻书看解释</span></span><br><span class="line">  edge[++num_edge].next=head[from]; <span class="comment">//链式存储下一条出边</span></span><br><span class="line">  edge[num_edge].to=to; <span class="comment">//当前节点编号</span></span><br><span class="line">  edge[num_edge].dis=dis; <span class="comment">//本条边的距离</span></span><br><span class="line">  head[from]=num_edge; <span class="comment">//记录下一次的出边情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//spfa用队列，这里用了STL的标准队列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dis[i]=inf; <span class="comment">//带权图初始化</span></span><br><span class="line">    vis[i]=<span class="number">0</span>; <span class="comment">//记录点i是否在队列中，同dijkstra算法中的visited数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.push(s); dis[s]=<span class="number">0</span>; vis[s]=<span class="number">1</span>; <span class="comment">//第一个顶点入队，进行标记</span></span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> u=q.front(); <span class="comment">//取出队首</span></span><br><span class="line">    q.pop(); vis[u]=<span class="number">0</span>; <span class="comment">//出队标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=edge[i].next) <span class="comment">//邻接表遍历，不多解释了（也可用vector代替）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> v=edge[i].to; </span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].dis) <span class="comment">//如果有最短路就更改</span></span><br><span class="line">      &#123;</span><br><span class="line">        dis[v]=dis[u]+edge[i].dis;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) <span class="comment">//未入队则入队</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[v]=<span class="number">1</span>; <span class="comment">//标记入队</span></span><br><span class="line">          q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">  s=n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> f,g,w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;f&gt;&gt;g&gt;&gt;w; </span><br><span class="line">    addedge(f,g,w); <span class="comment">//建图，有向图连一次边就可以了</span></span><br><span class="line">    addedge(g,f,w);</span><br><span class="line">  &#125;</span><br><span class="line">   spfa(); <span class="comment">//开始跑spfa</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;dis[<span class="number">1</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//否则打印最短距离</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D-POJ-1502-心"><a href="#D-POJ-1502-心" class="headerlink" title="D    POJ 1502    心"></a>D    POJ 1502    心</h2><p>也是最短路模板题，只是读入方式有些奇怪</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">10010</span>,MAXM=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XY</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,to,pre;</span><br><span class="line">&#125;e[MAXM];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XX</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> dis,num;</span><br><span class="line">&#125;d[MAXN],tmp;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp1</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(XX &amp;a,XX &amp;b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.dis&gt;b.dis;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> w[<span class="number">110</span>];</span><br><span class="line"><span class="keyword">int</span> n,s,sz=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> las[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[MAXN];</span><br><span class="line">priority_queue&lt;XX,<span class="built_in">vector</span>&lt;XX&gt;,cmp1&gt; q;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">sz=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(las,<span class="number">0</span>,<span class="keyword">sizeof</span>(las));</span><br><span class="line"><span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">++sz;</span><br><span class="line">e[sz].to=y;</span><br><span class="line">e[sz].w=w;</span><br><span class="line">e[sz].pre=las[x];</span><br><span class="line">las[x]=sz;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> min,u=<span class="number">0</span>;</span><br><span class="line">s=<span class="number">1</span>;</span><br><span class="line">d[s].dis=<span class="number">0</span>;</span><br><span class="line">q.push(d[s]);</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">u=q.top().num;</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (flag[u]) <span class="keyword">continue</span>;</span><br><span class="line">flag[u]=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=las[u];j;j=e[j].pre)&#123;</span><br><span class="line"><span class="keyword">int</span> mu=e[j].to;</span><br><span class="line"><span class="keyword">if</span> (d[mu].dis&gt;d[u].dis+e[j].w)&#123;</span><br><span class="line">d[mu].dis=d[u].dis+e[j].w;</span><br><span class="line">q.push(d[mu]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zhuanhua</span><span class="params">(<span class="keyword">char</span> s[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'x'</span>)</span><br><span class="line">        <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); i++)</span><br><span class="line">            sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n)!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">d[i].num=i;</span><br><span class="line">d[i].dis=<span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,w);</span><br><span class="line"><span class="keyword">int</span> zz=zhuanhua(w);</span><br><span class="line">add(i,j,zz);</span><br><span class="line">    add(j,i,zz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dijkstra();</span><br><span class="line"><span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">maxx=max(maxx,d[i].dis);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;maxx;</span><br><span class="line"><span class="keyword">while</span>(!q.empty())q.pop(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-HDU-5922-图"><a href="#E-HDU-5922-图" class="headerlink" title="E    HDU 5922    图"></a>E    HDU 5922    图</h2><p>找规律，表面是最小生成树，但仔细看会发现将点1与其他点相连费用最低（因为费用为两点之和，而1是最小的数）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case #%d: %lld\n"</span>,i,(n<span class="number">-1</span>)*(n+<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-HDU-2112-论"><a href="#F-HDU-2112-论" class="headerlink" title="F    HDU 2112    论"></a>F    HDU 2112    论</h2><p>也是最短路，不过每个站点都是具体的城市名，可以用map实现名字与编号的唯一对应</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> inf=<span class="number">2147483647</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">70005</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,s,num_edge=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;mp; </span><br><span class="line"><span class="keyword">int</span> dis[maxn],vis[maxn],head[maxm];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> next,to,dis;</span><br><span class="line">&#125;edge[maxm]; <span class="comment">//结构体表示静态邻接表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">int</span> dis)</span> <span class="comment">//邻接表建图</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//以下是数据结构书上的标准代码，不懂翻书看解释</span></span><br><span class="line">  edge[++num_edge].next=head[from]; <span class="comment">//链式存储下一条出边</span></span><br><span class="line">  edge[num_edge].to=to; <span class="comment">//当前节点编号</span></span><br><span class="line">  edge[num_edge].dis=dis; <span class="comment">//本条边的距离</span></span><br><span class="line">  head[from]=num_edge; <span class="comment">//记录下一次的出边情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; <span class="comment">//spfa用队列，这里用了STL的标准队列</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    dis[i]=inf; <span class="comment">//带权图初始化</span></span><br><span class="line">    vis[i]=<span class="number">0</span>; <span class="comment">//记录点i是否在队列中，同dijkstra算法中的visited数组</span></span><br><span class="line">  &#125;</span><br><span class="line">  q.push(s); </span><br><span class="line">  dis[s]=<span class="number">0</span>;</span><br><span class="line">vis[s]=<span class="number">1</span>; <span class="comment">//第一个顶点入队，进行标记</span></span><br><span class="line">  <span class="keyword">while</span>(!q.empty())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> u=q.front(); <span class="comment">//取出队首</span></span><br><span class="line">    q.pop(); vis[u]=<span class="number">0</span>; <span class="comment">//出队标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i; i=edge[i].next) <span class="comment">//邻接表遍历，不多解释了（也可用vector代替）</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> v=edge[i].to; </span><br><span class="line">      <span class="keyword">if</span>(dis[v]&gt;dis[u]+edge[i].dis) <span class="comment">//如果有最短路就更改</span></span><br><span class="line">      &#123;</span><br><span class="line">        dis[v]=dis[u]+edge[i].dis;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]==<span class="number">0</span>) <span class="comment">//未入队则入队</span></span><br><span class="line">        &#123;</span><br><span class="line">          vis[v]=<span class="number">1</span>; <span class="comment">//标记入队</span></span><br><span class="line">          q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">num_edge=<span class="number">0</span>;</span><br><span class="line">mp.erase(mp.begin(),mp.end());</span><br><span class="line"><span class="built_in">memset</span>(head,<span class="number">0</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0</span>,<span class="keyword">sizeof</span>(edge));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;m)</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">string</span> a,end,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;end;</span><br><span class="line">mp[a]=<span class="number">1</span>;</span><br><span class="line">  s=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">int</span> w;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line"><span class="keyword">if</span>(mp[a]==<span class="number">0</span>)</span><br><span class="line">mp[a]=++cnt;</span><br><span class="line"><span class="keyword">if</span>(mp[b]==<span class="number">0</span>)</span><br><span class="line">mp[b]=++cnt; </span><br><span class="line">    addedge(mp[a],mp[b],w); <span class="comment">//建图，有向图连一次边就可以了</span></span><br><span class="line">    addedge(mp[b],mp[a],w);</span><br><span class="line">  &#125;</span><br><span class="line">  n=cnt;</span><br><span class="line">   spfa(); <span class="comment">//开始跑spfa</span></span><br><span class="line">   <span class="keyword">if</span>(mp[end]==<span class="number">0</span>||dis[mp[end]]==inf)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"-1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;dis[mp[end]]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//否则打印最短距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/381143#problem&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;比赛链接：&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
    
    </summary>
    
    
      <category term="一起开心" scheme="http://Jozky.top/categories/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83/"/>
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83/%E6%AF%94%E8%B5%9B/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模板" scheme="http://Jozky.top/categories/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83/%E6%AF%94%E8%B5%9B/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="图论" scheme="http://Jozky.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>二分图匹配--匈牙利算法</title>
    <link href="http://jozky.top/2020/07/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://jozky.top/2020/07/11/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-11T11:28:39.000Z</published>
    <updated>2020-07-11T11:42:51.840Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><h2 id="二分图："><a href="#二分图：" class="headerlink" title="二分图："></a>二分图：</h2><p>二分图是一个无向图，点集分成子集X和Y，图中每一条边都是一边在X一边在Y<br>当且仅当无向图G的每一个回路次数都是偶数时（包括0），G就是一个二分图</p><a id="more"></a><p><img src="https://uploadfiles.nowcoder.com/files/20200711/543071257_1594440096071_20200711112506406.png" alt="在这里插入图片描述"></p><h2 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h2><p>介绍完二分图后我们看看匹配<br>匹配：如果任意两个边的端点都不相同，我们就称之为匹配。匹配是边的集合<br>最大匹配：所含匹配边数最多的匹配<br>完美匹配：在一次匹配中，所有的顶点都是匹配点<br>完美匹配一定是最大匹配，但是反过来不一定</p><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>以上讲的均为离散知识，现在开始讲算法<br>交替路：从一个未匹配点开始，按照非匹配边，匹配边，非匹配边。。。。这样的顺序形成的路径<br>增广路：从一个未匹配点开始，走交替路，如果途中经过另一个未匹配点，则这条交替路叫做增广路<br>增广路特点：非匹配边比匹配边多一条<br>算法核心就是寻找增广路径，直到没有<br>匈牙利算法寻找最大匹配，就是通过不断寻找原有匹配M的增广路径，因为找到一条M匹配的增广路径，就意味着一个更大的匹配M ‘ ，其恰好比M多一条边。这样不断更新，找不到就是最大情况<br>过程：<br>一开始随便选一个未匹配点，先是匹配（x1,y1），标记，然后给x2匹配，匹配（x2，y2），这样就形成匹配M，有两条边，目前没问题<br>然后x3匹配，发现y1已经被x1抢占了，然后x3横刀夺爱抢走y1，x1悲恨交加只能找下一个，然后把x2的对象y2也抢了，x2也只能顺位找y5，（这是个递归的过程，直到匹配到未被抢占的）,这就形成匹配M1<br>刚才的争执过程（x3,y1,x1,y2,x2,y5）,这就是匹配M的增广路<br>发现增广路就说明有更优的情况，所以我们由匹配M扩展到现在的M1<br>然后将x4加入，一次类推<br>如果争执过程中，最后一个人没找到对象怎么办？那也没事，反正整体的数量不会亏<br><img src="https://uploadfiles.nowcoder.com/files/20200711/543071257_1594440094213_20200711114942501.png" alt="在这里插入图片描述"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>我珍藏多年的模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,e;</span><br><span class="line"><span class="keyword">int</span> Map[<span class="number">4000</span>][<span class="number">4000</span>];<span class="comment">//map[i][j]=1表示X部的i和Y部的j存在路径,是否可以匹配</span></span><br><span class="line"><span class="keyword">int</span> cx[maxn], cy[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//cx[i]表示X部i点匹配的Y部顶点的编号</span></span><br><span class="line"><span class="comment">//cy[i]表示Y部i点匹配的X部顶点的编号</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span><span class="comment">//dfs进入的都是X部的点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= m; v++)<span class="comment">//枚举Y部的点，判断X部的u和Y部的v是否存在路径</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果存在路径并且还没被标记加入增广路</span></span><br><span class="line"><span class="keyword">if</span> (Map[u][v] &amp;&amp; !vis[v])<span class="comment">//vis数组只标记Y组</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//标记加入增广路</span></span><br><span class="line">vis[v] = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//如果Y部的点v还未被匹配</span></span><br><span class="line"><span class="comment">//或者已经被匹配了，但是可以从v点原来匹配的cy[v]找到一条增广路</span></span><br><span class="line"><span class="comment">//说明这条路就可是一个正确的匹配</span></span><br><span class="line"><span class="comment">//因为递归第一次进入dfs时，u是未匹配的</span></span><br><span class="line"><span class="comment">//如果v还没有匹配对象，即和它相连的所有边都不在，已经选择的匹配边集合M（M\in E）中，这时就找到了u-v增广路径</span></span><br><span class="line"><span class="comment">//如果v已经有匹配对象了，那么u-v是一条未选择的边，</span></span><br><span class="line"><span class="comment">//而v-cy[v] \in M 则是一条已经选择的边, dfs(cy[v])从cy[v]开始搜索增广路径</span></span><br><span class="line"><span class="comment">//如果新的v'没有匹配对象，那么u-v-cy[v]-v'就是一条增广路径，</span></span><br><span class="line"><span class="comment">//如果v'已经有匹配对象了，那么根据匹配是唯一的，</span></span><br><span class="line"><span class="comment">//cy[v]-v'一定不在已经选择的边中(和cy[v]-v冲突)，</span></span><br><span class="line"><span class="comment">//u-v-cy[v]-v'-cy[v']符合增广路径对边顺序的要求，继续利用dfs(cy[v'])搜索u-v-cy[v]-v'-cy[v']-下面的点</span></span><br><span class="line"><span class="comment">//当搜索到增广链时，如u-v-cy[v]-v',那么经过递归的匹配调整和return 1，进行匹配增广操作，假设dfs0 是main调用的dfs算法，dfs1是dfs0调用的dfs算法</span></span><br><span class="line"><span class="comment">//在dfs1中进行cy[v]-v'的匹配，因为dfs1返回1，因此在dfs0中进行u-v的匹配，匹配增广操作的结果是&#123;cy[v]-v&#125;-&gt;&#123;u-v,cy[v]-v'&#125;</span></span><br><span class="line"><span class="comment">//如果在一个dfs(k)自调用的dfs(k+1)中，遍历所有的v(k+1),要么已经有匹配点了，要么和输入u(k+1)没有连接可能，这时搜索终止，说明不存在经过u(k+1)的增广链，返回0</span></span><br><span class="line"><span class="comment">//而在main调用的dfs(0)中，调用的dfs(1)返回的都是0，而且v都是已经有匹配了，那么不存在从该点出发的增广链，那么就该点就不在最大匹配当中</span></span><br><span class="line"><span class="comment">//为什么找不到增广链就不在最大匹配当中呢？感觉可以用反证法证明，博客中下面内容可能有更新这方面的思考</span></span><br><span class="line"><span class="keyword">if</span> (cy[v] == <span class="number">-1</span> || dfs(cy[v]))</span><br><span class="line">&#123;</span><br><span class="line">cx[u] = v;<span class="comment">//可以匹配，进行匹配</span></span><br><span class="line">cy[v] = u;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//不能匹配</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxmatch</span><span class="params">()</span><span class="comment">//匈牙利算法主函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//匹配清空，全部置为-1</span></span><br><span class="line"><span class="built_in">memset</span>(cx, <span class="number">-1</span>, <span class="keyword">sizeof</span>(cx));</span><br><span class="line"><span class="built_in">memset</span>(cy, <span class="number">-1</span>, <span class="keyword">sizeof</span>(cy));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cx[i] == <span class="number">-1</span>)<span class="comment">//如果X部的i还未匹配</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));<span class="comment">//每次找增广路的时候清空vis</span></span><br><span class="line">ans += dfs(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输入匹配的两个点集合的数量</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m&gt;&gt;e;</span><br><span class="line"><span class="comment">//输入两个点集合成员间的匹配可能</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">Map[x][y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行匈牙利算法，输出最大匹配</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; maxmatch() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6 7 12</span></span><br><span class="line"><span class="comment">1 1</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">3 1</span></span><br><span class="line"><span class="comment">3 7</span></span><br><span class="line"><span class="comment">3 4</span></span><br><span class="line"><span class="comment">4 3</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">4 6</span></span><br><span class="line"><span class="comment">5 4</span></span><br><span class="line"><span class="comment">6 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;二分图：&quot;&gt;&lt;a href=&quot;#二分图：&quot; class=&quot;headerlink&quot; title=&quot;二分图：&quot;&gt;&lt;/a&gt;二分图：&lt;/h2&gt;&lt;p&gt;二分图是一个无向图，点集分成子集X和Y，图中每一条边都是一边在X一边在Y&lt;br&gt;当且仅当无向图G的每一个回路次数都是偶数时（包括0），G就是一个二分图&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="二分图匹配" scheme="http://Jozky.top/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
      <category term="匈牙利算法" scheme="http://Jozky.top/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网 【每日一题】7月9日题目 Color</title>
    <link href="http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE-Color/"/>
    <id>http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE-Color/</id>
    <published>2020-07-11T11:28:31.000Z</published>
    <updated>2020-07-11T11:44:52.661Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/14254" target="_blank" rel="noopener">来源：牛客网：</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">131072</span>K，其他语言<span class="number">262144</span>K</span><br><span class="line">Special Judge, <span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><p>@[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给一个没有重边的二分图, 要求给边染色. 有公共点的边不能同色. 问最少用多少种颜色, 并任意构造一组方案.  输入描述:<br>第一行两个数n和m表示图的点数和边数(0&lt;n&lt;1001,0&lt;m&lt;2001). 之后m行每行2个数表示一条边的两个端点. 点从1编号到n.<br>保证给的是二分图.</p></blockquote><a id="more"></a><p><strong>输出描述:</strong></p><blockquote><p>第一行一个数k表示需要多少种颜色. 接下来m行每行一个数表示输入的边的颜色. 按照输入的顺序输出, 颜色从1编号到k.</p></blockquote><p>示例1<br><strong>输入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>题目要求有公共点的边不能同色，最后要求最少的颜色数<br>所以有公共点的边我们就让他同色<br>二分图匹配：给定一个二分图G，在G的一个子图M中，M的边集{E}中的任意两条边都不依附于同一个顶点，则称M是一个匹配。（也就是匹配出没有共同点的边）<br>边数最大的子图就是最大匹配<br>所以我们可以多次调用二分图最大匹配（比如匈牙利算法），为每次匹配出来的边附上色，直到全部匹配<br>但是有的边可能在多次最大匹配中都可以被匹配上，怎么保证最优呢？<br>根据题意，每个点所连的边颜色各不相同，所以答案就是度数最大的那个点，所以每次匹配有限从度数大的开始匹配<br>具体为什么从最大度下手？可以从反证法，假设从最小度开始匹配会怎么样。也可以看看<a href="https://ac.nowcoder.com/discuss/448422" target="_blank" rel="noopener">官方解释</a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">9</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];<span class="comment">//点i的度数 </span></span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn];</span><br><span class="line"><span class="keyword">int</span> id[maxn],col[<span class="number">1040</span>][<span class="number">1040</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;g[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> match[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> d[x]&gt;d[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v:g[u])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])</span><br><span class="line">&#123;</span><br><span class="line">vis[v]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(match[v]==<span class="number">0</span>||dfs(match[v]))</span><br><span class="line">&#123;</span><br><span class="line">match[v]=u;</span><br><span class="line">match[u]=v;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(match,<span class="number">0</span>,<span class="keyword">sizeof</span>(match));</span><br><span class="line">sort(id+<span class="number">1</span>,id+<span class="number">1</span>+n,cmp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">d[x[i]]++;</span><br><span class="line">d[y[i]]++;</span><br><span class="line">ans=max(ans,max(d[x[i]],d[y[i]]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)id[i]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ans;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line"><span class="keyword">if</span>(!col[x[j]][y[j]])<span class="comment">//该边还未被标记 </span></span><br><span class="line">&#123;</span><br><span class="line">g[x[j]].push_back(y[j]);<span class="comment">//存边 </span></span><br><span class="line">g[y[j]].push_back(x[j]);</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>,k=id[j];j&lt;=n;j++,k=id[j])<span class="comment">//从度数最大的开始下手 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!match[k]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">dfs(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//对每一次最大匹配进行染色 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(match[j])<span class="comment">//如果j已经匹配 </span></span><br><span class="line">&#123;</span><br><span class="line">col[j][match[j]]=i;<span class="comment">//染上色 </span></span><br><span class="line">d[j]--;</span><br><span class="line">&#125;</span><br><span class="line">g[j].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;col[x[i]][y[i]]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14254&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;131072&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;262144&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Special Judge, &lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给一个没有重边的二分图, 要求给边染色. 有公共点的边不能同色. 问最少用多少种颜色, 并任意构造一组方案.  输入描述:&lt;br&gt;第一行两个数n和m表示图的点数和边数(0&amp;lt;n&amp;lt;1001,0&amp;lt;m&amp;lt;2001). 之后m行每行2个数表示一条边的两个端点. 点从1编号到n.&lt;br&gt;保证给的是二分图.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="二分图匹配" scheme="http://Jozky.top/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
    
      <category term="匈牙利算法" scheme="http://Jozky.top/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】7月8日 Alliances</title>
    <link href="http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%888%E6%97%A5-Alliances/"/>
    <id>http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%888%E6%97%A5-Alliances/</id>
    <published>2020-07-11T11:28:01.000Z</published>
    <updated>2020-07-11T11:48:31.170Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13950" target="_blank" rel="noopener">来源：牛客网</a><br>@[toc]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">5</span>秒，其他语言<span class="number">10</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">262144</span>K，其他语言<span class="number">524288</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>树国是一个有n个城市的国家，城市编号为1∼n。连接这些城市的道路网络形如一棵树，<br>即任意两个城市之间有恰好一条路径。</p></blockquote><a id="more"></a><blockquote><p>城市中有k个帮派，编号为1∼k。每个帮派会占据一些城市，以进行非法交易。有时帮派之间会结盟，这就使得城市更加不安全了。同一座城市中可能有多个帮派。<br>当一些帮派结成联盟时，他们会更加强大，同时也更加危险。他们所控制的城市数会显著增加。具体地，一个联盟控制的城市是联盟中所有帮派所占据的城市，再加上这些城市两两之间路径上的所有城市。<br>shy是树国的市长，他想要选择一个城市作为首都。在决定之前，他要先做一些调研。为此，他找来你帮他回答一些询问，你能做到吗？在每个询问中，shy会选择一个城市作为首都，同时会告诉你当前活跃的帮派的集合。在这个询问中，你只需要考虑给定的集合中的帮派，其他的帮派你可以当作不存在。已知给定集合中的这些帮派结成了联盟，shy希望抓获联盟中的人，以得到关于整个联盟的一些信息。为此，他要找到被联盟控制的所有城市中离首都最近的一座城市到首都的距离。有可能首都本身就被控制了，此时答案为0。请注意，询问之间相互独立，互不影响。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>输入的第一行包含一个整数n，代表树国中的城市数。  接下来n−1行，每行包含两个整数u和v，代表城市u和v之间存在一条道路。<br>接下来一行包含一个整数k，代表树国中的帮派数。<br>接下来k行，每行描述一个帮派。第i行的第一个整数c[i]代表第i个帮派占据的城市数，接下来c[i]个整数，代表被第i个帮派占据的城市。<br>接下来一行包含一个整数Q，代表询问数。<br>接下来Q行，每行描述一个询问。每行的前两个整数V和t[i]代表本次询问中的首都与需要考虑的帮派集合的大小。接下来t[i]个整数代表本次询问中需要考虑的帮派。.</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>对于每个询问，输出一行，包含一个整数，代表询问的答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>备注:</p><blockquote><p>对于30%的数据，1≤n,k,Q≤1000, 1≤每个帮派占据城市数之和≤1000, 1≤每个询问中考虑的帮派数之和≤1000  </p></blockquote><blockquote><p>对于60%的数据，1≤n,k,Q≤100000, 1≤每个帮派占据城市数之和≤100000, 1≤每个询问中考虑的帮派数之和≤100000</p></blockquote><blockquote><p>对于100%的数据，1≤n,k,Q≤500000, 1≤每个帮派占据城市数之和≤500000, 1≤每个询问中考虑的帮派数之和≤500000</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>第一反应lca，<del>最近好多lca的题</del><br>题目本质就是求一个点（即题目中的首都）到lca（x,y）上的点（即被控制的城市）的最短路径<br>被控制的城市其实就形成了一个子树<br>分情况讨论：<br>1.城市不在被控制的子树里面（如图）<br>紫色是城市，橙色是被控制子树，那距离就是首都到子树的距离<br>sum=dep[首都]+dep[lca(城市x)]-dep[lca(城市x，首都)]<br>城市x就是lca（x,y）的值(x和y就是题目所给的帮派)<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302157028_20200709165342620.png" alt="在这里插入图片描述"><br>2.首都被控制<br>首都被控制分为直接控制（帮派点为首都）<br>或间接控制（首都在帮派之间的线路上）<br>那距离就是0</p><p><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302154981_20200709165347695.png" alt="在这里插入图片描述"><br>3.首都没被控制，但是首都在被控制的子树中<br>（首都的前驱被控制，后继没被控制）<br>对于这种情况我们就要找首都的的前驱后继点，这样好判断距离<br>可以用dfs序，因为dfs序就保存着各个点的顺序<br>然后可以用二分来降低复杂度<br>如果首都到LCA的路径上存在一个点x（x被占领），x！=lca，那么答案就是首都到最近一个符合这个条件的点<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594302157049_20200709165408484.png" alt="在这里插入图片描述"><br><a href="https://blog.csdn.net/qq_35975367/article/details/105461878" target="_blank" rel="noopener">lca详细讲解</a><br><a href="https://blog.csdn.net/qq_35975367/article/details/105369244" target="_blank" rel="noopener">dfs序详细讲解</a><br>为什么这些知识点我都会，但是我就不会做题。。哭o(╥﹏╥)o</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>写完再加上。。。（最近有点懒）</p><hr><p>好吧我放弃了，写完一直改，一直wa，难受自闭了<br><a href="https://blog.nowcoder.net/n/fe24264bae7d4673a3eb143cd3039c2d" target="_blank" rel="noopener">借鉴的大佬的代码</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_N=<span class="number">1e6</span>+<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> DEG=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> LL MOD=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="comment">//链式前向星村边</span></span><br><span class="line"><span class="keyword">int</span> head[MAX_N],tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;edge[MAX_N*<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].nxt=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//求LCA</span></span><br><span class="line"><span class="keyword">int</span> fa[MAX_N][DEG];</span><br><span class="line"><span class="keyword">int</span> deg[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;que;</span><br><span class="line">    deg[root]=<span class="number">0</span>;</span><br><span class="line">    fa[root][<span class="number">0</span>]=root;</span><br><span class="line">    que.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;DEG;i++)&#123;</span><br><span class="line">            fa[tmp][i]=fa[fa[tmp][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[tmp];i!=<span class="number">-1</span>;i=edge[i].nxt)&#123;</span><br><span class="line">            <span class="keyword">int</span> v=edge[i].to;</span><br><span class="line">            <span class="keyword">if</span>(v==fa[tmp][<span class="number">0</span>])<span class="keyword">continue</span>;</span><br><span class="line">            deg[v]=deg[tmp]+<span class="number">1</span>;</span><br><span class="line">            fa[v][<span class="number">0</span>]=tmp;</span><br><span class="line">            que.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(deg[u]&gt;deg[v])swap(u,v);</span><br><span class="line">    <span class="keyword">int</span> hu=deg[u],hv=deg[v];</span><br><span class="line">    <span class="keyword">int</span> tu=u,tv=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> det=hv-hu,i=<span class="number">0</span>;det;det&gt;&gt;=<span class="number">1</span>,i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(det&amp;<span class="number">1</span>)tv=fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tu==tv)<span class="keyword">return</span> tu;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=DEG<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[tu][i]==fa[tv][i])<span class="keyword">continue</span>;</span><br><span class="line">        tu=fa[tu][i];</span><br><span class="line">        tv=fa[tv][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[tu][<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求DFS序</span></span><br><span class="line"><span class="keyword">int</span> dfsn[MAX_N];</span><br><span class="line"><span class="keyword">int</span> pos[MAX_N];</span><br><span class="line"><span class="keyword">int</span> dfst=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    dfsn[v]=++dfst;</span><br><span class="line">    pos[dfst]=v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[v];i!=<span class="number">-1</span>;i=edge[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[i].to;</span><br><span class="line">        <span class="keyword">if</span>(u==fa)<span class="keyword">continue</span>;</span><br><span class="line">        DFS(u,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=deg[u]+deg[v]<span class="number">-2</span>*deg[LCA(u,v)];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lc存每一个帮派的LCA</span></span><br><span class="line"><span class="comment">//g存每一个帮派的DFS序</span></span><br><span class="line"><span class="keyword">int</span> lc[MAX_N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAX_N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t[MAX_N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     init();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        addedge(u,v);</span><br><span class="line">        addedge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(<span class="number">1</span>);</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> c,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;c);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)lc[i]=x;</span><br><span class="line">            <span class="keyword">else</span> lc[i]=LCA(lc[i],x);</span><br><span class="line">            g[i].push_back(dfsn[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(g[i].begin(),g[i].end());</span><br><span class="line">        <span class="comment">//cout&lt;&lt;lc[i]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"****"&lt;&lt;endl;</span></span><br><span class="line">      <span class="keyword">int</span> q,u,cnt;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;cnt);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lca=lc[t[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)lca=LCA(lca,lc[t[i]]);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(LCA(lca,u)!=lca)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis(lca,u));</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp=t[i];</span><br><span class="line">            <span class="keyword">auto</span> p=lower_bound(g[tmp].begin(),g[tmp].end(),dfsn[u]);</span><br><span class="line">            <span class="keyword">if</span>(p!=g[tmp].end())&#123;</span><br><span class="line">                ans=min(ans,dis(u,LCA(u,pos[*p])));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p!=g[tmp].begin())&#123;</span><br><span class="line">                ans=min(ans,dis(u,LCA(u,pos[*prev(p)])));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13950&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;262144&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;524288&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;树国是一个有n个城市的国家，城市编号为1∼n。连接这些城市的道路网络形如一棵树，&lt;br&gt;即任意两个城市之间有恰好一条路径。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dfs序" scheme="http://Jozky.top/tags/dfs%E5%BA%8F/"/>
    
      <category term="lca" scheme="http://Jozky.top/tags/lca/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月7日题目精讲-最短路</title>
    <link href="http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%887%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%887%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%9C%80%E7%9F%AD%E8%B7%AF/</id>
    <published>2020-07-11T11:27:54.000Z</published>
    <updated>2020-07-11T11:47:38.178Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19814" target="_blank" rel="noopener">来源：牛客网：</a><br>@[toc]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给一个连通图，每次询问两点间最短路。每条边的长度都是1。 输入描述: 第一行两个整数n和m，表示图的点数和边数（1≤ n≤ 100000,<br>1≤ m≤ n+100）。 接下来m行每行两个整数a和b，表示一条边（1≤ a, b≤ n）。保证没有自环和重边。保证图连通。<br>接下来一个整数q表示询问的个数（1≤ q≤ 100000）。 接下来q行每行两个整数a和b表示询问a和b之间的最短路。</p></blockquote><a id="more"></a><p><strong>输出描述:</strong></p><blockquote><p>每个询问输出一行表示答案。</p></blockquote><p>示例1<br><strong>输入</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><del>我看了别人的讲解才逐渐明白。。我太菜了</del><br>题目是最短路，题目内容也是最短路，但是解法却不是常用的spfa等，因为询问的个数有点多（1 ~ 100000）<br>我们仔细看数据范围，m&lt;n+100,什么意思？想想m = n-1时是一棵树，那我们就可以把他当做树处理，然后剩下的边再慢慢干<br>如果当做一棵树的话，边长为1，求最短路径，我们就可以通过最近公共祖先（lca）得到两点的最近距离，dep[a]+dep[b] - 2<em>dep [ lca(a, b) ] (a的深度+b的深度，然后a和b有重复的部分，减去重复的部分)<br>然后我们看看多出来的100个边，会对结果有什么影响？<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594279390052_20200709143940363.png" alt="在这里插入图片描述"><br>蓝色是原本的树，橙色，绿色是多出来的边<br>如果是橙色，对结果没有影响，如果是绿色会有影响<br>那么该如何处理？<br>我们可以把剩下多出来的边跑单元最短路（以这些边的一个端点开始）并记录下来<br>然后与原路径进行比较<br>a到b的最小距离就在dep[a] +dep[b]-2</em>dep[ lca(a,b) ]与dis[a[i]]+dis[b[i]]中取最小值<br>不知道有没有听明白，我拿样例做个分析：<br>我们看一下样例，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>多余的边是：1-2 , 4-3,<br><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594279390425_20200709151000526.png" alt="在这里插入图片描述"><br>ans最开始的值就是树上的lca<br>ans={1,2,1,3}<br>然后开始跑1-2这个边，从1这个点开始，计算出1到个点的距离<br>dis={0,1,2,1}<br>然后更新最短距离：<br>ans[i] = min(ans[i], dis[a[i]] + dis[b[i]]);<br>a和b分别表示询问中a和b的距离<br>a[2]=1,b[2]=2<br>dis[a[2]]+dis[b[2]]=0+1=1&lt;ans[2]<br>所以ans[2]=1<br>大致就是这个过程</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p><a href="https://blog.nowcoder.net/n/7353e7a20a194775bb5e50669deb2b18" target="_blank" rel="noopener">代码来自</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) (x).begin(), (x).end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">'\n'</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ(x) (int)x.size()</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll, ll&gt; pll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="comment">//const int mod = 998244353;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> ll inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dir[][<span class="number">2</span>]=&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, depth[maxn], f[maxn][<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> from[maxn], to[maxn &lt;&lt; <span class="number">1</span>], nxt[maxn &lt;&lt; <span class="number">1</span>], cnt = <span class="number">1</span>, Log[maxn], From[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn], used[maxn];</span><br><span class="line"><span class="comment">//链式前向星加边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    From[++cnt] = u, to[cnt] = v, nxt[cnt] = from[u], from[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算深度&amp;计算祖先</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[fa] + <span class="number">1</span>;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Log[n]; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; i) &gt; depth[u]) <span class="keyword">break</span>;</span><br><span class="line">        f[u][i] =  f[f[u][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = from[u]; i; i = nxt[i]) &#123;</span><br><span class="line">        ll v = to[i];</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        used[i] = used[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        f[v][<span class="number">0</span>] = u;</span><br><span class="line">        dfs (v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算LCA</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span> <span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[x] &lt; depth[y]) swap(x, y);</span><br><span class="line">    <span class="comment">//我们默认x为更深的那个点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i = Log[n] ; i &gt;= <span class="number">0</span> ; --i)</span><br><span class="line">        <span class="keyword">if</span>(depth[x] - (<span class="number">1</span> &lt;&lt; i) &gt;= depth[y]) x = f[x][i];</span><br><span class="line">    <span class="comment">//将x跳到和y同一深度上</span></span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = Log[n]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (f[x][i] != f[y][i])</span><br><span class="line">            x = f[x][i], y = f[y][i];</span><br><span class="line">    <span class="comment">//一起向上跳</span></span><br><span class="line">    <span class="keyword">return</span> f[x][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//不难看出，此时两个点均在其LCA的下方，往上跳一次即可</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Log[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addEdge (u, v); addEdge(v, u);</span><br><span class="line">        Log[i] = Log[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log[n] = Log[n &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> p , <span class="keyword">int</span> q)</span></span>&#123;<span class="keyword">return</span> depth[p] + depth[q] - <span class="number">2</span> * depth[LCA(p , q)];&#125;</span><br><span class="line"><span class="keyword">int</span> ans[maxn],a[maxn],b[maxn],dis[maxn], Q, q[maxn], h, t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)dis[i] = inf;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    h = t = <span class="number">0</span>;</span><br><span class="line">    q[++h] = s;</span><br><span class="line">    <span class="keyword">while</span> (t &lt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q[++t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = from[u]; i; i = nxt[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> v = to[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + <span class="number">1</span>)</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>, q[++h] = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">        ans[i] = min(ans[i], dis[a[i]] + dis[b[i]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//  freopen("in.txt", "r", stdin);</span></span><br><span class="line"><span class="comment">//  freopen("out.txt", "w", stdout);</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">        ans[i] = dist(a[i], b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; i++)</span><br><span class="line">        <span class="keyword">if</span>(!used[i]) &#123;</span><br><span class="line">            used[i] = used[i ^ <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            bfs(From[i]);</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; <span class="number">101</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19814&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1048576&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;2097152&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给一个连通图，每次询问两点间最短路。每条边的长度都是1。 输入描述: 第一行两个整数n和m，表示图的点数和边数（1≤ n≤ 100000,&lt;br&gt;1≤ m≤ n+100）。 接下来m行每行两个整数a和b，表示一条边（1≤ a, b≤ n）。保证没有自环和重边。保证图连通。&lt;br&gt;接下来一个整数q表示询问的个数（1≤ q≤ 100000）。 接下来q行每行两个整数a和b表示询问a和b之间的最短路。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="LCA" scheme="http://Jozky.top/tags/LCA/"/>
    
      <category term="图论" scheme="http://Jozky.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月6日精讲-平衡二叉树</title>
    <link href="http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%886%E6%97%A5%E7%B2%BE%E8%AE%B2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%886%E6%97%A5%E7%B2%BE%E8%AE%B2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2020-07-11T11:27:44.000Z</published>
    <updated>2020-07-11T11:46:47.028Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/19775" target="_blank" rel="noopener">来源：牛客网：</a><br>@[toc]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>平衡二叉树，顾名思义就是一棵“平衡”的二叉树。在这道题中，“平衡”的定义为，对于树中任意一个节点，都满足左右子树的高度差不超过 d.</p></blockquote><a id="more"></a><blockquote><p>空树的高度定义为0，单个节点的高度为1，其他情况下树的高度定义为根节点左右子树高度最大值 + 1.<br>一棵在高度上平衡的树，节点数可能不平衡，因此再定义一棵树的不平衡度为这棵树中所有节点的左右子树的节点数之差的最大值。 给定平衡的定义参数d,<br>你需要求出所有高度为 n 的平衡树中不平衡度的最大值。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>两个整数，n, d.</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>一个整数：所有高度为 n 的平衡树中不平衡度的最大值。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><blockquote><p>下面这棵树在 d=1 的定义下高度是平衡的，其不平衡度为 5。</p></blockquote><p><img src="https://uploadfiles.nowcoder.com/files/20200709/543071257_1594268527449_2020070912062399.png" alt="在这里插入图片描述"></p><p>备注:</p><blockquote><p>0 ≤ n, d ≤ 60</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>不平衡度为这棵树中所有节点的左右子树的节点数之差的最大值<br>那我们要让不平衡度最大就要尽可能使左右子树差最大，左子树尽可能多，右子树尽可能少<br>左子树尽可能多的话我们可以直接给拉满，也就是满二叉树节点就是pow(2,n-1),n为整个树的高度，n-1为左子树的高度<br>右子树尽可能少，那深度就尽可能浅，但因为有题目左右子树的高度差不超过 d的限制，所以右子树的深度就是m=n-1-d。然后右子树也是有左右子子树，同样的道理<br>我们定义dp[i]表示深度为i的子树最少总节点个数<br>当前的树高是i，满足题意就是建一颗高度为i-1的左子树和一颗h-d-1的右子树<br>能得到转移方程：dp[i]=dp[i-1]+dp[i-d-1]+1<br>这个+1就是+根<br>我们要求最大的不平衡度<br>最后用满左子树 -（高度为n-d-1的右子树）- 1</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e3</span>+<span class="number">4</span>;</span><br><span class="line">ll dp[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,d;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d;</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)<span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>, <span class="number">0</span>;</span><br><span class="line">sum=(<span class="number">1l</span>l&lt;&lt;(n<span class="number">-1</span>)); </span><br><span class="line">dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n-d<span class="number">-1</span>;i++)&#123;</span><br><span class="line">dp[i]=dp[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(i-d<span class="number">-1</span>&gt;=<span class="number">0</span>)dp[i]+=dp[i-d<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum-dp[n-d<span class="number">-1</span>]<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/19775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网：&lt;/a&gt;&lt;br&gt;@[toc]&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1048576&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;2097152&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;平衡二叉树，顾名思义就是一棵“平衡”的二叉树。在这道题中，“平衡”的定义为，对于树中任意一个节点，都满足左右子树的高度差不超过 d.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】7月3日精讲-毒瘤xor</title>
    <link href="http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%883%E6%97%A5%E7%B2%BE%E8%AE%B2-%E6%AF%92%E7%98%A4xor/"/>
    <id>http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%883%E6%97%A5%E7%B2%BE%E8%AE%B2-%E6%AF%92%E7%98%A4xor/</id>
    <published>2020-07-11T11:27:30.000Z</published>
    <updated>2020-07-11T11:45:55.549Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18979" target="_blank" rel="noopener">【每日一题】7月3日精讲—毒瘤xor</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">32768</span>K，其他语言<span class="number">65536</span>K</span><br><span class="line">Special Judge, <span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><p>@[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="https://uploadfiles.nowcoder.com/files/20200708/543071257_1594194323314_20200708152132188.png" alt="在这里插入图片描述"></p><a id="more"></a><p><strong>输入描述:</strong></p><blockquote><p>第一行一个整数N，表示序列的长度 第二行N个整数，表示序列内的元素 第三行一个整数q，表示询问的个数 接下来q行，每行两个整数[L,<br>R]，表示询问的区间</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>输出q行，每行一个整数表示答案</p><p>若有多组可行解，请输出较小的解</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> </span><br><span class="line"><span class="number">4</span> <span class="number">78</span> <span class="number">12</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2147483632</span></span><br><span class="line"><span class="number">2147483635</span></span><br><span class="line"><span class="number">2147483635</span></span><br></pre></td></tr></table></figure><p>备注:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于<span class="number">30</span>%的数据，n , q ≤ <span class="number">10</span></span><br><span class="line">对于<span class="number">60</span>%的数据，n , q ≤ <span class="number">1000</span></span><br><span class="line">对于<span class="number">100</span>%的数据，n, q ≤ <span class="number">10</span>^<span class="number">5</span></span><br><span class="line">保证ai &lt; <span class="number">2</span>^<span class="number">31</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>很久没有遇到异或的题了<br>先讲下异或：1 ^ 1 =0 , 0 ^ 0= 0,1 ^ 0 =1,0 ^ 1 =1<br>相同为0，不同为1<br>异或是两个数二进制状态下相同数位进行操作<br>我们要找一个x使得x ^ a[i]的和最大，那我们就尽量使x与a[i]的相同位数异或后为1，这样就最大<br>a[i]是一个数组，所以我们就求这个数组里每个数的二进制状态下，每一位0和1的个数，比如说，数组有n个数，其中b个数二进制状态下第一位是0，剩下n-b个数二进制状态下第一位是1，如果b&gt;n-b,那我们就使X二进制的第一位是1，（就是和最多情况的数呈相反，这样异或出来才是1）<br>然后是第二位，依次类推最后我们就得到X的二进制状态，转化成十进制输出即可<br>因为有多轮询问，所以我们可以用前缀和来处理每一位为1的数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> w=((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);<span class="comment">//判断第j位是0是1 </span></span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+w);<span class="comment">//前缀和进行累加</span></span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">4</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[maxn];</span><br><span class="line"><span class="keyword">int</span> sum[maxn][<span class="number">40</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">bool</span> w=((a[i]&gt;&gt;j)&amp;<span class="number">1</span>);<span class="comment">//判断第j位是0是1 </span></span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> q;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[r][j]-sum[l<span class="number">-1</span>][j] &lt; ( (r-l)/<span class="number">2</span>+<span class="number">1</span>) )<span class="comment">//当这一位0居多时，X选为1 </span></span><br><span class="line">tot+=(<span class="number">1</span>&lt;&lt;j); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18979&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【每日一题】7月3日精讲—毒瘤xor&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;32768&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;65536&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Special Judge, &lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://uploadfiles.nowcoder.com/files/20200708/543071257_1594194323314_20200708152132188.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="前缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
      <category term="位运算" scheme="http://Jozky.top/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
      <category term="异或" scheme="http://Jozky.top/tags/%E5%BC%82%E6%88%96/"/>
    
  </entry>
  
  <entry>
    <title>牛客算法周周练14</title>
    <link href="http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%8314/"/>
    <id>http://jozky.top/2020/07/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%8314/</id>
    <published>2020-07-11T11:27:11.000Z</published>
    <updated>2020-07-11T11:40:45.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-友谊巨轮"><a href="#A-友谊巨轮" class="headerlink" title="A 友谊巨轮"></a>A 友谊巨轮</h2><h2 id="B-Circle"><a href="#B-Circle" class="headerlink" title="B Circle"></a>B Circle</h2><p>我们要找最大对数，相邻元素互质的对数其实就是n<br>因为互质说明最大公因数是1，而1与任何数a的最大公因数都是a，所以将n个数按照大小顺序首尾顺序佩列得到的互质的对数最多<br>也就是读入n输出n。。。</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Tree"><a href="#C-Tree" class="headerlink" title="C Tree"></a>C Tree</h2><h2 id="D-绝地求生-pubg"><a href="#D-绝地求生-pubg" class="headerlink" title="D 绝地求生(pubg)"></a>D 绝地求生(pubg)</h2><p>没错，你没有想错就是求最小公倍数<br>不过，我们求最小公倍数的公式是：x*y/gcd(x,y)<br>我们要先除后乘，如果x先乘y再除gcd，那就通不过了。。<br>可能是因为x和y可以取很大，乘后就更大了直接爆longlong，如果先除可以将数化小再运算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">ggcd</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b==<span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">return</span> ggcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=t;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll x,y;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="comment">//ll gcd=ggcd(x,y);</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %lld\n"</span>,i,x/ggcd(x,y)*y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-「水」悠悠碧波"><a href="#E-「水」悠悠碧波" class="headerlink" title="E 「水」悠悠碧波"></a>E 「水」悠悠碧波</h2><p>我看好多用kmp来做的，string里面本身就带着截取和查询，我们可以直接用<br>思路很简单：分别截取字符串头和尾相同的长度，比较是否相同，然后再从未截取的中间部分查询是否有截取部分，如果有记录截取片段，最后输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sum,a,a1,a2;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line"><span class="keyword">int</span> len=s.length();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=(len+<span class="number">1</span>)/<span class="number">2</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">a=s.substr(<span class="number">0</span>,i);<span class="comment">//头</span></span><br><span class="line">a1=s.substr(len-i,i);<span class="comment">//尾</span></span><br><span class="line">a2=s.substr(i,len-i*<span class="number">2</span>);<span class="comment">//未截取部分</span></span><br><span class="line"><span class="keyword">if</span>(a==a1&amp;&amp;a2.find(a)!=<span class="built_in">string</span>::npos)sum=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-友谊巨轮&quot;&gt;&lt;a href=&quot;#A-友谊巨轮&quot; class=&quot;headerlink&quot; title=&quot;A 友谊巨轮&quot;&gt;&lt;/a&gt;A 友谊巨轮&lt;/h2&gt;&lt;h2 id=&quot;B-Circle&quot;&gt;&lt;a href=&quot;#B-Circle&quot; class=&quot;headerlink&quot; title=&quot;B Circle&quot;&gt;&lt;/a&gt;B Circle&lt;/h2&gt;&lt;p&gt;我们要找最大对数，相邻元素互质的对数其实就是n&lt;br&gt;因为互质说明最大公因数是1，而1与任何数a的最大公因数都是a，所以将n个数按照大小顺序首尾顺序佩列得到的互质的对数最多&lt;br&gt;也就是读入n输出n。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>【每日一题】7月1日题目精讲 借教室</title>
    <link href="http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E5%80%9F%E6%95%99%E5%AE%A4/"/>
    <id>http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%917%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E5%80%9F%E6%95%99%E5%AE%A4/</id>
    <published>2020-07-11T11:26:46.000Z</published>
    <updated>2020-07-11T11:39:49.878Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/16564" target="_blank" rel="noopener">来源：牛客网</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">131072</span>K，其他语言<span class="number">262144</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><p>@[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。</p><p>   面对海量租借教室的信息，我们自然希望编程解决这个问题。</p></blockquote><a id="more"></a><blockquote><p>   我们需要处理接下来n天的借教室信息，其中第i天学校有ri个教室可供租借。共有m份订单，每份订单用三个正整数描述，分别为dj, sj,<br>tj，表示某租借者需要从第sj天到第tj天租借教室（包括第sj天和第tj天），每天需要租借dj个教室。</p><p>我们假定，租借者对教室的大小、地点没有要求。即对于每份订单，我们只需要每天提供dj个教室，而它们具体是哪些教室，每天是否是相同的教室则不用考虑。</p><p>借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第sj天到第tj天中有至少一天剩余的教室数量不足dj个。</p><p>   现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。</p></blockquote><p><strong>输入描述:</strong></p><blockquote><p>第一行包含两个正整数n, m，表示天数和订单的数量。</p><p>第二行包含n个正整数，其中第i个数为ri，表示第i天可用于租借的教室数量。</p><p>接下来有m行，每行包含三个正整数dj, sj, tj，表示租借的数量，租借开始、结束分别在第几天。</p><p>每行相邻的两个数之间均用一个空格隔开。天数与订单均用从1开始的整数编号。</p></blockquote><p><strong>输出描述:</strong></p><blockquote><p>如果所有订单均可满足，则输出只有一行，包含一个整数0。否则（订单无法完全满足）输出两行，第一行输出一个负整数-1，第二行输出需要修改订单的申请人编号。</p></blockquote><p>示例1<br><strong>输入</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong><br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>说明</strong><br>第1 份订单满足后，4 天剩余的教室数分别为0，3，2，3。<br>第2 份订单要求第2 天到第4 天每天提供3 个教室，而第3 天剩余的教室数为2，因此无法满足。分配停止，通知第2个申请人修改订单。<br><strong>备注:</strong></p><blockquote><p>对于10%的数据，有1≤n,m≤10； 对于30%的数据，有1≤n,m≤1000； 对于70%的数据，有1≤n,m≤105；<br>对于100%的数据，有1≤n, m≤106, 0≤ri, dj≤109, 1≤sj≤tj≤ n。</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>noip原题<br>第一反应线段树，不过线段树懒得打，我们用其他方法<br>差分+二分</p><h3 id="差分："><a href="#差分：" class="headerlink" title="差分："></a>差分：</h3><p>我们都知道前缀和，所谓差分简单理解就是前缀和的逆运算<br>前缀和：<br>其中数组a可以看做是相邻sum数组的差值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;<span class="built_in">cin</span>&gt;&gt;a[i];sum[i]=sum[i<span class="number">-1</span>]+a[i];&#125;</span><br></pre></td></tr></table></figure><p>差分：<br>差分就是给你相邻的差值，然后求出每一项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;<span class="built_in">cin</span>&gt;&gt;dif[i];a[i]=dif[i]+a[i<span class="number">-1</span>];&#125;</span><br></pre></td></tr></table></figure><p>前缀和是用元数据求元与元之间的并集关系，而差分则是根据元与元之间的逻辑关系求元数据，是互逆思想</p><h3 id="二分："><a href="#二分：" class="headerlink" title="二分："></a>二分：</h3><p>这个题为什么能用二分呢？<br>二分的条件：状态的决策过程或者序列是否满足单调性或者可以局部舍弃性<br>如果第x个订单无法满足，那x之后的就都不用看了，我们要找的答案就一定在x之前，如果x能满足，答案就在x之后，这不就是典型的二分吗？</p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dif[l[i]]+=d[i];</span><br><span class="line">dif[r[i]+<span class="number">1</span>]-=d[i];</span><br></pre></td></tr></table></figure><p>我们在读入时是 d l r，分别表示数量和时间范围<br>dif[x]+=d 可以理解为第x天之后（含第x天）的每天都需要数量为d的教室，为什么？看一下下面的代码，need[i]表示第i天的需求，need是由dif推导出来的，也就是dif[i]的结果会影响到第i天之后的每一个need,这样我们就可以通过改变dif来实现操作区间<br>但是我们数量d的范围是[l,r]，所以还要加一个dif[r[i]+1]-=d[i]，也就是第r+1天之后的数量减d，这样就和之前加d的影响给抵消了，最终效果只体现在区间[l,r]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">need[i]=need[i<span class="number">-1</span>]+dif[i];</span><br><span class="line"><span class="keyword">if</span>(need[i]&gt;a[i])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//供不应需 ，教室不够</span></span><br></pre></td></tr></table></figure><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> dif[maxn],need[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> d[maxn],l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isok</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dif,<span class="number">0</span>,<span class="keyword">sizeof</span>(dif));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x;i++)</span><br><span class="line">&#123;</span><br><span class="line">dif[l[i]]+=d[i];</span><br><span class="line">dif[r[i]+<span class="number">1</span>]-=d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">need[i]=need[i<span class="number">-1</span>]+dif[i];</span><br><span class="line"><span class="keyword">if</span>(need[i]&gt;a[i])<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//供不应需 ，教室不够 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)<span class="built_in">cin</span>&gt;&gt;d[i]&gt;&gt;l[i]&gt;&gt;r[i];</span><br><span class="line"><span class="keyword">int</span> l=<span class="number">1</span>,r=m;</span><br><span class="line"><span class="keyword">if</span>(isok(m))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>, <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(isok(mid))<span class="comment">//当前情况可以 </span></span><br><span class="line">l=mid+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="comment">//当前情况不可以</span></span><br><span class="line"> r=mid; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n%d"</span>,l);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/16564&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;131072&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;262144&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在大学期间，经常需要租借教室。大到院系举办活动，小到学习小组自习讨论，都需要向学校申请借教室。教室的大小功能不同，借教室人的身份不同，借教室的手续也不一样。&lt;/p&gt;
&lt;p&gt;   面对海量租借教室的信息，我们自然希望编程解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线段树" scheme="http://Jozky.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="差分" scheme="http://Jozky.top/tags/%E5%B7%AE%E5%88%86/"/>
    
      <category term="二分" scheme="http://Jozky.top/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="前缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】6月30日 Growth</title>
    <link href="http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%916%E6%9C%8830%E6%97%A5-Growth/"/>
    <id>http://jozky.top/2020/07/11/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%916%E6%9C%8830%E6%97%A5-Growth/</id>
    <published>2020-07-11T11:26:37.000Z</published>
    <updated>2020-07-11T11:39:53.046Z</updated>
    
    <content type="html"><![CDATA[<p><a href="%E7%89%9B%E5%AE%A2%E7%BD%91https://ac.nowcoder.com/acm/problem/19809">来源：</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">1048576</span>K，其他语言<span class="number">2097152</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><p>@[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。</p></blockquote><a id="more"></a><blockquote><p>为了激励弱弱努力学习，我们共有n种奖励，第i种奖励有xi，yi，zi三种属性，若a≥ xi且b≥<br>yi，则弱弱在接下来的每一天都可以得到zi的分数。 问m天以后弱弱最多能得到多少分数。 输入描述: 第一行一个两个整数n和m（1≤ n≤<br>1000，1≤ m≤ 2000000000）。 接下来n行，每行三个整数xi，yi，zi（1≤ xi,yi≤ 1000000000，1≤<br>zi ≤ 1000000）。</p></blockquote><p><strong>输出描述:</strong><br>一行一个整数表示答案。<br>示例1<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">50</span></span><br></pre></td></tr></table></figure><p>备注:</p><blockquote><p>在样例中，弱弱可以这样规划：第一天a涨1，第二天b涨1，第三天b涨1，第四天a涨1。 共获得0+0+20+30=50分。</p></blockquote><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>dp [ i ] [ j ]表示在sum = i+j天，两种属性分别是i和j所得到的分数（一共）<br>根据题意可得：<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]<br>a[i][j]表示属性分别是i和j可获得大分数（当天）<br>那a[i][j]是怎么得到的？<br>我们用二维前缀和的思想来实现：<br>a[ x<del>i</del> ][ x<del>j</del> ]=z<br>a[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1]<br>整合一下最后答案就是：<br>dp[i][j]=max(dp[i-1][j],dp[i][j-1])+a[i][j]<br>ans=max(ans,dp[i][j]+(m-i-j)*a[i][j])<br>如果我们在这一天可以获得a[][]的分数，那之后的每一天都可以获得，在此之后还有（m-i-j）天，所以直接加上这个分数在以后天数获得的总和<br>本题的xi，yi，m都比较大记得要先离散化。</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1400</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> x[maxn],y[maxn],z[maxn];</span><br><span class="line"><span class="keyword">int</span> b[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;x[i]&gt;&gt;y[i]&gt;&gt;z[i];</span><br><span class="line">b[i]=x[i];</span><br><span class="line">c[i]=y[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(b+<span class="number">1</span>,b+<span class="number">1</span>+n);</span><br><span class="line">sort(c+<span class="number">1</span>,c+<span class="number">1</span>+n);</span><br><span class="line"><span class="keyword">int</span> ant1=unique(b+<span class="number">1</span>,b+<span class="number">1</span>+n)-b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ant2=unique(c+<span class="number">1</span>,c+<span class="number">1</span>+n)-c<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">x[i] = lower_bound(b+<span class="number">1</span>,b+<span class="number">1</span>+ant1,x[i])-b;</span><br><span class="line">        y[i] = lower_bound(c+<span class="number">1</span>,c+<span class="number">1</span>+ant2,y[i])-c;</span><br><span class="line">        a[x[i]][y[i]] += z[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j]+=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>]-a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j]+(b[i]-b[i<span class="number">-1</span>]<span class="number">-1</span>)*a[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]+(c[j]-c[j<span class="number">-1</span>]<span class="number">-1</span>)*a[i][j<span class="number">-1</span>]) + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ant1;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=ant2;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]+c[i]&gt;m)<span class="keyword">break</span>;</span><br><span class="line">sum=max(sum,dp[i][j]+(m-b[i]-c[i])*a[i][j]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;%E7%89%9B%E5%AE%A2%E7%BD%91https://ac.nowcoder.com/acm/problem/19809&quot;&gt;来源：&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1048576&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;2097152&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;弱弱有两个属性a和b，这两个属性初始的时候均为0，每一天他可以通过努力，让a涨1点或b涨1点。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="离散化" scheme="http://Jozky.top/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一起开心暑假集训第一周限时训练 2020/7/5</title>
    <link href="http://jozky.top/2020/07/05/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%AC%AC%E4%B8%80%E5%91%A8%E9%99%90%E6%97%B6%E8%AE%AD%E7%BB%83-2020-7-5/"/>
    <id>http://jozky.top/2020/07/05/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E7%AC%AC%E4%B8%80%E5%91%A8%E9%99%90%E6%97%B6%E8%AE%AD%E7%BB%83-2020-7-5/</id>
    <published>2020-07-05T13:29:08.000Z</published>
    <updated>2020-07-05T13:29:56.506Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]</p><p><a href="https://vjudge.net/contest/381396#problem/D" target="_blank" rel="noopener">vjudge试题集链接</a></p><h2 id="A-Goldbach’s-Conjecture-POJ-2262"><a href="#A-Goldbach’s-Conjecture-POJ-2262" class="headerlink" title="A - Goldbach’s Conjecture POJ - 2262"></a>A - Goldbach’s Conjecture POJ - 2262</h2><p><a href="http://poj.org/problem?id=2262" target="_blank" rel="noopener">试题链接：</a><br>线性筛先预处理，然后判断就行</p><a id="more"></a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1000000</span>;</span><br><span class="line"><span class="keyword">int</span> prime[maxn+<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> isprime[maxn+<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prime</span><span class="params">(<span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(isprime,<span class="number">1</span>,<span class="keyword">sizeof</span>(isprime));</span><br><span class="line">isprime[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isprime[i])prime[++cnt]=i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt&amp;&amp;i*prime[j]&lt;=N;j++)</span><br><span class="line">&#123;</span><br><span class="line">isprime[i*prime[j]]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">Prime(maxn);</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(isprime[i]!=<span class="number">0</span>&amp;&amp;isprime[n-i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d = %d + %d\n"</span>,n,i,n-i);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="B-同余方程-计蒜客-T2010"><a href="#B-同余方程-计蒜客-T2010" class="headerlink" title="B - 同余方程 计蒜客 - T2010"></a>B - 同余方程 计蒜客 - T2010</h2><p><a href="https://nanti.jisuanke.com/t/T2010" target="_blank" rel="noopener">试题链接：</a><br>求逆元裸题，好像是noip原题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">ll x,y;</span><br><span class="line">ll gcd=exgcd(a,mod,x,y);</span><br><span class="line"><span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;inv(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-Tr-A-HDU-1575"><a href="#C-Tr-A-HDU-1575" class="headerlink" title="C - Tr A HDU - 1575"></a>C - Tr A HDU - 1575</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575" target="_blank" rel="noopener">试题链接：</a><br><a href="http://jozky.top/2020/07/05/Tr-A-HDU1575/">题解</a></p><h2 id="D-C-Looooops-POJ-2115"><a href="#D-C-Looooops-POJ-2115" class="headerlink" title="D - C Looooops POJ - 2115"></a>D - C Looooops POJ - 2115</h2><p><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">试题链接：</a><br><a href="http://jozky.top/2020/07/05/C-Looooops-POJ-2115/">题解：</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://vjudge.net/contest/381396#problem/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vjudge试题集链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;A-Goldbach’s-Conjecture-POJ-2262&quot;&gt;&lt;a href=&quot;#A-Goldbach’s-Conjecture-POJ-2262&quot; class=&quot;headerlink&quot; title=&quot;A - Goldbach’s Conjecture POJ - 2262&quot;&gt;&lt;/a&gt;A - Goldbach’s Conjecture POJ - 2262&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2262&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;试题链接：&lt;/a&gt;&lt;br&gt;线性筛先预处理，然后判断就行&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
      <category term="一起开心" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/%E4%B8%80%E8%B5%B7%E5%BC%80%E5%BF%83/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Tr A HDU1575</title>
    <link href="http://jozky.top/2020/07/05/Tr-A-HDU1575/"/>
    <id>http://jozky.top/2020/07/05/Tr-A-HDU1575/</id>
    <published>2020-07-05T13:16:04.000Z</published>
    <updated>2020-07-05T13:19:21.010Z</updated>
    
    <content type="html"><![CDATA[<p>@[toc]<br><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1575" target="_blank" rel="noopener">Tr A HDU1575</a></p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote><p>A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。</p></blockquote><a id="more"></a> <p><strong>Input</strong></p><blockquote><p>数据的第一行是一个T，表示有T组数据。 每组数据的第一行有n(2 &lt;= n &lt;= 10)和k(2 &lt;= k &lt;<br>10^9)两个数据。接下来有n行，每行有n个数据，每个数据的范围是[0,9]，表示方阵A的内容。</p></blockquote><p><strong>Output</strong><br>对应每组数据，输出Tr(A^k)%9973。<br><strong>Sample Input</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">99999999</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2686</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始以为A^k^的意思是主对角线各项的k次方的和，发现我太天真了，正确的含义应该是矩阵A的k次幂，然后再求主对角线各项的和<br>用 矩阵快速幂 来做<br>也算是模板题把</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 15</span></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span>//定义一个结构体，方便传递值</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[maxn][maxn];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">mul</span><span class="params">(matrix a, matrix b)</span>    <span class="comment">//矩阵求积, 矩阵乘法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans.m[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.m[i][j] += (a.m[i][k] * b.m[k][j]) % <span class="number">9973</span>;</span><br><span class="line">                ans.m[i][j] %= <span class="number">9973</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">quick_pow</span><span class="params">(matrix a, <span class="keyword">int</span> b)</span>    <span class="comment">//矩阵快速幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j)</span><br><span class="line">                ans.m[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ans.m[i][j] = <span class="number">0</span>;<span class="comment">//这里要初始化为单位矩阵，类比普通快速幂这里初始化为1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)<span class="comment">//方法与普通快速幂相同，只有乘法的实现不同</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            ans = mul(a, ans);</span><br><span class="line">        a = mul(a, a);</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix a;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; a.m[i][j];</span><br><span class="line"></span><br><span class="line">        matrix tmp = quick_pow(a, k);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= n; ++i)</span><br><span class="line">            ans += tmp.m[i][i] % <span class="number">9973</span>;</span><br><span class="line"></span><br><span class="line">        ans %= <span class="number">9973</span>;    <span class="comment">// 最后这里一定要再次取余！</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[toc]&lt;br&gt;&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1575&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tr A HDU1575&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A为一个方阵，则Tr A表示A的迹（就是主对角线上各项的和），现要求Tr(A^k)%9973。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="矩阵快速幂" scheme="http://Jozky.top/tags/%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>C Looooops POJ - 2115</title>
    <link href="http://jozky.top/2020/07/05/C-Looooops-POJ-2115/"/>
    <id>http://jozky.top/2020/07/05/C-Looooops-POJ-2115/</id>
    <published>2020-07-05T13:15:54.000Z</published>
    <updated>2020-07-05T13:19:22.927Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://poj.org/problem?id=2115" target="_blank" rel="noopener">C Looooops POJ - 2115</a></p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote><p>A Compiler Mystery: We are given a C-language style for loop of type</p><figure class="highlight cpp"><figcaption><span>for (variable </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">statement; </span><br></pre></td></tr></table></figure><p>I.e., a loop which starts by setting variable to value A and while<br>variable is not equal to B, repeats statement followed by increasing<br>the variable by C. We want to know how many times does the statement<br>get executed for particular values of A, B and C, assuming that all<br>arithmetics is calculated in a k-bit unsigned integer type (with<br>values 0 &lt;= x &lt; 2k) modulo 2k.</p></blockquote><a id="more"></a> <p><strong>Input</strong></p><blockquote><p>The input consists of several instances. Each instance is described by<br>a single line with four integers A, B, C, k separated by a single<br>space. The integer k (1 &lt;= k &lt;= 32) is the number of bits of the<br>control variable of the loop and A, B, C (0 &lt;= A, B, C &lt; 2k) are the<br>parameters of the loop.</p><p>The input is finished by a line containing four zeros.</p></blockquote><p><strong>Output</strong></p><blockquote><p>The output consists of several lines corresponding to the instances on<br>the input. The i-th line contains either the number of executions of<br>the statement in the i-th instance (a single integer number) or the<br>word FOREVER if the loop does not terminate.</p></blockquote><p><strong>Sample Input</strong><br>3 3 2 16<br>3 7 2 16<br>7 3 2 16<br>3 4 2 16<br>0 0 0 0<br><strong>Sample Output</strong><br>0<br>2<br>32766<br>FOREVER</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>初始值为A，每次可以增加C，值要mod2^k^,问mod后的值如果等于B，增加了几次C，如果无法等于B输出FOREVER</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>看一下我的推导：<br><img src="https://uploadfiles.nowcoder.com/files/20200705/543071257_1593953536536_202007052049339.png" alt="在这里插入图片描述"><br>你会发现其实就是扩展欧几里得的模板题，并求出最小正整数解<br>我们可以用 (x0 % b1 + b1 ) % b1得到它的最小正整数解了<br>此处x0= x * c / gcd(a,b)<br>详细证明看下面博客<br><a href="https://blog.csdn.net/qq_35975367/article/details/107072070" target="_blank" rel="noopener">扩展欧几里得讲解</a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll A,B,C,K;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;C&gt;&gt;K)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(A==<span class="number">0</span>&amp;&amp;B==<span class="number">0</span>&amp;&amp;C==<span class="number">0</span>&amp;&amp;K==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">ll x,y;</span><br><span class="line">ll a=C;</span><br><span class="line">ll b=(ll)<span class="number">1</span>&lt;&lt;K;</span><br><span class="line">ll c=B-A;</span><br><span class="line">ll gcd=exgcd(a,b,x,y);</span><br><span class="line"><span class="keyword">if</span>(c%gcd!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"FOREVER"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> x=(x*(c/gcd))%b;</span><br><span class="line">             x=(x%(b/gcd)+b/gcd)%(b/gcd);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://poj.org/problem?id=2115&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C Looooops POJ - 2115&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;A Compiler Mystery: We are given a C-language style for loop of type&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;figcaption&gt;&lt;span&gt;for (variable &lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;statement; &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;I.e., a loop which starts by setting variable to value A and while&lt;br&gt;variable is not equal to B, repeats statement followed by increasing&lt;br&gt;the variable by C. We want to know how many times does the statement&lt;br&gt;get executed for particular values of A, B and C, assuming that all&lt;br&gt;arithmetics is calculated in a k-bit unsigned integer type (with&lt;br&gt;values 0 &amp;lt;= x &amp;lt; 2k) modulo 2k.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模板题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E6%9D%BF%E9%A2%98/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="exgcd" scheme="http://Jozky.top/tags/exgcd/"/>
    
  </entry>
  
  <entry>
    <title>小a的旅行计划</title>
    <link href="http://jozky.top/2020/07/05/%E5%B0%8Fa%E7%9A%84%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/"/>
    <id>http://jozky.top/2020/07/05/%E5%B0%8Fa%E7%9A%84%E6%97%85%E8%A1%8C%E8%AE%A1%E5%88%92/</id>
    <published>2020-07-05T13:15:48.000Z</published>
    <updated>2020-07-05T13:18:25.833Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20808" target="_blank" rel="noopener">来源：牛客网</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间限制：C/C++ <span class="number">1</span>秒，其他语言<span class="number">2</span>秒</span><br><span class="line">空间限制：C/C++ <span class="number">32768</span>K，其他语言<span class="number">65536</span>K</span><br><span class="line"><span class="number">64b</span>it IO Format: %lld</span><br></pre></td></tr></table></figure><p>@[toc]</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>小a终于放假了，它想在假期中去一些地方游玩，现在有N个景点，编号为1, 2, \dots<br>N1,2,…N，同时小b也想出去游玩。由于一些特殊♂原因，他们的旅行计划必须满足一些条件 首先，他们可以从这N个景点中任意选几个游玩<br>设小a选出的景点集合为A，小b选的景点集合为B，则需要满足</p><ol><li>A,B的交集不能为空集</li><li>A,B不能相互包含(A=B也属于相互包含) 注意：在这里我们认为(A,B)是无序的，即(A,B)和(B,A)是同一种方案</li></ol></blockquote><a id="more"></a> <p><strong>输入描述:</strong><br>一个整数N表示景点的数量<br><strong>输出描述:</strong><br>一个整数表示方案数，答案对10^8^ + 7取模<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>说明<br>合法的方案如下：<br>小a：(1, 2) 小b： (2, 3)<br>小a：(1, 3) 小b： (2, 3)<br>小a：(1, 2) 小b： (1, 3)<br>示例2<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure><p>示例3<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>示例4<br>输入<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure><p>输出<br>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">68735934</span></span><br></pre></td></tr></table></figure><p>示例5<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>备注:<br>对于100%的数据1⩽n⩽10 ^13^</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p><a href="https://blog.csdn.net/weixin_42757232/article/details/89702769" target="_blank" rel="noopener">解题思路来自</a><br>我们整合一下题目的条件可以得到，A和B都至少有两个元素，且最少有一个相同，至少有一个不同<br>一共n的元素，我们可以先选出A的元素，然后在A中选一些元素作为公共元素，然后在A未选的元素中选择给B<br>可以得到公式<br><img src="https://uploadfiles.nowcoder.com/files/20200704/543071257_1593829203785_20200704100610423.png" alt="在这里插入图片描述"><br>我们注意到公式中存在除法操作，且我们需要mod，所以用逆元来算<br><a href="https://blog.csdn.net/qq_35975367/article/details/107119628" target="_blank" rel="noopener">求逆元的方法：</a></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">ll x,y;</span><br><span class="line">ll gcd=exgcd(a,mod,x,y);</span><br><span class="line"><span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">ll base=a%mod;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*base%mod;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ll inv(ll a,ll mod)&#123;</span></span><br><span class="line"><span class="comment">//return poww(a,mod-2);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="comment">//cout&lt;&lt;poww(2,3)&lt;&lt;endl;</span></span><br><span class="line">ll ans1=((poww(<span class="number">4</span>,n)<span class="number">-1</span>)-(poww(<span class="number">3</span>,n+<span class="number">1</span>))+mod)%mod;</span><br><span class="line">    ll ans2=<span class="number">3</span>*poww(<span class="number">2</span>,n<span class="number">-1</span>)%mod;</span><br><span class="line">    ll ans3=inv(<span class="number">2</span>,mod)%mod;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(ans1*ans3+ans2)%mod;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20808&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;来源：牛客网&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;时间限制：C/C++ &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;秒，其他语言&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空间限制：C/C++ &lt;span class=&quot;number&quot;&gt;32768&lt;/span&gt;K，其他语言&lt;span class=&quot;number&quot;&gt;65536&lt;/span&gt;K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;64b&lt;/span&gt;it IO Format: %lld&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;@[toc]&lt;/p&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;小a终于放假了，它想在假期中去一些地方游玩，现在有N个景点，编号为1, 2, \dots&lt;br&gt;N1,2,…N，同时小b也想出去游玩。由于一些特殊♂原因，他们的旅行计划必须满足一些条件 首先，他们可以从这N个景点中任意选几个游玩&lt;br&gt;设小a选出的景点集合为A，小b选的景点集合为B，则需要满足&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A,B的交集不能为空集&lt;/li&gt;
&lt;li&gt;A,B不能相互包含(A=B也属于相互包含) 注意：在这里我们认为(A,B)是无序的，即(A,B)和(B,A)是同一种方案&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="逆元" scheme="http://Jozky.top/tags/%E9%80%86%E5%85%83/"/>
    
      <category term="组合数" scheme="http://Jozky.top/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="二项式定理" scheme="http://Jozky.top/tags/%E4%BA%8C%E9%A1%B9%E5%BC%8F%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>逆元的求法</title>
    <link href="http://jozky.top/2020/07/04/%E9%80%86%E5%85%83%E7%9A%84%E6%B1%82%E6%B3%95/"/>
    <id>http://jozky.top/2020/07/04/%E9%80%86%E5%85%83%E7%9A%84%E6%B1%82%E6%B3%95/</id>
    <published>2020-07-04T01:32:48.000Z</published>
    <updated>2020-07-04T01:35:42.022Z</updated>
    
    <content type="html"><![CDATA[<p>逆元：<br>对于a和p，若 a * inv(a) % p ≡ 1，则称inv(a)为a%p的逆元。其中p为质数<br>逆元就是在mod下，不能直接除以一个数，而要乘以他的逆元<br>a * inv(a) = 1 (mod p)<br>x / a可以改成 x * inv(a) % p</p><a id="more"></a> <p>@[toc]</p><h2 id="方法一-扩展欧几里得"><a href="#方法一-扩展欧几里得" class="headerlink" title="方法一.扩展欧几里得"></a>方法一.扩展欧几里得</h2><p>a * inv(a) = 1 (mod p)<br>可以变形成 a * inv(a) +k * p = 1(前提是a和p要互素)<br>可以用扩欧的公式来计算<br>时间复杂度:O(logn)<br>适用范围：只要存在逆元即可求，适用于个数不多但是mod很大的时候，也是最常见的一种求逆元的方法。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span><span class="comment">//扩展欧几里得算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;  <span class="comment">//到达递归边界开始向上一层返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    ll gcd=exgcd(b,a%b,x,y);</span><br><span class="line">    ll y1=y;    <span class="comment">//把x y变成上一层的</span></span><br><span class="line">    ll x1=x;</span><br><span class="line">    y=x1-(a/b)*y1;</span><br><span class="line">    x=y1;</span><br><span class="line">    <span class="keyword">return</span> gcd;     <span class="comment">//得到a b的最大公因数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line">ll x,y;</span><br><span class="line">ll gcd=exgcd(a,mod,x,y);</span><br><span class="line"><span class="keyword">if</span>(gcd!=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (x+mod)%mod; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二-费马小定理-欧拉定理"><a href="#方法二-费马小定理-欧拉定理" class="headerlink" title="方法二.费马小定理+欧拉定理"></a>方法二.费马小定理+欧拉定理</h2><p>费马小定理：假如p是质数，且gcd(a,p)=1，那么 a^(p-1)^ ≡ 1（mod p），进一步可以推出a^p-2^ * a ≡ 1 (mod p)<br>a^p-2^就是a在mod p意义下的逆元<br>欧拉函数：a^φ(n)^≡1 (mod n) ，其中 gcd(a,n)=1<br>若n为素数，φ(n)=n-1<br>时间复杂度 O(log mod)<br>适用范围：在mod是素数的时候使用，比扩欧快</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b,ll mod)</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1</span>;</span><br><span class="line">ll base=a;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*base%mod;</span><br><span class="line">base=base*base%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">inv</span><span class="params">(ll a,ll mod)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> poww(a,mod<span class="number">-2</span>,mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三-递推求逆元"><a href="#方法三-递推求逆元" class="headerlink" title="方法三:递推求逆元"></a>方法三:递推求逆元</h2><p>时间复杂度为O（n）<br>使用条件：mod为不是很大的素数，且需要多次调用</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> inv[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n,<span class="keyword">long</span> <span class="keyword">long</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">inv[i]=((p-p/i)*inv[p%i]%p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;逆元：&lt;br&gt;对于a和p，若 a * inv(a) % p ≡ 1，则称inv(a)为a%p的逆元。其中p为质数&lt;br&gt;逆元就是在mod下，不能直接除以一个数，而要乘以他的逆元&lt;br&gt;a * inv(a) = 1 (mod p)&lt;br&gt;x / a可以改成 x * inv(a) % p&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="逆元" scheme="http://Jozky.top/tags/%E9%80%86%E5%85%83/"/>
    
  </entry>
  
</feed>
