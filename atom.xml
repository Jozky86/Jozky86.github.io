<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-04-07T11:10:32.813Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客网【每日一题】4月7号题目精讲 树</title>
    <link href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/"/>
    <id>http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/</id>
    <published>2020-04-07T10:59:14.000Z</published>
    <updated>2020-04-07T11:10:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13611" target="_blank" rel="noopener">树</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K<br>其他语言262144K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边；</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数表示方案数（mod 1e9+7）。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">39</span><br></pre></td></tr></table></figure><p>备注:</p><p>对于30%的数据，n≤10, k≤3；<br>对于100%的数据，n,k≤300。<br><strong>题解：</strong><br><del>shy爹有棵树</del><br>这个题也可以这么想，把相同颜色当成一个整体，连通块，问构成连通块的方案<br>我们用dp来计数<br>dp[i][j]表示i个点用了j个颜色的方案<br>那么转移方程就是<br>dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(k-(j-1))<br>dp[i][j]=第i个点和第i-1个点颜色相同或者第i-1个点所用的颜色与之前不同，之前用了（j-1）个颜色，这个点可用的颜色种类就是k-（j-1）<br>（可以理解成前者在一个连通块，后者不在一个连通块内）<br>因为数据给的肯定是棵树，那树的形状并不会影响结果，所以。。。也可以不输入那（n-1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=303;</span><br><span class="line">ll mod =1e9+7;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line">int n,k;</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=1;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==1&amp;&amp;j==1)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-(j-1)))%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum=(sum+dp[n][i])%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有第二个办法：<br>一下为转载：<br>题目意思是用k个点把一个有n个节点的树染色,然后的地方必须联通,求有多少方案数?<br>下面给大家介绍两种做法..<br><img src="https://img-blog.csdnimg.cn/20200407185522399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">切边表示染色用的颜色个数,比如我要用3种颜色染色,那么我就只要考虑切2条边,比如切2-4,和3和7这是一种方案。若将树分割为 i个连通块，则需要删去 i−1条边，故方案数为 C^i-1^ n−1然后考虑染色,假如我现在切的是i条边,要从k种颜色中选出i中颜色染色，而且是有顺序的，故方案数为A(k,i+1).<br>综上，总的方案数为：<br><img src="https://img-blog.csdnimg.cn/20200407190618154.png" alt="在这里插入图片描述">可以线性求逆元，枚举 i 实现。</p><p>时间复杂度：O(n)<br>代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">const ll maxn=310;</span><br><span class="line">ll n,k,ans,inv[maxn],f[maxn];</span><br><span class="line">ll C(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[y]%mod*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll A(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    inv[0]=f[0]=inv[1]=f[1]=1;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=((mod-mod/i)*inv[mod%i])%mod,f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=(inv[i]*inv[i-1])%mod,f[i]=(f[i]*f[i-1])%mod;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=k&amp;&amp;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+(C(n-1,i-1)*A(k,i)%mod))%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.nowcoder.net/n/c76751c0215344ff99357aaee5235851" target="_blank" rel="noopener">转载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13611&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K&lt;br&gt;其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="DFS序" scheme="http://Jozky.top/tags/DFS%E5%BA%8F/"/>
    
      <category term="连通块" scheme="http://Jozky.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>DFS序讲解</title>
    <link href="http://jozky.top/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/"/>
    <id>http://jozky.top/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/</id>
    <published>2020-04-07T10:00:26.000Z</published>
    <updated>2020-04-07T10:01:41.173Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；<br>dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。</p><a id="more"></a><p>如图：<br><img src="https://img-blog.csdnimg.cn/20200407172327886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">dfs序就是：ABDDEEBCFHHFG<br>其实就是用dfs全部遍历一遍，不过我们不能光遍历还有动些小手脚，我们要在遍历的同时记录每个节点进栈与出栈的时间序列。</p><p>介绍两个基本函数：in[x],out[x]<br>dfs从根节点开始，这俩函数就分别记录每个节点x进入与离开的时间戳<br>还有num[x]，表示第x个节点的编号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inline int dfs(int x,int fa,int time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">in</span>[x]=++time;</span><br><span class="line">num[time]=x;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=e[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">int w=e[x][i];</span><br><span class="line"><span class="keyword">if</span>(w==fa)<span class="built_in">continue</span>;//防止又从子节点找回去</span><br><span class="line">dfs(w,x,time); </span><br><span class="line">&#125;</span><br><span class="line">out[x]=time;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">dfs(s,0,0);</span><br></pre></td></tr></table></figure><p>（具体情况根据，根据题目来写）<br><img src="https://img-blog.csdnimg.cn/20200407174719197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">num生成的就是一个新秩序，由每个节点进入关系而形成的<br>你仔细观察会发现：<br>序根节点的进栈时间&lt;子树的dfs&lt;根节点的出栈时间<br>这样不就成一个区间了<br>in[x]~out[x]是x为根节点的子树，划分为一个区间<br>然后什么单点修改，区间查询，莫队都可以用在树上，而且dfs序也是树链剖分的前驱知识</p><p>光说可能不怎么懂，我去找一些题，做完再更新例题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；&lt;br&gt;dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="DFS序" scheme="http://Jozky.top/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月27日 数学考试</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/</id>
    <published>2020-04-06T14:53:34.000Z</published>
    <updated>2020-04-06T15:01:52.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 题号 NC15553<br> 名称 数学考试<br> 来源 2018年长沙理工大学第十三届程序设计竞赛<br>链接：<a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15553</a><br>来源：牛客网<br><a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">试题传送门</a><br>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述<br>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br>他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br>即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p><a id="more"></a><p>输入描述:</p><blockquote><p>第一行一个整数T（T&lt;=10）,代表有T组数据 接下来一行两个整数n,k,(1&lt;=n&lt;=200,000),(1&lt;=k,2k &lt;= n)<br>接下来一行n个整数a1,a2,…,an，（-100,000&lt;=ai&lt;=100,000）</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数，qwb能获得的最大分数</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">8 2</span><br><span class="line">-1 0 2 -1 -1 2 3 -1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><strong><em>题解：</em></strong><br>题意就是求不想交的前缀与后缀和的最大值<br>第一反应是线段树（<del>毕竟是有关区间查询</del> ） ，不过仔细想想也不能这么麻烦（<del>打线段树不累吗？</del> ） ，不过也有大佬用线段树做的。<br>根据题意知道前缀与后缀长度一样，依据朴素的原则单纯打暴力肯定不行，需要优化优化，怎么优化呢？</p><p>我们先求出所有前缀和q[]<br>然后按照给定前后缀的长度k，求出每个k长区间的和<br>比如 -1 0 2 -1 -1 2 3 -1   k=2；<br>每个k长区间的和为：w[]-1 2 1 -2 1 5 2<br>我们所要求的最大值max=dp1+dp2<br>dp1是前缀和最大值<br>dp2是后缀和最大值<br>那其实就是在w中取一个dp1再取一个dp2，使他们和最大<br>但注意前缀与后缀不能相交和相连<br>方法一：<br>稍微处理下,可以先选后缀，然后前缀的范围就是去除已选的后缀，在里面取最大的前缀<br>maxx=(q[i]-q[i-k])+max(q[1],q[2],q[3]…..q[i-k-1])<br>(q[i]-q[i-k])后缀和<br>max(q[1],q[2],q[3]…..q[i-k-1])最大的前缀<br>然后求出maxx的最大值情况<br>诶，这不就是线性dp吗！wok做完才注意到<br>方法二：<br>求出前缀和所能取到的最大值（从头开始），放入数组w1<br>求出后缀和所能取到的最大值（从尾开始），放入w2中<br>然后再一个循环，求出w1[i]与w2[i+1]（即当前位i的前缀和与排在i之后的最大后缀和之和）的最大值<br>代码一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;cnt;</span><br><span class="line">  q[i]=q[i-1]+cnt; </span><br><span class="line">&#125;</span><br><span class="line">memset(w1,-128,sizeof(w1));</span><br><span class="line">memset(w2,-128,sizeof(w2));</span><br><span class="line">cnt=-1e10;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  w[i]=q[i]-q[i-k];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[i]+w1[i-k]&gt;cnt)cnt=w[i]+w1[i-k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;cnt;</span><br><span class="line">  q[i]=q[i-1]+cnt; </span><br><span class="line">&#125;</span><br><span class="line">memset(w1,-128,sizeof(w1));</span><br><span class="line">memset(w2,-128,sizeof(w2));</span><br><span class="line">cnt=-1e10;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  w[i]=q[i]-q[i-k];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=n-k+1;i&gt;=k+1;i--)</span><br><span class="line">w2[i]=w2[i+1]&gt;w[i+k-1]?w2[i+1]:w[i+k-1];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w2[i+1]+w1[i]&gt;cnt)cnt=w2[i+1]+w1[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了还有变形的问题：<br><del>（等晚上有空再想吧）</del> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 题号 NC15553&lt;br&gt; 名称 数学考试&lt;br&gt; 来源 2018年长沙理工大学第十三届程序设计竞赛&lt;br&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15553&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15553&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15553&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;试题传送门&lt;/a&gt;&lt;br&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;br&gt;今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，&lt;br&gt;他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,&lt;br&gt;即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &amp;gt;= L+k）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="前缀后缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C/"/>
    
      <category term="线性dp" scheme="http://Jozky.top/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月26日 合并回文子串</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-04-06T14:53:16.000Z</published>
    <updated>2020-04-06T14:59:35.451Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题号：NC13230<br>名称：合并回文子串<br>来源：美团2017年CodeM大赛-初赛A轮</strong><br><a href="https://ac.nowcoder.com/acm/problem/13230" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><p><strong>题目描述</strong></p><blockquote><p>输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。<br>我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。<br>需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:</p></blockquote><a id="more"></a><blockquote><p>第一行一个整数T(T ≤ 50)。 接下来2T行，每两行两个字符串分别代表A,B(|A|,|B| ≤ 50)，A,B的字符集为全体小写字母。</p></blockquote><p>输出描述:</p><p>对于每组数据输出一行一个整数表示价值最大的C的价值。<br>示例1</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">a</span><br><span class="line">aaaabcaa</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>思路：区间dp问题</strong><br>dp[i][j][m][n]表示A中下标i到j-1以及B中下标m到n-1的串，能否组成回文串<br>(dp值为零则表示不构成回文串，不为零则表示构成)<br>首先：字符本身是回文串<br>其次，分为四种情况<br>a[i]==a[j-1]        dp[i][j][m][n]+=c[i+1][j-1][m][n];<br>因为dp我们只考虑是否为0或非0，所以dp之间可以+=也可以|=,都不影响<br>（当A的第i为和第j-1位相同时，那么dp[i][j]是否为回文串就取决于比它小一层的dp[i+1][j-1]，这样一次往里推，就可以推到以一种情况）<br>b[m]==b[n-1]    dp[i][j][m][n]+=c[i][j][m+1][n-1];<br>(和上一个思路相同)</p><p>a[i]==b[n-1]        dp[i][j][m][n]+=c[i+1][j][m][n-1];<br>（当A的i与B的n-1相同时，那么dp[i][][][n]是否为回文串就取决于A的后一位i+1和B的前一位n-1的情况）<br>a[m]==b[j-1]    dp[i][j][m][n]+=c[i][j-1][m+1][n];<br><strong>代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">int t;</span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int c[maxn][maxn][maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">char ch=getchar();</span><br><span class="line">int j;</span><br><span class="line">int n;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">int ans=0;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">ch=getchar();</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">ch=getchar();</span><br><span class="line">int len1=strlen(a),len2=strlen(b);</span><br><span class="line"><span class="keyword">for</span>(int tj=0;tj&lt;=len1;tj++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int tn=0;tn&lt;=len2;tn++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i+tj&lt;=len1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int m=0;m+tn&lt;=len2;m++)</span><br><span class="line">&#123;</span><br><span class="line">j=i+tj;</span><br><span class="line">n=m+tn;</span><br><span class="line"><span class="keyword">if</span>(tj+tn&lt;=1)c[i][j][m][n]=1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c[i][j][m][n]=0;</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=2&amp;&amp;a[i]==a[j-1])c[i][j][m][n]|=c[i+1][j-1][m][n];                                               </span><br><span class="line"><span class="keyword">if</span>(tn&gt;=2&amp;&amp;b[m]==b[n-1])c[i][j][m][n]|=c[i][j][m+1][n-1];</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[i]==b[n-1])c[i][j][m][n]|=c[i+1][j][m][n-1];</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[m]==b[j-1])c[i][j][m][n]|=c[i][j-1][m+1][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i][j][m][n])ans=max(ans,tj+tn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另外</strong><br>tj和tn从0开始，不断讨论A中i到i+tj和B中m到tn的回文字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题号：NC13230&lt;br&gt;名称：合并回文子串&lt;br&gt;来源：美团2017年CodeM大赛-初赛A轮&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13230&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。&lt;br&gt;我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。&lt;br&gt;需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="区间dp" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="字符串" scheme="http://Jozky.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月25日 tokitsukaze and Soldier</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/</id>
    <published>2020-04-06T14:51:59.000Z</published>
    <updated>2020-04-06T14:57:17.978Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="牛客网【每日一题】3月25">TOC</a></p><p> 题号：NC50439<br>名称： tokitsukaze and Soldier<br>来源：练习赛50-C<br>链接: <a href="https://ac.nowcoder.com/acm/problem/50439" target="_blank" rel="noopener">牛客网</a>.</p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。<br>第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。<br>但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)<br>tokitsukaze想知道，团的战力最大为多少。</p></blockquote><a id="more"></a><p>输入描述:</p><p>第一行包含一个正整数n(1≤n≤10^5)。<br>接下来n行，每行包括2个正整数v,s(1≤v≤10^9,1≤s≤n)。</p><p>输出描述:</p><p>输出一个正整数，表示团的最大战力。</p><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>示例2<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">100 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><p><strong><em>思路</em></strong><br>所求的最大战斗力由v和s这两个因素限制。<br>结构体数组a存放v和s，然后对其排序，先按照s从大到小，如果s相同再排v，也是从大到小（先要保证足够的人数，后面好进行取舍）。<br>定义一个从小到大的优先队列q，ans相互跟随q，（q每次添加一个战力值，同时用ans加上战力值；ans删去，q也弹出），战力值的先后加入由s的排序决定，当q的元素数量大于当前s的值时（s是由大到小的排序的），就将多出的部分pop出（q是从小到大排序，所以弹出的总是其中最小值），再用ans减去，这样ans的值即为在人数限定在s内的最佳情况（因为弹出的是最小值，相对于前s个数的和，所以之后也不用再考虑被弹出的数），记录ans的最大值<br><del>我刚开始提交是70多分，想了一阵子才发现是数组开小了（笑哭）</del> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v,s;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.s!=b.s)<span class="keyword">return</span> a.s&gt;b.s;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.v&gt;a.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i].v&gt;&gt;a[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort (a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//int tot=0;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minn=maxn;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">q.push(a[i].v);</span><br><span class="line">ans+=a[i].v;</span><br><span class="line"><span class="keyword">while</span>(q.size()&gt;a[i].s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans-=q.top();</span><br><span class="line"><span class="comment">//printf("q.size=%d,a[i].s=%d,ans=%d\n",q.size(),a[i].s,ans);</span></span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">//tot--;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;maxx)maxx=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxx;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@&lt;a href=&quot;牛客网【每日一题】3月25&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 题号：NC50439&lt;br&gt;名称： tokitsukaze and Soldier&lt;br&gt;来源：练习赛50-C&lt;br&gt;链接: &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50439&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 524288K，其他语言1048576K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。&lt;br&gt;第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。&lt;br&gt;但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)&lt;br&gt;tokitsukaze想知道，团的战力最大为多少。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="优先队列" scheme="http://Jozky.top/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】4月6日数码</title>
    <link href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/"/>
    <id>http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/</id>
    <published>2020-04-06T12:59:12.000Z</published>
    <updated>2020-04-06T15:01:56.489Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<a href="https://ac.nowcoder.com/acm/problem/13221" target="_blank" rel="noopener">数码</a><br>来源：<a href="https://ac.nowcoder.com/acm/contest/5#description" target="_blank" rel="noopener">美团2017年CodeM大赛-资格赛</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x<br>的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 </p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>一行，两个整数 l 和 r (1 ≤ l ≤ r ≤ 10^9^)。</p></blockquote><p>输出描述:</p><p>输出9行。</p><blockquote><p>第 i 行，输出数码 i 出现的次数。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>题解：<br>先介绍一个函数：<br>solve（a，b）就是从1<del>a中数码b的倍数出现的次数<br>solve(a,b)=a/b<br>那么求[l,r]的话，就用solve(r,b)-solve(l-1,b)，大致可以理解成前缀和那种<br>num就是0</del>9，计算每个num对应的区间<br>最高位是1的话：1,10 ~ 19,100 ~ 199， 1000 ~ 1999….<br>最高位是2的话：2,20 ~ 29,200 ~ 299， 2000 ~ 2999….</p><p>因为我们只记录约数的最高位，像1999，约数就是1和1999，我们只记录最高位，那么就是有两个1<br>那么我们枚举以num开头的数，计算它的倍数在[l,r]中出现的次数。<br>按照几位数和最高位是几进行枚举，有多少这样的数直接统计就ok<br>solve(r,num)-solve(l-1,num)<br>枚举num的值<br>让最高位等于x时num枚举相对应的区间（从x<em>10^y-1^~(x+1)</em>10^y-1^-1）y=1.2.3….<br>有部分数会被算重复，因为有完全平方数存在，<br>再运用整除分块技巧，让复杂度降到O(根号n)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">ll minn(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;a;</span><br><span class="line"> <span class="built_in">return</span> a;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll a, ll b) &#123;</span><br><span class="line">  ll res = 0;</span><br><span class="line">   ll beg;</span><br><span class="line">   ll end;</span><br><span class="line">  <span class="keyword">for</span> (ll i = 1; i &lt;= a / b; i *= 10) &#123;</span><br><span class="line">    beg = b * i;//区间开头</span><br><span class="line">    </span><br><span class="line"> end = minn(a, beg + i - 1);//区间结尾</span><br><span class="line"> int k;</span><br><span class="line">    <span class="keyword">for</span> (int j = beg; j &lt;= end; j = k + 1) &#123;</span><br><span class="line">      k = min(a / (a / j), end);</span><br><span class="line">      //cout&lt;&lt;a/(a/i)&lt;&lt;<span class="string">" "</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">      res += (k - j + 1) * (a / j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll l,r;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">   cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=9;i++)&#123;</span><br><span class="line">        cout&lt;&lt;solve(r,i)-solve(l-1,i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13221&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数码&lt;/a&gt;&lt;br&gt;来源：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5#description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美团2017年CodeM大赛-资格赛&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x&lt;br&gt;的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="整除分块" scheme="http://Jozky.top/tags/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】4月1日题目 Rinne Loves Edges </title>
    <link href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/"/>
    <id>http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/</id>
    <published>2020-04-05T16:17:13.000Z</published>
    <updated>2020-04-05T16:20:28.242Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22598" target="_blank" rel="noopener">牛客网</a></p><ol><li>题目：</li></ol><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><blockquote><p>题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m<br>条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为<br>1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1<br>了！作为回报，她会让你的排名上升一定的数量。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行三个整数 N,M,S，意义如「题目描述」所述。</p><p>接下来 M 行，每行三个整数 u,v,w 代表点 u 到点 v 之间有一条长度为 w 的无向边。</p></blockquote><p>输出描述:</p><p>一个整数表示答案。</p><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 1 </span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明</p><p>需要使得点 2,3,4 不能到达点 1，显然只能删除所有的边，答案为 3</p><p>示例2<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>说明</p><blockquote><p>需要使得点 4 不能到达点 1，显然删除边 2↔3是最优的。</p></blockquote><p>备注:</p><blockquote><p>2≤S≤N≤10^5^,M=N−1保证答案在 C++ long long 范围内</p></blockquote><ol start="2"><li>题解：</li></ol><p>仔细观察题中给的数据m=n-1，其实就是给你一个树，而被删除度为1的点就是这个树的叶子节点，给你的s就是这个树的根<br>那一切就很清楚了：给你一个树和根节点，让你通过删边使得根节点与叶子节点不相连，问你怎么删值最小<br>这个是树形dp问题，我们要做的就是在搜索树的过程中不断处理数据<br>凡是dp问题，都有状态转移，就是一个大问题可以小问题<br>s为根节点时，要删去一些边让s与每个叶子节点不连通，其实就是让x为根节点的子树删去一些边，使得s和x的子树上每个叶子节点不连通。<br>两种情况：一个就是删去x与他儿子y的边<br>另一个就是看以y为子树的根节点的最小情况。<br>我们取较小值<br>    f[x]+=min(f[y],edge[i].w);<br>    edge[i].w是指当前节点x与其子节点y的距离<br>    具体看代码吧</p><ol start="3"><li>代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+3;</span><br><span class="line">int f[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int u,v,w,next;</span><br><span class="line">&#125;edge[maxn*2];</span><br><span class="line">int root[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">int cnt=0;</span><br><span class="line">int n,m,s;</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">edge[++cnt].v=v;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=s&amp;&amp;root[x]==1)f[x]=-1;//如果这个是叶子节点，就断绝与父亲的关系 </span><br><span class="line">//根节点s也有可能度为1，所以要除s之外</span><br><span class="line">int now;//当前点x的子节点</span><br><span class="line">//关系(fa--&gt;x--&gt;now)</span><br><span class="line"><span class="keyword">for</span>(int i=head[x];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">now=edge[i].v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(now==fa)<span class="built_in">continue</span>;//因为是无向图，我们要防止返回到父亲节点</span><br><span class="line"></span><br><span class="line">dfs(now,x);//继续向下</span><br><span class="line"><span class="keyword">if</span>(f[now]==-1)f[x]+=edge[i].w;//这个我们已经给断绝关系了，只加当前边的权值</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[x]+=min(f[now],edge[i].w);//考虑两个方面</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">int u,v,w;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">addt(u,v,w);</span><br><span class="line">addt(v,u,w);//链式前向星</span><br><span class="line">root[u]++;</span><br><span class="line">root[v]++;</span><br><span class="line"> &#125; </span><br><span class="line"> dfs(s,0);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[s]);</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/22598&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;题目：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m&lt;br&gt;条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为&lt;br&gt;1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1&lt;br&gt;了！作为回报，她会让你的排名上升一定的数量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>牛客每日一题3.31 城市网络</title>
    <link href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    <id>http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</id>
    <published>2020-04-05T11:42:46.000Z</published>
    <updated>2020-04-05T11:56:01.376Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13331" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><blockquote><p>题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。<br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。</p></blockquote><a id="more"></a><blockquote><p>在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v<br>），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p></blockquote><p>输入描述:</p><blockquote><p>第一行，两个正整数 n , q (2 ≤ n ≤ 10^5^ , 1 ≤ q ≤ 10^5^)。 第二行，n 个正整数 a_i (1 ≤<br>a_i ≤ 10^5) 描述每个城市售卖的珠宝的价值。 接下来 n-1 行，每行描述一条道路 x , y (1 ≤ x,y ≤<br>n)，表示有一条连接 x 和 y 的道路。 接下来 q 行，每行描述一次行程 u , v , c (1 ≤ u,v ≤ n , 1 ≤ c<br>≤ 10^5^)。</p></blockquote><p>输出描述:</p><blockquote><p>对于每次行程输出一行，为所购买次数。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3 5 1 2 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 2 1</span><br><span class="line">4 2 2</span><br><span class="line">4 2 3</span><br><span class="line">5 1 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>题解:<br>毋庸置疑就是用倍增来做<br>那什么是倍增呢？<br>（先挖个坑，有空做个倍增的讲解）<br>递推式fa[i][j] = fa[fa[i][j-1]][j - 1],只要倍增得到fa[i][0]就行，因为有了这个后面都可以推出<br>fa[i][j] 代表i节点往上走2^j的距离，且比当前大的点<br>每次查询时，在所有需要问的点加一条新点，连在u的下方，新点的权值就是询问的初始权值，从这个新点往上倍增就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">const int maxn=2e5+2;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int fa[maxn][23];</span><br><span class="line">int n,q;</span><br><span class="line">int to[maxn];</span><br><span class="line">vector&lt;int&gt; W[2*maxn];</span><br><span class="line">void dfs(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">int pos=f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=21;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[pos][i]&amp;&amp;a[fa[pos][i]]&lt;=a[u])</span><br><span class="line">pos=fa[pos][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[pos]&gt;a[u])fa[u][0]=f;</span><br><span class="line"><span class="keyword">else</span> fa[u][0]=fa[pos][0];</span><br><span class="line"><span class="keyword">for</span>(int i=1;fa[fa[u][i-1]][i-1];i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i-1]][i-1];</span><br><span class="line">&#125;</span><br><span class="line">dis[u]=dis[f]+1;</span><br><span class="line"><span class="keyword">for</span>(int v=0;v&lt;W[u].size();v++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(W[u][v]==f)<span class="built_in">continue</span>;</span><br><span class="line">dfs(W[u][v],u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int a;</span><br><span class="line">  int b;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        W[a].push_back(b);</span><br><span class="line">        W[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i =1; i &lt;= q ; ++i)&#123;//增加新点</span><br><span class="line">        int aa,b,c;</span><br><span class="line">        scanf(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;b,&amp;c);</span><br><span class="line">        W[n+i].push_back(aa);</span><br><span class="line">        W[aa].push_back(i+n);</span><br><span class="line">        a[n+i] = c;</span><br><span class="line">        to[n+i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">   int sum = 0; </span><br><span class="line">   int pos;</span><br><span class="line">    <span class="keyword">for</span>(int i = n+1; i &lt;= n+q; ++i)&#123;</span><br><span class="line">       pos=i;</span><br><span class="line">      sum=0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 21; j &gt;= 0; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[fa[pos][j]] &gt;= dis[to[i]]) &#123;</span><br><span class="line">                sum += (1 &lt;&lt; j);</span><br><span class="line">pos= fa[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13331&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。&lt;br&gt;你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="倍增" scheme="http://Jozky.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>清明追思家国永念</title>
    <link href="http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/"/>
    <id>http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/</id>
    <published>2020-04-04T14:59:20.000Z</published>
    <updated>2020-04-04T15:08:57.094Z</updated>
    
    <content type="html"><![CDATA[<p>我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行<img src="https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>本来想睡觉，企鹅群不小心看见一些发言气醒了。</p><p>4月4日默哀是形式主义?</p><p>你知道什么是形式主义吗?这种公共活动都是形式主义?死去的同胞、牺牲的医护都配不上，那谁还配得上这样的国礼?这算哪门子形式?</p><p>你可以说，我觉得宣传口的工作不够到位;你也可以说，我觉得现在才发布通知过于仓促;你还可以说，禁止的范围有待商榷。</p><p>无动于衷不是罪过，没有感同身受不是罪过，做不到泪流满面不是罪过，私下继续娱乐活动也不是罪过。你可以不爱听歌功颂德的文本，可以用自己的方式怀缅，可以用其他途径玩得.昏天黑地。</p><p>娱乐至死的时代，只有无聊才让人如临大敌，都懂。</p><p>做了不代表尊重，没做也不代表不尊重。</p><p>没有卫兵站在你家里用枪抵着你的后脑勺让你哭天抢地，没有条子叔叔把看电视打游戏听音乐的人逮起来，也没有人让你排着长队对着什么东西跪地哀嚎。事实上，没有人强迫你。只是有一点，自身的态度和对外界的要求要-致。若是不以流程怀念，就不要对着默哀的人喊你们是一群被形式主义迫害的粉红，缄默到底。若是以流程怀缅，也不必逼迫他人做超出公报内容的事，真挚只能自发。</p><p>你可以不立正，可以不起床。但是在鸣笛的那几分钟里，你必须清楚，你还活着，没有失去年长的亲人、远方的朋友是因为谁。你也得清楚，这样的祭奠，那些人配得上。<br>———转载<br><img src="https://img-blog.csdnimg.cn/20200404230406288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200404230410721.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行&lt;img src=&quot;https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】Shortest Path 4月3日题目精讲 DFS </title>
    <link href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/"/>
    <id>http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/</id>
    <published>2020-04-04T14:53:04.000Z</published>
    <updated>2020-04-04T14:55:17.159Z</updated>
    
    <content type="html"><![CDATA[<p>题号 NC13886<br><a href="https://ac.nowcoder.com/acm/problem/13886" target="_blank" rel="noopener">Shortest Path</a><br><a href="https://ac.nowcoder.com/acm/contest/10#description" target="_blank" rel="noopener">西南交通大学第十三届ACM决赛</a><br>题意：<br>一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？<br><strong>题解：</strong><br>如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式</p><a id="more"></a><p><img src="https://uploadfiles.nowcoder.com/files/20200404/543071257_1585932178570_20200404003717820.png" alt="在这里插入图片描述"><br>改变后路径更小，也就是说两两一组的点都不会覆盖其他点<br>那么每个点与其他点配对就有两者选择，一个与兄弟节点配对（中间跨过父亲点），另一个就是与父亲节点相连，这样选择肯定是最优的<br>如果这个节点所在的自树里有偶数个节点，那么他们内部配对就可以了（好像有什么怪怪的）<br>如果有奇数个节点，还有把父亲节点拉进来一起配对（这样才能组成偶数个）<br>来上代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxx=1e4+5;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int head[maxx];</span><br><span class="line">int cnt=0;</span><br><span class="line">ll x,y,z;</span><br><span class="line">ll ans;</span><br><span class="line">struct node</span><br><span class="line">&#123;</span><br><span class="line">ll w,v,u,next;</span><br><span class="line">&#125;edge[maxx*2];</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">edge[++cnt].u=u;</span><br><span class="line">edge[cnt].v=v;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ll dfs(ll u,ll f,ll w)</span><br><span class="line">&#123;</span><br><span class="line">ll sum=1;</span><br><span class="line"><span class="keyword">for</span>(int i=head[u];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(edge[i].v!=f)sum+=dfs(edge[i].v,u,edge[i].w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum%2)ans+=w;</span><br><span class="line"><span class="built_in">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int T;</span><br><span class="line">int n;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=T;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">memset(head,0,sizeof(head));</span><br><span class="line">cnt=0;</span><br><span class="line">ans=0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">scanf(<span class="string">"%lld%lld%lld"</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">addt(x,y,z);</span><br><span class="line">addt(y,x,z); </span><br><span class="line">&#125;</span><br><span class="line">dfs(1,0,0);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">//树上dfs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题号 NC13886&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Shortest Path&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/10#description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;西南交通大学第十三届ACM决赛&lt;/a&gt;&lt;br&gt;题意：&lt;br&gt;一棵偶数节点的树，分成n/2对，两两一组，所有组的路径之和最小是多少？&lt;br&gt;&lt;strong&gt;题解：&lt;/strong&gt;&lt;br&gt;如果两个点之间相连将另外两个相连的点覆盖，那么完全可以改变相连方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
  </entry>
  
  <entry>
    <title>About Me</title>
    <link href="http://jozky.top/2020/04/04/About-Me/"/>
    <id>http://jozky.top/2020/04/04/About-Me/</id>
    <published>2020-04-04T08:51:12.000Z</published>
    <updated>2020-04-04T14:16:41.355Z</updated>
    
    <content type="html"><![CDATA[<ul><li>A acmer, live in liaocheng,China</li><li>70%山东+20%四川+10%深圳=Me<br>姓名：Jozky<br>现居：聊城<br>大学：QDU<br>QQ:2830872914<br><img src="https://img-blog.csdnimg.cn/20200404170050150.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;A acmer, live in liaocheng,China&lt;/li&gt;
&lt;li&gt;70%山东+20%四川+10%深圳=Me&lt;br&gt;姓名：Jozky&lt;br&gt;现居：聊城&lt;br&gt;大学：QDU&lt;br&gt;QQ:2830872914&lt;br&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="介绍" scheme="http://Jozky.top/categories/%E4%BB%8B%E7%BB%8D/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客练习赛60--斩杀线计算大师</title>
    <link href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/"/>
    <id>http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B60-%E6%96%A9%E6%9D%80%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%A4%A7%E5%B8%88/</id>
    <published>2020-04-02T12:57:47.000Z</published>
    <updated>2020-04-04T15:08:57.805Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4853/D" target="_blank" rel="noopener">题目传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,<br>64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。<br>数据保证一定存在解。如果存在多组解，输出任意一组。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>一行四个整数分别表示a,b,c,k</p></blockquote><p>输出描述:</p><blockquote><p>一行输出三个整数分别表示x,y,z</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 20</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure><p>备注:<br>1 ≤ a , b , c ≤ 1e5<br>0 ≤ k ≤ 1e12</p><ul><li>题意：</li></ul><p>就是多少个a+多少个b+多少个c=k<br>问你这个“多少个”分别是什么</p><p> <strong>题解</strong></p><ol><li>方法一</li></ol><p>把题目改成公式形式就是<br>ax+by+cz=k<br>没错，其实就是exgcd，只不过exgcd是ax+by=k<br>你把咱们这个式子再变变形<br>就能得到：<br>a x + b y = k - c * z<br>而这个z我们可以枚举<br>那就是a x + b y = k - c * i<br>题目说了肯定有解，那放心枚举i就完事了<br>把后面这部分-c<em>i当做整体M<br>ax+by=M<br>然后就是exgcd的步骤<br>用exgcd求出x0,y0<br>a</em>x0+b<em>y0=GCD(a,b)<br>两边同时除以gcd（a，b）<br>(gcd(a,b)我们用w代替)<br>两边除以w，再乘c<br>a</em>x0+b<em>y0-gcd(a,b)+b</em>y*c/gcd(a,b)=c</p><p>如果w=1<br>x = x0 + b *  t<br>y = y0 - a *  t<br>且对任一正数t，皆成立<br>根据这个我们就可以求出方程所有解<br>t = b / w<br>x= ( x % t + t ) % t<br><del>有空专门整理一下exgcd原理和博客</del> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const ll mod =1e9+3;</span><br><span class="line">ll exgcd(ll a,ll b,ll &amp;x,ll &amp;y)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!b)</span><br><span class="line">&#123;</span><br><span class="line">x=1;</span><br><span class="line">y=0;</span><br><span class="line"><span class="built_in">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">ll d;</span><br><span class="line">d=exgcd(b,a%b,y,x);</span><br><span class="line">y=y<span class="_">-a</span>/b*x;</span><br><span class="line"><span class="built_in">return</span> d;</span><br><span class="line">&#125;//exgcd模板 </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ll a,b,c,k,x,y;</span><br><span class="line">scanf(<span class="string">"%lld%lld%lld%lld"</span>,&amp;a,&amp;b,&amp;c,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(ll i=0;i&lt;k/c;i++)</span><br><span class="line">&#123;</span><br><span class="line">ll ans=(k-i*c);//去掉c*i的剩余部分</span><br><span class="line">ll w = exgcd(a,b,x,y);</span><br><span class="line"><span class="keyword">if</span>(ans%w)<span class="built_in">continue</span>;</span><br><span class="line"></span><br><span class="line">x= x * ans / w;</span><br><span class="line">y= y * ans / w;</span><br><span class="line"></span><br><span class="line">x=( x % ( b / w ) + ( b / w ) ) % ( b / w );</span><br><span class="line">y= ( ans - x * a ) / b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&gt;=0&amp;&amp;y&gt;=0)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="string">" "</span>&lt;&lt;i;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法二</li></ol><p>公式还有个变形方式：<br>k-ax-by=cz<br>(k-ax-by)/c=z<br>也就是( k - a x - b y ) % c = = 0<br> ( k - a i - b j ) % c = = 0<br> 枚举i和j就ok了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span>(j)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>( k - a i - b j ) % c = = 0</span><br><span class="line"> &#123;</span><br><span class="line"> cout&lt;&lt;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>曾经noip好像考过ecgcd裸题感兴趣可以做做</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4853/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K Special Judge,&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;算术能力是每个炉石玩家必不可少的，假设现在有三种伤害卡，伤害值分别是a,b,c。并且每种伤害卡的数量你可以认为是无限的。现在牛牛想知道是否存在一种方式可以刚好造成k点伤害，输出x,y,z分别表示三种伤害卡的使用个数。&lt;br&gt;数据保证一定存在解。如果存在多组解，输出任意一组。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="exgcd" scheme="http://Jozky.top/tags/exgcd/"/>
    
  </entry>
  
  <entry>
    <title>序列自动机</title>
    <link href="http://jozky.top/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/"/>
    <id>http://jozky.top/2020/04/02/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA-1/</id>
    <published>2020-04-02T05:28:45.000Z</published>
    <updated>2020-04-04T14:52:31.131Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<br>给你a和b两个字符串，问b是不是a的子序列？</p><ul><li>题解：<br><a href="https://ac.nowcoder.com/discuss/396686" target="_blank" rel="noopener">参考题解</a><br>注意看，子序列不是子串，两者含义不一样</li></ul><blockquote><p>一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S<br>通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。</p></blockquote><a id="more"></a><p>可以理解成：abc是abcd的子串，abc是adbewc的子序列，而非子串<br>求子串可以用kmp<br>那求子序列就用今天要讲的序列自动机<br>字符串A：abcdefgh<br>字符串B：aez<br>当a匹配过后，再去枚举后面的bcd没有意义，因为我们要找的是A中是否要aez三个字符，并且是这样的顺序，无须是连着的。如果我们能在a之后直接跳到a后面的一个e，再跳到e后面第一个z，等到子串B遍历完，或者在a中找不到了，我们就可以结束啦。<br>注意：我们在往后跳找字母时，比如a后面有很多个e，那么我们选第一个，因为如果第一个不行的话，那第二个第三个也白瞎，我们选的越往前其实选择空间就越大<br>仔细想想怎么能实现跳跃查找这个呢：<br>开个数组next[i][j]表示主串第i个字母之后的第一个‘a’+j的坐标，<br>next的维护只需要从后向前扫描主串，到第i位时维护一个数组last[j]，j表示对应的‘a’~‘z’，last反映的是最靠前的字母j在哪里，然后把值赋给next就ok了<br>这样查找时顺着走就可以了<br>每次匹配B复杂度是O（|B|），<br>总复杂度O(26|A|+|B|)，因为A要用26个字母都循环一遍所以是26|A|<br>可以通过下图理解<br><img src="https://img-blog.csdnimg.cn/20200402131626533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>模板：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn = 1e6 + 10;</span><br><span class="line">int n, t, next[maxn][30];</span><br><span class="line">char s[maxn], str[maxn];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">scanf(<span class="string">"%s"</span>, s+1);</span><br><span class="line">int len = strlen(s+1);</span><br><span class="line"><span class="keyword">for</span>(int i=len; i; i--) &#123;</span><br><span class="line"><span class="keyword">for</span>(int j=0; j&lt;26; j++) </span><br><span class="line">&#123;</span><br><span class="line">next[i-1][j] = next[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next[i-1][s[i]-<span class="string">'a'</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">scanf(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">scanf(<span class="string">"%s"</span>, str);</span><br><span class="line">int lenc = strlen(str), f = 0;</span><br><span class="line">int now=0;</span><br><span class="line"><span class="keyword">for</span>(int i=0; i&lt;lenc; i++)&#123;</span><br><span class="line">now = next[now][str[i]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(!now) &#123;</span><br><span class="line">f = 1;</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f) puts(<span class="string">"No"</span>);</span><br><span class="line"><span class="keyword">else</span> puts(<span class="string">"Yes"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：&lt;br&gt;给你a和b两个字符串，问b是不是a的子序列？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题解：&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/discuss/396686&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考题解&lt;/a&gt;&lt;br&gt;注意看，子序列不是子串，两者含义不一样&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一个字符串 s 被称作另一个字符串 S 的子串，表示 s 在 S中出现了。  一个字符串 s被称作另一个字符串 S 的子序列，说明从序列 S&lt;br&gt;通过去除某些元素但不破坏余下元素的相对位置（在前或在后）可得到序列 s 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="序列自动机" scheme="http://Jozky.top/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月2日 月月查华华的手机</title>
    <link href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/"/>
    <id>http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/</id>
    <published>2020-04-02T05:20:40.000Z</published>
    <updated>2020-04-04T14:55:19.468Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/23053" target="_blank" rel="noopener">牛客网链接</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述</p><blockquote><p>月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。<br>月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。<br>现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行输入一个字符串A表示华华的昵称。 第二行输入一个正整数N表示华华的推荐好友的个数。<br>接下来N行，每行输入一个字符串BiB_iBi​表示某个推荐好友的昵称。</p></blockquote><p>输出描述:</p><blockquote><p>输出N行，对于第i个推荐好友，如果华华可能向她搭讪，输出Yes，否则输出No。 注意大写，同时也要注意输出效率对算法效率的影响。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">noiauwfaurainairtqltqlmomomo</span><br><span class="line">8</span><br><span class="line">rain</span><br><span class="line">air</span><br><span class="line">tql</span><br><span class="line">ntt</span><br><span class="line">xiaobai</span><br><span class="line">oiiiooo</span><br><span class="line">orzcnzcnznb</span><br><span class="line">ooooo</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><p>备注:<br><img src="https://img-blog.csdnimg.cn/20200402104928886.png" alt="在这里插入图片描述"><br><strong><em>题解：</em></strong><br>字符串问题<br>有两个解决方法，字典树和序列自动机都能做（我想到的）<br>这里就不讲字典树了<br>序列自动机：<br>序列自动机就是用一个数组next[i][j]来记录数组a第i位的字符j在i后第一次出现的坐标。<br>设串长为n,字符集大小为a，预处理时间复杂度为O(n*a)<br><a href="https://jozky.gitee.io/2020/04/02/序列自动机/" target="_blank" rel="noopener" title="序列自动机详细讲解">https://jozky.gitee.io/2020/04/02/序列自动机/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(int i=n;i;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=1;j&lt;=a;j++) next[i-1][j]=next[i][j];</span><br><span class="line">next[i-1][s[i]]=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include&lt;string&gt;</span></span><br><span class="line"><span class="comment">#include&lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include&lt;algorithm&gt; </span></span><br><span class="line"><span class="comment">#define forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">#define fore(n) for(int j=1;j&lt;=n;j++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int ma=1000004;</span><br><span class="line">char a[ma];</span><br><span class="line">int len;</span><br><span class="line">int w=0;</span><br><span class="line">int m;</span><br><span class="line">bool f=1;</span><br><span class="line">int next[ma][30];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;(a+1);</span><br><span class="line">int len=strlen(a+1);</span><br><span class="line"><span class="keyword">for</span>(int i=len;i&gt;=1;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=0;j&lt;=25;j++) next[i-1][j]=next[i][j];</span><br><span class="line">next[i-1][a[i]-<span class="string">'a'</span>]=i;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">char ch=getchar();</span><br><span class="line">forr(m)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;(a+1);</span><br><span class="line">len=strlen(a+1);</span><br><span class="line"> w=0;</span><br><span class="line">f=1;</span><br><span class="line">fore(len)</span><br><span class="line">&#123;</span><br><span class="line">w=next[w][a[j]-<span class="string">'a'</span>];</span><br><span class="line"><span class="keyword">if</span>(w==0)</span><br><span class="line">&#123;</span><br><span class="line">f=0;</span><br><span class="line">cout&lt;&lt;<span class="string">"N0"</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f!=0)cout&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/23053&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;月月和华华一起去吃饭了。期间华华有事出去了一会儿，没有带手机。月月出于人类最单纯的好奇心，打开了华华的手机。哇，她看到了一片的QQ推荐好友，似乎华华还没有浏览过。月月顿时醋意大发，出于对好朋友的关心，为了避免华华浪费太多时间和其他网友聊天，她要删掉一些推荐好友。但是为了不让华华发现，产生猜疑，破坏了他们的友情，月月决定只删华华有可能搭讪的推荐好友。&lt;br&gt;月月熟知华华搭讪的规则。华华想与某个小姐姐搭讪，当且仅当小姐姐的昵称是他的昵称的子序列。为了方便，华华和小姐姐的昵称只由小写字母构成。为了更加方便，保证小姐姐的昵称长度不会比华华的长。&lt;br&gt;现在月月要快速的判断出哪些推荐好友要删掉，因为华华快回来了，时间紧迫，月月有点手忙脚乱，所以你赶紧写个程序帮帮她吧！&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="序列自动机" scheme="http://Jozky.top/tags/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Recordering the Cows</title>
    <link href="http://jozky.top/2020/04/01/Recordering-the-Cows/"/>
    <id>http://jozky.top/2020/04/01/Recordering-the-Cows/</id>
    <published>2020-04-01T14:05:21.000Z</published>
    <updated>2020-04-04T14:52:30.270Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/4860/B" target="_blank" rel="noopener">牛客网传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>Farmer John’s N cows (1 &lt;= N &lt;= 100), conveniently numbered 1..N, are<br>standing in a row. Their ordering is described by an array A, where<br>A(i) is the number of the cow in position i. Farmer John wants to<br>rearrange them into a different ordering for a group photo, described<br>by an array B, where B(i) is the number of the cow that should end up<br>in position i.</p></blockquote><a id="more"></a><blockquote><p>For example, suppose the cows start out ordered as follows:</p><p>A = 5 1 4 2 3</p><p>and suppose Farmer John would like them instead to be ordered like<br>this:</p><p>B = 2 5 3 1 4</p><p>To re-arrange themselves from the “A” ordering to the “B” ordering,<br>the cows perform a number of “cyclic” shifts. Each of these cyclic<br>shifts begins with a cow moving to her proper location in the “B”<br>ordering, displacing another cow, who then moves to her proper<br>location, displacing another cow, and so on, until eventually a cow<br>ends up in the position initially occupied by the first cow on the<br>cycle. For example, in the ordering above, if we start a cycle with<br>cow 5, then cow 5 would move to position 2, displacing cow 1, who<br>moves to position 4, displacing cow 2, who moves to position 1, ending<br>the cycle. The cows keep performing cyclic shifts until every cow<br>eventually ends up in her proper location in the “B” ordering. Observe<br>that each cow participates in exactly one cyclic shift, unless she<br>occupies the same position in the “A” and “B” orderings.</p><p>Please compute the number of different cyclic shifts, as well as the<br>length of the longest cyclic shift, as the cows rearrange themselves.</p></blockquote><p>输入描述:</p><blockquote><ul><li><p>Line 1: The integer N.</p></li><li><p>Lines 2..1+N: Line i+1 contains the integer A(i).</p></li><li><p>Lines 2+N..1+2N: Line 1+N+i contains the integer B(i)</p></li></ul></blockquote><p>输出描述:</p><blockquote><ul><li>Line 1: Two space-separated integers, the first giving the number of cyclic shifts and the second giving the number cows involved in the<br>longest such shift.  If there are no cyclic shifts, output -1 for the<br>second number.</li></ul></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><p><strong>题意：</strong><br>比如样例：通过移动A，将A=B<br>A     5 1 4 2 3<br>B   2 5 3 1 4<br>id   1 2 3 4 5<br>首先A中5要到1的位置（id=2），然后1移动到2的位置上（id=4），2要移动到5的位置上上（id=1）就是一个环，5-&gt;1-&gt;2-&gt;5，移动次数为3（也就是环的长度），除此之外还有4-&gt;3-&gt;4,移动次数为2，问将A通过移动转化成B的过程中，最长移动次数（即最长的环）是多少？环的数量是多少？<br><strong>题解：</strong><br><strong>（第一二个代码讲述的是我做错的过程，正解在是第三个）</strong><br><del>这题是我难以忘记的痛o(╥﹏╥)o</del><br><img src="https://img-blog.csdnimg.cn/20200330140321589.png" alt="在这里插入图片描述">看完这个题第一反应是noip考过的信息传递，所以一开始就用并查集来做，father[A[id]]=B[id]（就是id相对于A的父亲节点是B），因为一定能成环，所以就找一共多少个环，并求出最长环的长度<br>然而。。。。<img src="https://img-blog.csdnimg.cn/20200330140749959.png" alt="在这里插入图片描述"><br>我调了一阵子也但还是段错误，我换了个oj测评一下，然后就就AC了。。。玄学（<del>可能这个oj数据弱</del> ）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10000];</span><br><span class="line">int b[194000];</span><br><span class="line">int father[10003];</span><br><span class="line">bool f[100004];</span><br><span class="line">int maxx=0;</span><br><span class="line">void unionn(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    father[x]=y;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x,int z)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;//如果这个数在A中与B中位置相同，不需要交换</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;//如果这个数曾经被查询过</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;//如果这个环第一次被查询</span><br><span class="line">    z++;//z只有0和非0，来表示这个数之前是否被查询过</span><br><span class="line">    f[x]=1;</span><br><span class="line">    maxx=max(maxx,z);</span><br><span class="line">    find(father[x],z);//不断地向后查找5-&gt;1-&gt;2</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">        unionn(a[j],b[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(find(i,0))ant++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我痛定思痛，感觉是因为自身递归导致段错误，又改了一个思路，在寻找根节点并压缩路径的时候，顺便用dis来记录路径的长度，然后统计出最长的路径。<br>结果没段错误，但。。。wa了。。唉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">bool f[10034];//标记这个点所在的环是否被查询过</span><br><span class="line">int dis[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//  father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        father[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(father[x]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        int last=father[x];</span><br><span class="line">        father[x]=find(father[x]);</span><br><span class="line">        dis[x]+=dis[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> father[x];</span><br><span class="line">&#125;</span><br><span class="line">void unionn(int aa,int bb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">    int x=find(aa);</span><br><span class="line">    int y=find(bb);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)</span><br><span class="line">    &#123;</span><br><span class="line">        father[x]=y;</span><br><span class="line">        dis[aa]=dis[bb]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);//更新最长边</span><br><span class="line">&#125;</span><br><span class="line">//int find(int x,int z)</span><br><span class="line">//&#123;</span><br><span class="line">//  <span class="keyword">if</span>(father[x]==x)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z==0)<span class="built_in">return</span> 0;</span><br><span class="line">//  <span class="keyword">else</span> <span class="keyword">if</span>(f[x]==1&amp;&amp;z!=0)<span class="built_in">return</span> 1;</span><br><span class="line">//  z++;</span><br><span class="line">//  f[x]=1;</span><br><span class="line">//  maxx=max(maxx,z);</span><br><span class="line">//  find(father[x],z);</span><br><span class="line">//&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;b[j];</span><br><span class="line">    &#125;</span><br><span class="line">    init();</span><br><span class="line">    int tot=0;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">        <span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tot==0)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int ant=0;//多少个环</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">         </span><br><span class="line">        unionn(a[i],b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">        &#123;</span><br><span class="line">            ant++;</span><br><span class="line">            f[father[i]]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我冷静一会后，重新思考，感觉把题越想越复杂了<br>样例：<br>A 5 1 4 2 3<br>B 2 5 3 1 4<br>f[]来标记id是否被查询过<br>我们用fa和fb来记录A和B中数的id位置，然后在union时,通过father[]来让 A中的点对应B的位置相互指向，A中id=1的5指向id=2的1，father[5]=1,依次类推<br>A    ——-&gt;5 1 4 2 3<br>fa——-&gt;2 4 5 3 1<br>B——–&gt;2 5 3 1 4<br>fb——–&gt;4 1 3 5 2<br>father—&gt;2 4 5 1 3<br>在查找时for(i-&gt;n),查询该点i后，接着查与这点i相连的点father[i]，并用f[]标记，ans记录长度，如果相连的点&gt;2(也就是这个点不是指向自己)，统计最长环长，并记录换的数量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">int n;</span><br><span class="line">int a[10030];</span><br><span class="line">int b[19333];</span><br><span class="line">int father[100333];</span><br><span class="line">int fa[10034];</span><br><span class="line">int fb[10034];</span><br><span class="line">int f[100022];</span><br><span class="line">int maxx=0;</span><br><span class="line">int ans;</span><br><span class="line">int id;</span><br><span class="line">int tot=0;</span><br><span class="line">int w=0;</span><br><span class="line">int find()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i]==0)</span><br><span class="line">&#123;</span><br><span class="line">id=i;</span><br><span class="line">ans=0;</span><br><span class="line"><span class="keyword">while</span>(f[id]==0)</span><br><span class="line">&#123;</span><br><span class="line">f[id]=1;</span><br><span class="line">ans++;</span><br><span class="line">id=father[id];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">tot=max(ans,tot);</span><br><span class="line">w++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line">fa[a[i]]=i;</span><br><span class="line">fb[b[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void init1()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">father[fa[a[i]]]=fb[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//void unionn(int x,int y)</span><br><span class="line">//&#123;</span><br><span class="line">//father[x]=y;</span><br><span class="line">//&#125;</span><br><span class="line">//void unionn(int aa,int bb)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(aa==bb)<span class="built_in">return</span>;</span><br><span class="line">//int x=find(aa);</span><br><span class="line">//int y=find(bb);</span><br><span class="line">//<span class="keyword">if</span>(x!=y)</span><br><span class="line">//&#123;</span><br><span class="line">//father[x]=y;</span><br><span class="line">//dis[aa]=dis[bb]+1;</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">else</span> maxx=max(maxx,dis[aa]+dis[bb]+1);</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(a[i]!=b[i])tot++;</span><br><span class="line">//<span class="keyword">else</span> f[a[i]]=1;</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">if</span>(tot==0)</span><br><span class="line">//&#123;</span><br><span class="line">//cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line">//<span class="built_in">return</span> 0;</span><br><span class="line">//&#125;</span><br><span class="line">//int ant=0;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//</span><br><span class="line">//unionn(a[i],b[i]);</span><br><span class="line">//&#125;</span><br><span class="line">//<span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">//&#123;</span><br><span class="line">//<span class="keyword">if</span>(f[father[i]]==0)</span><br><span class="line">//&#123;</span><br><span class="line">//ant++;</span><br><span class="line">//f[father[i]]=1;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//cout&lt;&lt;ant&lt;&lt;<span class="string">" "</span>&lt;&lt;maxx;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line"></span><br><span class="line">init();</span><br><span class="line">init1();</span><br><span class="line"><span class="keyword">if</span>(find()==0)cout&lt;&lt;0&lt;&lt;<span class="string">" "</span>&lt;&lt;-1;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;w&lt;&lt;<span class="string">" "</span>&lt;&lt;tot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终于做出来了。。。我太菜了o(╥﹏╥)o</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4860/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Farmer John’s N cows (1 &amp;lt;= N &amp;lt;= 100), conveniently numbered 1..N, are&lt;br&gt;standing in a row. Their ordering is described by an array A, where&lt;br&gt;A(i) is the number of the cow in position i. Farmer John wants to&lt;br&gt;rearrange them into a different ordering for a group photo, described&lt;br&gt;by an array B, where B(i) is the number of the cow that should end up&lt;br&gt;in position i.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="并查集" scheme="http://Jozky.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>牛客网2020愚人节比赛</title>
    <link href="http://jozky.top/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/"/>
    <id>http://jozky.top/2020/04/01/%E7%89%9B%E5%AE%A2%E7%BD%912020%E6%84%9A%E4%BA%BA%E8%8A%82%E6%AF%94%E8%B5%9B/</id>
    <published>2020-04-01T14:01:50.000Z</published>
    <updated>2020-04-04T14:52:31.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="牛客2020年愚人节比赛2020-4-1-21-32-11"><a href="#牛客2020年愚人节比赛2020-4-1-21-32-11" class="headerlink" title="牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 "></a>牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 </h2><p><del>欢乐的一晚上</del><br><a href="https://ac.nowcoder.com/acm/contest/4863#question" target="_blank" rel="noopener">题目链接</a><br>其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感<br><img src="https://img-blog.csdnimg.cn/20200401211211311.png" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200401211308221.png" alt="在这里插入图片描述">不知道这是哪位哥的，心疼一下</p><a id="more"></a><p><strong>题解</strong><br>注：一下题解没必要较劲，欢乐局而已<br>对不对无所谓，换了最重要奥<br>A题rand36：<br>我试了好几个数，最后3过了，以为答案3，结果发现答案是随机的，看命了有人一下就过。。。<br>B寻宝游戏：<br>要找的宝贝就在宝藏图上，输出题目中图的地址就ac了<br>C老铁安排上：<br>看图是什么手机？老年机，所以是九字输入法，字母按照九字输入法的对应数字<br>D神奇的字母<br>输出题目中的样例<br>“一个字符，表示神奇的字母（范围从’a’到’z’，保证小写）。”<br>即可<br>E return1；<br>不会（笑哭）貌似场上唯一一个没人做出来的题<br>F 抬头，答案在天上<br>天上就是指你浏览器的上面，也就是网址，按照顺序对应相应的数字<br>G抬头在地上<br>就是看字地下的标点符号，你会发现有个标点符号是超链接，输出超链接地址即可<br>H园<br>问你能套多少园，可没说不能套娃哦<del>，n是几就能套几个<br>I牛客搜索题<br>这里面最扯的题（个人感觉<img src="https://img-blog.csdnimg.cn/20200401212525727.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">）<br>J签到题<br>不会（笑哭）<br>K四万像素五角星<br>有个大佬手打出来了。。。<br>L positive-integer<br>经过证明<br>n=1时，输出1；<br>其他输出0<br>证明过程嘛。。。（</del>多尝试几次就OK了，不怕失败，都wa了多少次了）~~<br>好像官方出题解了，看官方题解吧<br><a href="https://ac.nowcoder.com/discuss/396514?type=101&order=0&pos=5&page=1" target="_blank" rel="noopener">题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;牛客2020年愚人节比赛2020-4-1-21-32-11&quot;&gt;&lt;a href=&quot;#牛客2020年愚人节比赛2020-4-1-21-32-11&quot; class=&quot;headerlink&quot; title=&quot;牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 &quot;&gt;&lt;/a&gt;牛客2020年愚人节比赛2020/4/1 21 : 32 : 11 &lt;/h2&gt;&lt;p&gt;&lt;del&gt;欢乐的一晚上&lt;/del&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/4863#question&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;其实做做也挺好，脑筋急转弯，不需要算法不需要数据结构，纯娱乐，wa的快感&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211211311.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;)&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211222213.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;)&lt;img src=&quot;https://img-blog.csdnimg.cn/20200401211308221.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;不知道这是哪位哥的，心疼一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="欢乐局" scheme="http://Jozky.top/tags/%E6%AC%A2%E4%B9%90%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>滑动窗口</title>
    <link href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <id>http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</id>
    <published>2020-04-01T02:13:38.008Z</published>
    <updated>2020-04-06T15:03:23.571Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br> 空间限制：C/C++ 32768K  其他语言 65536K<br> 64bit IO Format:%lld</p><p><a href="https://ac.nowcoder.com/acm/problem/50528" target="_blank" rel="noopener">牛客网</a><br><a href="https://www.luogu.com.cn/problem/P1886" target="_blank" rel="noopener">洛谷</a><br> <strong>题目描述</strong><br>给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：</p></blockquote><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200329120250163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><blockquote><p>你的任务是找出窗体在各个位置时的最大值和最小值。</p></blockquote><p>输入描述:</p><blockquote><p>第1行：两个整数N和K； 第2行：N个整数，表示数组的N个元素(≤2×10^9^)；</p></blockquote><p>输出描述:</p><blockquote><p>第一行为滑动窗口从左向右移动到每个位置时的最小值，每个数之间用一个空格分开；<br>第二行为滑动窗口从左向右移动到每个位置时的最大值，每个数之间用一个空格分开。</p></blockquote><p>示例1<br>输入<br>8 3<br>1 3 -1 -3 5 3 6 7<br>输出<br>-1 -3 -3 -3 3 3<br>3 3 5 5 6 7<br>备注:<br>对于20%的数据，K≤N≤1000；<br>对于50%的数据，K≤N≤10^5^<br>对于100%的数据，K≤N≤10^6^<br><strong>题解：</strong><br>老题了。。<br>（<del>想起来我当年逝去的OI梦</del> ）</p><p>赶紧从洛谷找到以前的代码<br>就是单调队列的模板题<br><del>手写就完事了</del> </p><p>构造一个单调队列，<br>我们来模拟下过程：<br>（以求最小为例）<br>head指向头，tail指向尾<br>a[]是我们一开始存放的数<br>mi存放的是最小值的坐标（即 i ）<br>i是指向数组a当前位置<br>m=3<br>例如 1 3 -1<br>坐标 1 2  3<br>1和3顺利存入mi中（存的是坐标）mi={1,2}；<br>读入-1时与前面的进行比较，-1&lt;3然后tail–，-1&lt;1,tail–,直到整个区间都比完（也就是tail大于head时），或者是出现比-1还小的数x，tail就在x的位置停下来。然后将-1的坐标存入到mi[++tail]中,说明从tail之后没有比-1还小的了.<br>m=3<br>例如1 2 4 5 4<br>如果读入的数没有比之前小的，就依次读入mi中，mi=[1,2,3],head=1;当i=4时,就超出m的范围时（mi[head]+m&lt;=i），就将区间向后移动（head++，头向后移动，整个区间也跟着移动），随着输出（将多的输出来）<br>然后一直循环就可以了。<br>head指的是mi，mi反应的是当前最小值在a中的坐标<br>也可以写两个数组来一个表示单调队列，一个表示对应的在原列表里的序号，我这就用了一个。<br>（话说线段树也可以做）<br><del>讲的我自己也有点乱，明白但是讲不大出来，结合者代码看吧</del> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define for(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e6+3;</span><br><span class="line">int a[maxn];</span><br><span class="line">int ma[maxn];</span><br><span class="line">int mi[maxn]; </span><br><span class="line">void min(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int head=1;</span><br><span class="line">int tail=0;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;mi[head]+m&lt;=i)</span><br><span class="line">head++;//向后移动head</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&lt;a[mi[tail]])</span><br><span class="line">tail--;//向前移动tail</span><br><span class="line"></span><br><span class="line">tail++;</span><br><span class="line">mi[tail]=i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[mi[head]]&lt;&lt;<span class="string">" "</span>;//如果元素超出就输出当前区域最小</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void max(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">int head=1;</span><br><span class="line">int tail=0;</span><br><span class="line"><span class="keyword">for</span>(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;ma[head]+m&lt;=i)head++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;a[i]&gt;a[ma[tail]])tail--;</span><br><span class="line">tail++;</span><br><span class="line">ma[tail]=i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)cout&lt;&lt;a[ma[head]]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(n)cin&gt;&gt;a[i];</span><br><span class="line">min(n,m);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">max(n,m);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt; 空间限制：C/C++ 32768K  其他语言 65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50528&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷&lt;/a&gt;&lt;br&gt; &lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;给一个长度为N的数组，一个长为K的滑动窗体从最左端移至最右端，你只能看到窗口中的K个数，每次窗体向右移动一位，如下图：&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="单调队列" scheme="http://Jozky.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
