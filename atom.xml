<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-04-14T14:39:06.221Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>树学</title>
    <link href="http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/"/>
    <id>http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/</id>
    <published>2020-04-14T14:35:39.000Z</published>
    <updated>2020-04-14T14:39:06.221Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/201400" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:&gt; %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep<del>root</del>为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep<del>i</del>=dep<del>fa</del> <del>i</del>+1,整棵树的价值W=<img src="https://img-blog.csdnimg.cn/20200414204932422.png" alt="在这里插入图片描述"> ，即所有点的深度和</p><a id="more"></a><p>牛妹希望这棵树的W最小，请你告诉她，选择哪个点可以使W最小<br>输入描述:<br>第一行，一个数，n<br>接下来n-1行，每行两个数x,y，代表x-y是树上的一条边<br>输出描述:<br>一行，一个数，最小的W<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>备注:<br>对于30%30%的数据，1&lt;= n&lt;=1000<br>对于100%100%的数据，1&lt;=n &lt;=10^6^</p><h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>树形dp+换根<br>用到的几个函数：<br>dep[i]：节点i的深度<br>ant[i]：i的子树的个数（含本身）<br>f[x]：以x为根的每个节点深度的和<br><img src="https://img-blog.csdnimg.cn/20200414211409638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图一为以u为根节点<br>图二为以v为根节点<br>从u转到v 之后，图二中黄色区域（u和子树1和子树2）根节点都加1（因为成为别人的子节点），绿色区域（v和根节点2）根节点减1（因为成为别人的根节点）<br>那转换成公式是什么样的？<br>f[v]=（f[u]-ant[v]）+(n-ant[v]);<br>怎么理解呢？<br>第一个括号里，是将图二的绿色区域根节点减一，因为黄色区域一共ant[v]个节点，这个区域内每个节点都减1，所以整个区域f[u]要减ant[v].<br>第二个括号就是黄色区域每个节点都加一，那整个区域就加这个区域的节点数，这个区域的节点数=整个区域-绿色区域，所以就是n-ant[v]<br>我们从1开始dfs，求出每个节点的深度，即dep[]<br>然后再dfs求出每个点子树数量,再dfs换成其他根，利用公式求出f来</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//链式前项星 </span></span><br><span class="line">ll head[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//无向边，所以乘2</span></span><br><span class="line">ll dep[maxn];<span class="comment">//节点的深度 </span></span><br><span class="line">ll ant[maxn];<span class="comment">//节点x的子树数量（包含本身） </span></span><br><span class="line">ll f[maxn];<span class="comment">//以i为根的时候每个点深度的和 </span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll minn=<span class="number">1e7</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++cnt].v=v;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">forr(n)f[<span class="number">1</span>]+=dep[i];<span class="comment">//在dfs1求完每个点深度后，接着求出以1为根的时候每个点深度的和  </span></span><br><span class="line">forr(n)ant[i]=<span class="number">1</span>;<span class="comment">//每个节点的子树一开始都是本身 </span></span><br><span class="line">&#125;</span><br><span class="line">ll v=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">dfs1(v,now);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//以1为根节点开始，计算出每个节点的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> dfs2(v,now);</span><br><span class="line"> ant[now]+=ant[v]; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="comment">//求出x节点的子树数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> f[v]=f[now]-ant[v]+(n-ant[v]); </span><br><span class="line"> dfs3(v,now);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1开始换成其他根，并求出其他根的f值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">init(n);<span class="comment">//初始化 </span></span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">dfs3(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,f[i]);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minn;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看会发现dfs1与dfs2结构相似，完全可以和在一起写<br>或者用vector写更简洁</p><h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p>我看有很多大佬都用重心的性质来做<br>树的重心有一个这样的性质：在树中所有点到某点的距离和 当中，到树的重心的距离和是最小的，如果有多个重心，那他们距离和一样。<br>树中所有点到重心的距离和最小，不就是我们要求的那个值吗。<br>先用dfs树形dp求出重心，再求出重心与每个点的距离进行累加求和</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ant[maxn],root[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">ll res;</span><br><span class="line">ll point=maxn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ant[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(u,v);</span><br><span class="line">            </span><br><span class="line">            ant[v]+=(ant[u]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            maxx=max(ant[u],maxx);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxx=max(n-ant[v]<span class="number">-1</span>,maxx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(maxx&lt;point)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">        point=maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxx==point)</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res+=dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">            dfs2(u,v,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关树的重心其他性质，有空专门讲讲</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/201400&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format:&amp;gt; %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep&lt;del&gt;root&lt;/del&gt;为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep&lt;del&gt;i&lt;/del&gt;=dep&lt;del&gt;fa&lt;/del&gt; &lt;del&gt;i&lt;/del&gt;+1,整棵树的价值W=&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414204932422.png&quot; alt=&quot;在这里插入图片描述&quot;&gt; ，即所有点的深度和&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="换根" scheme="http://Jozky.top/tags/%E6%8D%A2%E6%A0%B9/"/>
    
      <category term="树的重心" scheme="http://Jozky.top/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>使用一段时间牛客网的心得</title>
    <link href="http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/</id>
    <published>2020-04-13T16:06:43.000Z</published>
    <updated>2020-04-14T14:39:10.022Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（<del>心痛</del> ）<br>牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉<br>一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。<br>等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200414000658411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414000643124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>背包等着我<del>~</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（&lt;del&gt;心痛&lt;/del&gt; ）&lt;br&gt;牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉&lt;br&gt;一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。&lt;br&gt;等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="文章" scheme="http://Jozky.top/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月9日题目精讲 Running Median</title>
    <link href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/"/>
    <id>http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/</id>
    <published>2020-04-12T16:32:26.000Z</published>
    <updated>2020-04-12T16:33:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://ac.nowcoder.com/acm/problem/50940" target="_blank" rel="noopener">–&gt;链接&lt;—</a></p><blockquote><p>时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit<br> IO Format:%lld</p></blockquote><p>题目描述 </p><blockquote><p>For this problem, you will write a program that reads in a sequence of<br>32-bit signed integers. After each odd-indexed value is read, output<br>the median (middle value) of the elements received so far.</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>The first line of input contains a single integerP(1≤P≤1000), which is the number of data sets that follow. The<br>first line of each data set contains the data set number, followed by<br>a space, followed by an odd decimal integer (1≤M≤9999), giving the total number of signed integers to be<br>processed. The remaining line(s) in the dataset consists of the<br>values, 10 per line, separated by a single space. The last line in the<br>dataset may contain less than 10 values.</p></blockquote><p>输出描述:</p><blockquote><p>For each data set the first line of output contains the data set<br>number, a single space and the number of medians output (which should<br>be one-half the number of input values plus one). The output medians<br>will be on the following lines, 10 per line separated by a single<br>space. The last line may have less than 10 elements, but at least 1<br>element. There should be no blank lines in the output.</p></blockquote><p>示例1<br>输入<br>3<br>1 9<br>1 2 3 4 5 6 7 8 9<br>2 9<br>9 8 7 6 5 4 3 2 1<br>3 23<br>23 41 13 22 -3 24 -31 -11 -8 -7<br>3 5 103 211 -311 -45 -67 -73 -81 -99<br>-33 24 56<br>输出<br>1 5<br>1 2 3 4 5<br>2 5<br>9 8 7 6 5<br>3 12<br>23 23 22 22 13 3 5 5 3 -3<br>-7 -3</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你m个数，一次输入，每当输入的个数为奇数时，输出按大小排列最中间的数<br>比如1 5 6 7 8<br>一开始输入1，输出1<br>然后输入1 5，不输出<br>输入1 5 6，输出5<br>输入1 5 6 7，不输出<br>输入1 5 6 7 8，输出6</p><h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>可以用堆来做<br>w1为大堆，w1用于存放小值<br>w2为小堆，w2存放大值<br>比如上面那个例子1 5 6 7 8<br>奇数位存在w1，偶数存在w2<br>如果w1.top()&gt;w2.top(),就是w1的最大比w2的最小值大，就将这两个值互换，始终保证，w1的值比w2的任意一个都小，这样无论数据怎么读入，w1的最大值始终都是最中间的数<br>看下面模拟：<br>第一轮：<br>w1:1<br>w2：0<br>二：<br>w1:1<br>w2:5<br>三：<br>w1:1 6<br>w2:5<br>6&gt;5<br>w1:1 5<br>w2:6<br>四<br>w1:1 5<br>w2: 7 6<br>五<br>w1:1 5 8<br>w2: 7 6<br>8&gt;6<br>w1:1 5 6<br>w2; 7 8<br>这样每奇数轮，w1的top位就是答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;w1;<span class="comment">//默认为大堆，从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;w2;<span class="comment">//默认为小堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">  <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p,m,x;</span><br><span class="line">    <span class="keyword">int</span> minn,maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;m;</span><br><span class="line">        case1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p,m/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)w1.push(x);</span><br><span class="line">            <span class="keyword">else</span> w2.push(x);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                minn=w1.top();</span><br><span class="line">                maxx=w2.top();</span><br><span class="line">                <span class="keyword">if</span>(minn&gt;maxx)</span><br><span class="line">                &#123;</span><br><span class="line">                    w1.pop();</span><br><span class="line">                    w2.pop();</span><br><span class="line">                    w1.push(maxx);</span><br><span class="line">                    w2.push(minn);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(case1!=<span class="number">0</span>&amp;&amp;case1%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                case1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==m)<span class="built_in">cout</span>&lt;&lt;w1.top();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,w1.top());</span><br><span class="line">                case1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(!w1.empty())w1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!w2.empty())w2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这个题的格式我一开始一直没注意。。。）</p><h2 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h2><p>我看很多人都是这么做的，但是只能过50%的数据。。包括我自己<br>我看了清楚姐姐的代码稍微改一下：<br>我们在读入一个数后，直接与w1.top比较，小于就存进去，大了就存w2里<br>当w1的数量多了，就把堆顶拿出给w2（小根堆）<br>w2多了就给大根堆<br>这样维护出来其实和上面的方法差不多<br>因为总数是奇数，两个堆数量一定不一样，多的那方，堆顶就是答案<br>代码：<br>清楚阿姨（<del>狗头</del> ）代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//小根堆 ，存较大的一半的数</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">//大根堆 ，存较小的一半的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty()) q2.pop();  <span class="comment">//优先队列没有clear函数，要一个一个弹出</span></span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m ,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m, (n+<span class="number">1</span>)/ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &lt;= q1.top()) q1.push(x); <span class="comment">//如果当前值比大根堆堆顶小，说明在小的这二分之一，塞进大根堆</span></span><br><span class="line">            <span class="keyword">else</span>  q2.push(x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> num1= q1.size();</span><br><span class="line">            <span class="keyword">int</span> num2= q2.size();</span><br><span class="line">            <span class="keyword">if</span> (num1 - num2 &gt; <span class="number">1</span>)   <span class="comment">//大根堆里面元素多了，把堆顶拿出来塞近小根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.top());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(num2 - num1 &gt;<span class="number">1</span>) <span class="comment">//小根堆里面元素多了，把堆顶拿出来塞近大根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.top());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//目前的元素个数是奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                num1 = q1.size();</span><br><span class="line">                num2 = q2.size();</span><br><span class="line">                <span class="keyword">if</span>(num1 &gt; num2) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q1.top()); <span class="comment">//中位数在大根堆</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, q2.top());           <span class="comment">//中位数在小根堆</span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">19</span> &amp;&amp; i!=n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;–&amp;gt;链接&amp;lt;—&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit&lt;br&gt; IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this problem, you will write a program that reads in a sequence of&lt;br&gt;32-bit signed integers. After each odd-indexed value is read, output&lt;br&gt;the median (middle value) of the elements received so far.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="堆" scheme="http://Jozky.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>浅谈LCA</title>
    <link href="http://jozky.top/2020/04/12/%E6%B5%85%E8%B0%88LCA/"/>
    <id>http://jozky.top/2020/04/12/%E6%B5%85%E8%B0%88LCA/</id>
    <published>2020-04-12T09:30:59.000Z</published>
    <updated>2020-04-12T10:21:22.428Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="LCA介绍"><a href="#LCA介绍" class="headerlink" title="LCA介绍"></a>LCA介绍</h2><p>lca是啥？最近公共祖先<br>就是：两个点在这棵树上距离最近的公共祖先节点<br>LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）<br>来看一个经典图<br><img src="https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>LCA（4,5）=2<br>LCA（4,3）=1<br>LCA（2,1）=1</p><h2 id="解决方法概括："><a href="#解决方法概括：" class="headerlink" title="解决方法概括："></a>解决方法概括：</h2><p>常用四种方法 ：</p><ol><li>用倍增法求解，预处理复杂度是 O(nlogn) ,每次询问的复杂度是 O(logn), 属于在线解法。</li><li>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)，每次询问的复杂度为 O(1)，也是在线算法。</li><li>采用Tarjan算法求解，复杂度 O(α(n)+Q)，属于离线算法。</li><li>利用树链剖分求解，复杂度预处理O(n)，单次查询 O(logn) ，属于在线算法。</li></ol><h2 id="倍增法："><a href="#倍增法：" class="headerlink" title="倍增法："></a>倍增法：</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;LCA介绍&quot;&gt;&lt;a href=&quot;#LCA介绍&quot; class=&quot;headerlink&quot; title=&quot;LCA介绍&quot;&gt;&lt;/a&gt;LCA介绍&lt;/h2&gt;&lt;p&gt;lca是啥？最近公共祖先&lt;br&gt;就是：两个点在这棵树上距离最近的公共祖先节点&lt;br&gt;LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）&lt;br&gt;来看一个经典图&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LCA" scheme="http://Jozky.top/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>牛客算法周周练1</title>
    <link href="http://jozky.top/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/"/>
    <id>http://jozky.top/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/</id>
    <published>2020-04-11T08:45:11.000Z</published>
    <updated>2020-04-11T08:45:40.650Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>幸运数字Ⅱ </title>
    <link href="http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/"/>
    <id>http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</id>
    <published>2020-04-11T08:38:26.000Z</published>
    <updated>2020-04-11T08:50:51.099Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/E" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。<br>定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r</p><ul><li>1) + next(r)。 输入描述:</li></ul><p>两个整数l和r (1 &lt;= l &lt;= r &lt;= 1000,000,000)。</p></blockquote><a id="more"></a> <p>输出描述:</p><blockquote><p>一个数字表示答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>示例2<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>题意：<br>打表出奇迹<br>你可以提前打好表，记录在数组里<br>或者现打表，有两个方法<br>一个是用vector，<br>或者自身递归查找，存在pre中<br>打完表后，直接从l开始对比数到r<br>直接if判断然后sum加有点慢<br>你可以看每两个pre之间的数最后都做一样相加，比如47~74之间（不含47）的数都算作74，那有多少个数？就是74-47+1，然后直接乘74，加起来就ok了<br>注意注意！！！不要忘了longlong，可坑死我了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll pre[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1e10</span>+<span class="number">2</span>)<span class="keyword">return</span> ; </span><br><span class="line">pre[cnt++]=n;</span><br><span class="line">dfs(n*<span class="number">10</span>+<span class="number">4</span>);</span><br><span class="line">dfs(n*<span class="number">10</span>+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(ll x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(n-1e9&gt;0)return ;</span></span><br><span class="line"><span class="comment">q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">dfs((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">dfs((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dfs(0);</span></span><br><span class="line"><span class="comment">sort(q.begin(),q.end());</span></span><br><span class="line"><span class="comment">q.push_back(4444444444); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll r,l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;l,&amp;r);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="comment">//cout&lt;&lt;pre[cnt-1]&lt;&lt;endl;</span></span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line">ll ant=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=l;i&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(i&gt;pre[ant])ant++;</span></span><br><span class="line"><span class="comment">//sum+=pre[ant];</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;pre[ant])ant++;</span><br><span class="line">sum+=pre[ant]*(min(r,pre[ant])-i+<span class="number">1</span>);</span><br><span class="line">i=pre[ant]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。&lt;br&gt;定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) + next(r)。 输入描述:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个整数l和r (1 &amp;lt;= l &amp;lt;= r &amp;lt;= 1000,000,000)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DFS" scheme="http://Jozky.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>身体训练 </title>
    <link href="http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/"/>
    <id>http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/</id>
    <published>2020-04-11T08:38:19.000Z</published>
    <updated>2020-04-11T08:50:53.483Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/B" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述</p><blockquote><p>美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v<br>米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v</p><a id="more"></a> <p>米/秒。每个人最初的最高速度为c[i] 米/秒，每轮衰减d[i]<br>米/秒，也就是说，如果i是第j个跑的，那么他的速度就是c[i]-(j-1)*d[i] 米/秒。<br>n个人初始以随机的顺序排列，每种顺序的概率完全相等，跑完一轮（每个人都追到排头一次，序列恢复原样）的期望需要的时间是多少？</p></blockquote><p>输入描述:</p><blockquote><p>第一行整数n（&lt;=1000）, 实数v(&lt;=100) , 实数u(&lt;=10) 第二行n个实数每个人的速度c<a href="<=50000">i</a><br>第三行n个实数值每个人衰减量d<a href="<=10">i</a></p><p>输入数据保证每个人的速度不会衰减到&lt;=v</p></blockquote><p>输出描述:</p><p>答案保留3位小数。</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">37.618</span> <span class="number">0.422</span></span><br><span class="line"></span><br><span class="line"><span class="number">72.865</span> <span class="number">126.767</span> <span class="number">202.680</span> <span class="number">106.102</span> <span class="number">99.516</span> <span class="number">134.418</span> <span class="number">167.952</span> <span class="number">173.646</span> <span class="number">120.210</span> <span class="number">136.571</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.941</span> <span class="number">3.664</span> <span class="number">7.363</span> <span class="number">4.161</span> <span class="number">0.246</span> <span class="number">8.046</span> <span class="number">5.521</span> <span class="number">7.473</span> <span class="number">7.178</span> <span class="number">5.649</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.815</span></span><br></pre></td></tr></table></figure><p>题解：<br>因为除了最后一个人，其他人速率相同，那么就可以把大家都看做静止的，最后一个人的速度就是V（原本）-V（其他人的速度），可以理解成相对速度<br>题目问跑完一轮，说明每个人在每个位置都会经历一遍。虽然每个快递员位置未定，在每个位置上概率都是1/n,但是无论是什么位置，快递员要跑的相对路长是一定的，都是u<em>n。<br>（相对路长就是在相对时间内跑的距离，大家都是静止的，一共n个人，最后一名前面有n-1个人，他要从最后跑到比排头还远u，跨过了n个间隙，距离是u</em>n）<br>如果i是第j个跑的，那么他的速度就是c[i]-(j-1)<em>d[i] 米/秒。v是其他人的速度<br>相对速度就是c[i]-(j-1)</em>d[i]-v<br>距离有了速度有了，相除就可以求时间<br>可以求出每个快递员跑过每个位置所需要的的时间，累加起来就可以<br>啥是期望？数学期望(mean)是试验中每次可能结果的概率乘以其结果的总和<br>所以最后再乘以概率 1/n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> c[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> v,u,sum=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v&gt;&gt;u;</span><br><span class="line">forr(n)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">forr(n)<span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=u/( c[i] - v - ( j<span class="number">-1</span> ) * d[i] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3f"</span>,sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v&lt;br&gt;米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Maximize The Beautiful Value </title>
    <link href="http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/"/>
    <id>http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/</id>
    <published>2020-04-11T08:37:37.000Z</published>
    <updated>2020-04-11T08:40:06.790Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/A" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he<br>thinks it’s not beautiful so he wants to make it beautiful. To make<br>it, HH will choose exactly one number and move it forward at least k<br>steps(i.e. you can move ai to aj if k≤i−j), and then he defines the<br>beautiful value F(n) as  HH asks you to calculate max(F(n))</p></blockquote><a id="more"></a> <blockquote><p><img src="https://uploadfiles.nowcoder.com/files/20200411/543071257_1586538298107_20200411005140649.png" alt="在这里插入图片描述"></p></blockquote><p>输入描述:</p><blockquote><p> The first line contains an positive integer T(1≤T≤10), represents<br>there are T test cases.   For each test case:   The first line<br>contains two positive integers n,k(1≤n≤105,1≤k&lt;n)，the length of the<br>sequence ,the least steps you need to move.   The second line contains<br>n integers a1,a2…an(1≤ai≤108) - the sequence.</p><p>输出描述:</p><p>For each test case, you should output the max F(n).</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure><p>说明</p><blockquote><p>In the first example, you can move the fifth number 4 for 3 steps and<br>make the sequence become [4,1,1,3,5], then the beautiful value is<br>4×1+1×2+1×3+3×4+5×5=46. You can also move the fifth number to make it<br>become [1,5,1,3,4], the beautiful value is also 46. In the second<br>example, you can move the  fifth number 5 for 2 steps and make the<br>sequence become [1,1,5,3,4] In the second example, you can move the<br>second number 1 for 1 steps and then the sequence is still [1,1,3,4,5]</p></blockquote><p>备注:</p><p>scanf is commended。</p><p> <strong>题解：</strong><br>比如：A B C D E<br>对应：1 2 3 4 5<br>此时的值为ans1=1<em>A+2<em>B+3</em>C+4<em>D+5</em>E<br>现在D移动到B前面，移动了两步<br>A D B C E<br>此时的值：ans2 = 1<em>A+2</em>D+3<em>B+4</em>C+5<em>E<br> =1</em>A+2<em>B+3</em>C+4<em>D+5</em>E-3<em>D+（B+C+D）<br>观察ans1与ans2相比有什么变化<br>发生改变就是减去这个数字的k倍，再加上被移动数字（共k个）的和<br>因为D向前移动k，说明D</em>i–&gt;D</em>(i-k)<br>BC因为D向前而被拱到后面，从B<em>i—&gt;b</em>(i+1)<br>被移动数字之和我们可以用前缀和pre实现<br>看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(w) for(int i=w;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt;a[i];</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">ans=ans+a[i]*i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>((k+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">tot=max(tot,ans-a[i]*k+(pre[i<span class="number">-1</span>]-pre[i-k<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he&lt;br&gt;thinks it’s not beautiful so he wants to make it beautiful. To make&lt;br&gt;it, HH will choose exactly one number and move it forward at least k&lt;br&gt;steps(i.e. you can move ai to aj if k≤i−j), and then he defines the&lt;br&gt;beautiful value F(n) as  HH asks you to calculate max(F(n))&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="前缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2008]仪仗队</title>
    <link href="http://jozky.top/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/"/>
    <id>http://jozky.top/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/</id>
    <published>2020-04-09T14:47:44.000Z</published>
    <updated>2020-04-09T14:50:11.296Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20313" target="_blank" rel="noopener">牛客网</a><br>题目描述</p><blockquote><p>作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *<br>N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200409214206553.png" alt="在这里插入图片描述"><br>  <a id="more"></a><br>现在，C君希望你告诉他队伍整齐时能看到的学生人数。<br>输入描述:</p><p>共一个数N。</p><p>输出描述:</p><p>共一个数，即C君应看到的学生人数。</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>题解：<br>无限接近裸的欧拉函数<br>可以自己画图看看<br><img src="https://img-blog.csdnimg.cn/20200409214430241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我来解释下我这个图，我把n=4和5画在了一起，紫色区域是4<em>4区域，红色区域（也是整个区域）是5</em>5，左上角围成一个三角形区域，我们暂时不考虑对角线上的情况（因为对角线只能看见一个，后面的都被挡住了）。<br>左下角坐标是（0,0），我们发现能看的坐标（x，y），x与y为互质，如果不是互质，就一定会被挡住，（比如（2,4）会被（1,2）挡住，而1与2互质，（1,2）就不会被挡住）<br>我们用ans记录三角区域的情况数<br>就是ans=每行的情况加一起<br>那每行有多少种，可以用欧拉函数求<br>欧拉函数的ϕ(x)表示小于x的且与x互质的数有多少个<br>ϕ(3)=2（与3互质的有1和2，一共有两个）<br>特别注意ϕ(1)=1<br>公式法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="comment">// 直接求3</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Euler</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> res = n;</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">long</span> <span class="keyword">long</span> i =<span class="number">2</span> ;i*i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>( n %i == <span class="number">0</span> )&#123;</span><br><span class="line">n/=i;</span><br><span class="line">res = res - res/i;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">while</span>( n % i==<span class="number">0</span>)</span><br><span class="line"> n/=i;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">if</span>( n &gt; <span class="number">1</span> )</span><br><span class="line">     res = res - res/n;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += Euler(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>筛法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(!phi[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    get_phi(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += phi[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>记录下欧拉函数的模板：<br>筛法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特性 :</span></span><br><span class="line"><span class="comment">1.若a为质数,phi[a]=a-1;</span></span><br><span class="line"><span class="comment">2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a</span></span><br><span class="line"><span class="comment">3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> m[n],phi[n],p[n],nump;</span><br><span class="line"><span class="comment">//m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m[i])<span class="comment">//i为素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[++nump]=i;<span class="comment">//将i加入素数数组p中</span></span><br><span class="line">            phi[i]=i<span class="number">-1</span>;<span class="comment">//因为i是素数,由特性得知    </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nump&amp;&amp;p[j]*i&lt;n;j++)  <span class="comment">//用当前已的到的素数数组p筛,筛去p[j]*i</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[p[j]*i]=<span class="number">1</span>;<span class="comment">//可以确定i*p[j]不是素数 </span></span><br><span class="line">            <span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="comment">//看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 </span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[p[j]*i]=phi[i]*p[j]; <span class="comment">//特性2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[p[j]*i]=phi[i]*(p[j]<span class="number">-1</span>); <span class="comment">//互质,特性3其,p[j]-1就是phi[p[j]]   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公式法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eular</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n/=i,ret*=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,ret*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ret*=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N + <span class="number">0.5</span>), ans = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(N % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(N &gt; <span class="number">1</span>) ans = ans / N * (N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20313&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *&lt;br&gt;N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409214206553.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="欧拉函数" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>子序列</title>
    <link href="http://jozky.top/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://jozky.top/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-04-09T14:47:11.000Z</published>
    <updated>2020-04-09T14:50:13.446Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18203" target="_blank" rel="noopener">牛客网题目</a><br>题目描述</p><blockquote><p>给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果</p></blockquote><p>输入描述:</p><blockquote><p>第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示</p><p>接下来一行N个整数，表示给出的序列</p><p>保证序列内的数互不相同</p></blockquote><a id="more"></a><p>输出描述:</p><blockquote><p>对于每组数据，输出一个整数表示答案，对10^9^ + 7 取模 每组数据之间以换行分割</p></blockquote><p> 示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span> </span><br><span class="line"><span class="number">100</span> <span class="number">1020</span> <span class="number">2050</span> <span class="number">102</span> <span class="number">12</span> <span class="number">235</span> <span class="number">4</span> <span class="number">57</span> <span class="number">32135</span> <span class="number">54354</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">81000</span></span><br><span class="line"><span class="number">521918013</span></span><br></pre></td></tr></table></figure><p>说明：<br>第一组数据解释<br>所有长度为3的子序列为 (5,3,1) (5,3,4) (3,1,4) (5,1,4)<br>最终答案为3∗4∗3∗4=1443<br><img src="https://img-blog.csdnimg.cn/20200409222358794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">题解：<br>对于子序列一个数a，a会以三种形式存在<br>1.最大值<br>2.最小值<br>3.中间值<br>我们现将序列从小到大排序（从0开始），并不影响结果，但是有利于计算<br> a在长度为 k 的子序列中出现的次数为 C^k−1^<del>n−1</del>(因为如果它出现在子序列中，那么总数还有 n−1 个 数字，序列的长度还有 k−1 个)<br>对于第一种情况，a作为最大值的下表为i，a之前的i个数都比a小，所选出的子序列一定有以下标i为结尾的，我们需要从前i个中选出k-1个，组成长度为k的子序列，个数为C^k-1^<del>i</del>(组合数）<br>同理：ai 是最小值的情况的方法数为 C^k−1^<del>n−i−1</del><br>pi=C^k−1^<del>n−1</del>−C^k−1^<del>i</del>−C^k−1^<del>n−i−1</del> 对于 ai这个数来说，它对答案的贡献为 a^pi^<del>i</del><br>最终的答案为 ：ans=∏^n−1^<del>i=0</del>a^pi^<del>i</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function">LL <span class="title">Pow</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL c[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % (MOD<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a, a+n);</span><br><span class="line">        LL tmp = c[n<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL b = tmp-c[i][k<span class="number">-1</span>]-c[n-i<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">            b = (b%(MOD<span class="number">-1</span>)+(MOD<span class="number">-1</span>))%(MOD<span class="number">-1</span>);</span><br><span class="line">            ans = ans*Pow(a[i], b)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为那个是指数，比如说 a^b^%p，可以用费马小定理 a^(b%(p-1))^ % p</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18203&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网题目&lt;/a&gt;&lt;br&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示&lt;/p&gt;
&lt;p&gt;接下来一行N个整数，表示给出的序列&lt;/p&gt;
&lt;p&gt;保证序列内的数互不相同&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="欧拉函数" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数" scheme="http://Jozky.top/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月8日题目精讲 黑白树</title>
    <link href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/"/>
    <id>http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/</id>
    <published>2020-04-09T10:54:52.000Z</published>
    <updated>2020-04-09T11:00:07.425Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13249" target="_blank" rel="noopener">试题链接</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。<br>你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行一个整数n (1 ≤ n ≤ 10^5^) 接下来n-1行，每行一个整数，依次为2号点到n号点父亲的编号。 最后一行n个整数为k[i]<br>(1 ≤ k[i] ≤ 10^5^)</p><p>样例解释:<br> 对节点3操作，导致节点2与节点3变黑 对节点4操作，导致节点4变黑 对节点1操作，导致节点1变黑</p></blockquote><p>输出描述:</p><p>一个数表示最少操作次数</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>题解：<br>一开始以为是红黑树的姐妹黑白树。。<br>求出最少的操作，用dfs</p><p>我们要不断更新染色的最远距离，还要把子节点的染色范围更新的父亲节点<br>比如1-&gt;2-&gt;3-.&gt;4-&gt;5-&gt;6-&gt;7<br>f[2]=5,f[3]=2<br>2节点就可以直接染色到6<br>操作完2之后，如果3就已经被染色了，如果3能染色的范围比fa[ 2 ]-1（因为2已经染色了本身，所以减一）还大，那染色范围可以更远<br>如果fa[3]&lt;fa[2]-1，就把f3的最远距离更新到fa[2]-1<br>总结就是fa[fa]=max（ fa [ fa ] , fa [ son ] - 1 ）<br>fa=0说明这个点无法被处理到<br>因为染色都是从下向上的。如果一个节点没办法被它子树的节点染色，那这个节点的父亲节点也没办法将它染色，他只能自己染色了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100004</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;w[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w[x].size();j++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(w[x][j]);</span><br><span class="line">fa[x]=max( fa[ w[x][j] ]<span class="number">-1</span> , fa[x] );</span><br><span class="line">a[x]=max( a[ w[x][j] ]<span class="number">-1</span> , a[x] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">fa[x]=a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">forr(n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">w[m].push_back(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;试题链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。&lt;br&gt;你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dfs" scheme="http://Jozky.top/tags/dfs/"/>
    
      <category term="贪心" scheme="http://Jozky.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月7号题目精讲 树</title>
    <link href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/"/>
    <id>http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/</id>
    <published>2020-04-07T10:59:14.000Z</published>
    <updated>2020-04-07T11:10:32.813Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13611" target="_blank" rel="noopener">树</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K<br>其他语言262144K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行两个整数n，k代表点数和颜色数； 接下来n-1行，每行两个整数x,y表示x与y之间存在一条边；</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数表示方案数（mod 1e9+7）。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">39</span><br></pre></td></tr></table></figure><p>备注:</p><p>对于30%的数据，n≤10, k≤3；<br>对于100%的数据，n,k≤300。<br><strong>题解：</strong><br><del>shy爹有棵树</del><br>这个题也可以这么想，把相同颜色当成一个整体，连通块，问构成连通块的方案<br>我们用dp来计数<br>dp[i][j]表示i个点用了j个颜色的方案<br>那么转移方程就是<br>dp[i][j]=dp[i-1][j]+dp[i-1][j-1]*(k-(j-1))<br>dp[i][j]=第i个点和第i-1个点颜色相同或者第i-1个点所用的颜色与之前不同，之前用了（j-1）个颜色，这个点可用的颜色种类就是k-（j-1）<br>（可以理解成前者在一个连通块，后者不在一个连通块内）<br>因为数据给的肯定是棵树，那树的形状并不会影响结果，所以。。。也可以不输入那（n-1）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long ll;</span><br><span class="line">const int maxn=303;</span><br><span class="line">ll mod =1e9+7;</span><br><span class="line">ll dp[maxn][maxn];</span><br><span class="line">int n,k;</span><br><span class="line">ll sum=0;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int j=1;j&lt;=k;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==1&amp;&amp;j==1)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*(k-(j-1)))%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">sum=(sum+dp[n][i])%mod;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,sum);</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有第二个办法：<br>一下为转载：<br>题目意思是用k个点把一个有n个节点的树染色,然后的地方必须联通,求有多少方案数?<br>下面给大家介绍两种做法..<br><img src="https://img-blog.csdnimg.cn/20200407185522399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">切边表示染色用的颜色个数,比如我要用3种颜色染色,那么我就只要考虑切2条边,比如切2-4,和3和7这是一种方案。若将树分割为 i个连通块，则需要删去 i−1条边，故方案数为 C^i-1^ n−1然后考虑染色,假如我现在切的是i条边,要从k种颜色中选出i中颜色染色，而且是有顺序的，故方案数为A(k,i+1).<br>综上，总的方案数为：<br><img src="https://img-blog.csdnimg.cn/20200407190618154.png" alt="在这里插入图片描述">可以线性求逆元，枚举 i 实现。</p><p>时间复杂度：O(n)<br>代码如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">using namespace std;</span><br><span class="line">const ll mod=1e9+7;</span><br><span class="line">const ll maxn=310;</span><br><span class="line">ll n,k,ans,inv[maxn],f[maxn];</span><br><span class="line">ll C(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[y]%mod*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">ll A(ll x,ll y)&#123;</span><br><span class="line">    <span class="built_in">return</span> f[x]*inv[x-y]%mod;</span><br><span class="line">&#125;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    inv[0]=f[0]=inv[1]=f[1]=1;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=((mod-mod/i)*inv[mod%i])%mod,f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(ll i=2;i&lt;maxn;i++)</span><br><span class="line">        inv[i]=(inv[i]*inv[i-1])%mod,f[i]=(f[i]*f[i-1])%mod;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=k&amp;&amp;i&lt;=n;i++)</span><br><span class="line">        ans=(ans+(C(n-1,i-1)*A(k,i)%mod))%mod;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.nowcoder.net/n/c76751c0215344ff99357aaee5235851" target="_blank" rel="noopener">转载地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13611&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K&lt;br&gt;其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;shy有一颗树，树有n个结点。有k种不同颜色的染料给树染色。一个染色方案是合法的，当且仅当对于所有相同颜色的点对(x,y)，x到y的路径上的所有点的颜色都要与x和y相同。请统计方案数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="DFS序" scheme="http://Jozky.top/tags/DFS%E5%BA%8F/"/>
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="连通块" scheme="http://Jozky.top/tags/%E8%BF%9E%E9%80%9A%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>DFS序讲解</title>
    <link href="http://jozky.top/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/"/>
    <id>http://jozky.top/2020/04/07/DFS%E5%BA%8F%E8%AE%B2%E8%A7%A3/</id>
    <published>2020-04-07T10:00:26.000Z</published>
    <updated>2020-04-12T10:21:24.366Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；<br>dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。</p><a id="more"></a><p>如图：<br><img src="https://img-blog.csdnimg.cn/20200407172327886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">dfs序就是：ABDDEEBCFHHFG<br>其实就是用dfs全部遍历一遍，不过我们不能光遍历还有动些小手脚，我们要在遍历的同时记录每个节点进栈与出栈的时间序列。</p><p>介绍两个基本函数：in[x],out[x]<br>dfs从根节点开始，这俩函数就分别记录每个节点x进入与离开的时间戳<br>还有num[x]，表示第x个节点的编号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">inline int dfs(int x,int fa,int time)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">in</span>[x]=++time;</span><br><span class="line">num[time]=x;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=e[x].size();i++)</span><br><span class="line">&#123;</span><br><span class="line">int w=e[x][i];</span><br><span class="line"><span class="keyword">if</span>(w==fa)<span class="built_in">continue</span>;//防止又从子节点找回去</span><br><span class="line">dfs(w,x,time); </span><br><span class="line">&#125;</span><br><span class="line">out[x]=time;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">dfs(s,0,0);</span><br></pre></td></tr></table></figure><p>（具体情况根据，根据题目来写）<br><img src="https://img-blog.csdnimg.cn/20200407174719197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">num生成的就是一个新秩序，由每个节点进入关系而形成的<br>你仔细观察会发现：<br>序根节点的进栈时间&lt;子树的dfs&lt;根节点的出栈时间<br>这样不就成一个区间了<br>in[x]~out[x]是x为根节点的子树，划分为一个区间<br>然后什么单点修改，区间查询，莫队都可以用在树上，而且dfs序也是树链剖分的前驱知识</p><p>光说可能不怎么懂，我去找一些题，做完再更新例题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常会遇到树的问题，但树是非线性的结构，操作起来始终还是麻烦，如果我们能把树改造成线性结构，有什么方法？对，就是今天要讲的DSF序；&lt;br&gt;dfs序呢，就是把一棵树区间化，我们用dfs的方式将它区间化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="DFS序" scheme="http://Jozky.top/tags/DFS%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月27日 数学考试</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/</id>
    <published>2020-04-06T14:53:34.000Z</published>
    <updated>2020-04-06T15:01:52.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 题号 NC15553<br> 名称 数学考试<br> 来源 2018年长沙理工大学第十三届程序设计竞赛<br>链接：<a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/problem/15553</a><br>来源：牛客网<br><a href="https://ac.nowcoder.com/acm/problem/15553" target="_blank" rel="noopener">试题传送门</a><br>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述<br>今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，<br>他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,<br>即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &gt;= L+k）。</p><a id="more"></a><p>输入描述:</p><blockquote><p>第一行一个整数T（T&lt;=10）,代表有T组数据 接下来一行两个整数n,k,(1&lt;=n&lt;=200,000),(1&lt;=k,2k &lt;= n)<br>接下来一行n个整数a1,a2,…,an，（-100,000&lt;=ai&lt;=100,000）</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数，qwb能获得的最大分数</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">6 3</span><br><span class="line">1 1 1 1 1 1</span><br><span class="line">8 2</span><br><span class="line">-1 0 2 -1 -1 2 3 -1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><strong><em>题解：</em></strong><br>题意就是求不想交的前缀与后缀和的最大值<br>第一反应是线段树（<del>毕竟是有关区间查询</del> ） ，不过仔细想想也不能这么麻烦（<del>打线段树不累吗？</del> ） ，不过也有大佬用线段树做的。<br>根据题意知道前缀与后缀长度一样，依据朴素的原则单纯打暴力肯定不行，需要优化优化，怎么优化呢？</p><p>我们先求出所有前缀和q[]<br>然后按照给定前后缀的长度k，求出每个k长区间的和<br>比如 -1 0 2 -1 -1 2 3 -1   k=2；<br>每个k长区间的和为：w[]-1 2 1 -2 1 5 2<br>我们所要求的最大值max=dp1+dp2<br>dp1是前缀和最大值<br>dp2是后缀和最大值<br>那其实就是在w中取一个dp1再取一个dp2，使他们和最大<br>但注意前缀与后缀不能相交和相连<br>方法一：<br>稍微处理下,可以先选后缀，然后前缀的范围就是去除已选的后缀，在里面取最大的前缀<br>maxx=(q[i]-q[i-k])+max(q[1],q[2],q[3]…..q[i-k-1])<br>(q[i]-q[i-k])后缀和<br>max(q[1],q[2],q[3]…..q[i-k-1])最大的前缀<br>然后求出maxx的最大值情况<br>诶，这不就是线性dp吗！wok做完才注意到<br>方法二：<br>求出前缀和所能取到的最大值（从头开始），放入数组w1<br>求出后缀和所能取到的最大值（从尾开始），放入w2中<br>然后再一个循环，求出w1[i]与w2[i+1]（即当前位i的前缀和与排在i之后的最大后缀和之和）的最大值<br>代码一</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;cnt;</span><br><span class="line">  q[i]=q[i-1]+cnt; </span><br><span class="line">&#125;</span><br><span class="line">memset(w1,-128,sizeof(w1));</span><br><span class="line">memset(w2,-128,sizeof(w2));</span><br><span class="line">cnt=-1e10;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  w[i]=q[i]-q[i-k];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"><span class="keyword">if</span>(i&gt;=k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w[i]+w1[i-k]&gt;cnt)cnt=w[i]+w1[i-k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;iostream&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstdio&gt;</span></span><br><span class="line"><span class="comment">#include &lt;cstring&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string&gt;</span></span><br><span class="line"><span class="comment">#include &lt;algorithm&gt;</span></span><br><span class="line">typedef long long ll;</span><br><span class="line">using namespace std;</span><br><span class="line">const int inf=2e5+4;</span><br><span class="line">ll a[inf];</span><br><span class="line">ll q[inf];</span><br><span class="line">ll w[inf];</span><br><span class="line">ll w1[inf],w2[inf];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int t;</span><br><span class="line">  cin&gt;&gt;t;</span><br><span class="line">  int n,k;</span><br><span class="line">  ll cnt;</span><br><span class="line">  <span class="keyword">while</span>(t--)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line">  <span class="keyword">for</span>(int i=1;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  cin&gt;&gt;cnt;</span><br><span class="line">  q[i]=q[i-1]+cnt; </span><br><span class="line">&#125;</span><br><span class="line">memset(w1,-128,sizeof(w1));</span><br><span class="line">memset(w2,-128,sizeof(w2));</span><br><span class="line">cnt=-1e10;</span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">  w[i]=q[i]-q[i-k];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">w1[i]=w[i]&gt;w1[i-1]?w[i]:w1[i-1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=n-k+1;i&gt;=k+1;i--)</span><br><span class="line">w2[i]=w2[i+1]&gt;w[i+k-1]?w2[i+1]:w[i+k-1];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=k;i&lt;=n-k+1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(w2[i+1]+w1[i]&gt;cnt)cnt=w2[i+1]+w1[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对了还有变形的问题：<br><del>（等晚上有空再想吧）</del> </p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 题号 NC15553&lt;br&gt; 名称 数学考试&lt;br&gt; 来源 2018年长沙理工大学第十三届程序设计竞赛&lt;br&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15553&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://ac.nowcoder.com/acm/problem/15553&lt;/a&gt;&lt;br&gt;来源：牛客网&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/15553&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;试题传送门&lt;/a&gt;&lt;br&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;br&gt;今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，&lt;br&gt;他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,&lt;br&gt;即[L,L+1,L+2,….,L+k-1]，[R,R+1,R+2,…,R+k-1]（R &amp;gt;= L+k）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="前缀后缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C/"/>
    
      <category term="线性dp" scheme="http://Jozky.top/tags/%E7%BA%BF%E6%80%A7dp/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月26日 合并回文子串</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</id>
    <published>2020-04-06T14:53:16.000Z</published>
    <updated>2020-04-06T14:59:35.451Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题号：NC13230<br>名称：合并回文子串<br>来源：美团2017年CodeM大赛-初赛A轮</strong><br><a href="https://ac.nowcoder.com/acm/problem/13230" target="_blank" rel="noopener">题目链接</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><p><strong>题目描述</strong></p><blockquote><p>输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。<br>我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。<br>需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:</p></blockquote><a id="more"></a><blockquote><p>第一行一个整数T(T ≤ 50)。 接下来2T行，每两行两个字符串分别代表A,B(|A|,|B| ≤ 50)，A,B的字符集为全体小写字母。</p></blockquote><p>输出描述:</p><p>对于每组数据输出一行一个整数表示价值最大的C的价值。<br>示例1</p><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">a</span><br><span class="line">aaaabcaa</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>思路：区间dp问题</strong><br>dp[i][j][m][n]表示A中下标i到j-1以及B中下标m到n-1的串，能否组成回文串<br>(dp值为零则表示不构成回文串，不为零则表示构成)<br>首先：字符本身是回文串<br>其次，分为四种情况<br>a[i]==a[j-1]        dp[i][j][m][n]+=c[i+1][j-1][m][n];<br>因为dp我们只考虑是否为0或非0，所以dp之间可以+=也可以|=,都不影响<br>（当A的第i为和第j-1位相同时，那么dp[i][j]是否为回文串就取决于比它小一层的dp[i+1][j-1]，这样一次往里推，就可以推到以一种情况）<br>b[m]==b[n-1]    dp[i][j][m][n]+=c[i][j][m+1][n-1];<br>(和上一个思路相同)</p><p>a[i]==b[n-1]        dp[i][j][m][n]+=c[i+1][j][m][n-1];<br>（当A的i与B的n-1相同时，那么dp[i][][][n]是否为回文串就取决于A的后一位i+1和B的前一位n-1的情况）<br>a[m]==b[j-1]    dp[i][j][m][n]+=c[i][j-1][m+1][n];<br><strong>代码</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#define maxn 100</span></span><br><span class="line">using namespace std;</span><br><span class="line">int t;</span><br><span class="line">char a[maxn],b[maxn];</span><br><span class="line">int c[maxn][maxn][maxn][maxn];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">char ch=getchar();</span><br><span class="line">int j;</span><br><span class="line">int n;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">int ans=0;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">ch=getchar();</span><br><span class="line">cin&gt;&gt;b;</span><br><span class="line">ch=getchar();</span><br><span class="line">int len1=strlen(a),len2=strlen(b);</span><br><span class="line"><span class="keyword">for</span>(int tj=0;tj&lt;=len1;tj++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int tn=0;tn&lt;=len2;tn++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int i=0;i+tj&lt;=len1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(int m=0;m+tn&lt;=len2;m++)</span><br><span class="line">&#123;</span><br><span class="line">j=i+tj;</span><br><span class="line">n=m+tn;</span><br><span class="line"><span class="keyword">if</span>(tj+tn&lt;=1)c[i][j][m][n]=1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">c[i][j][m][n]=0;</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=2&amp;&amp;a[i]==a[j-1])c[i][j][m][n]|=c[i+1][j-1][m][n];                                               </span><br><span class="line"><span class="keyword">if</span>(tn&gt;=2&amp;&amp;b[m]==b[n-1])c[i][j][m][n]|=c[i][j][m+1][n-1];</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[i]==b[n-1])c[i][j][m][n]|=c[i+1][j][m][n-1];</span><br><span class="line"><span class="keyword">if</span>(tj&gt;=1&amp;&amp;tn&gt;=1&amp;&amp;a[m]==b[j-1])c[i][j][m][n]|=c[i][j-1][m+1][n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(c[i][j][m][n])ans=max(ans,tj+tn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> &#125; </span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另外</strong><br>tj和tn从0开始，不断讨论A中i到i+tj和B中m到tn的回文字符串</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题号：NC13230&lt;br&gt;名称：合并回文子串&lt;br&gt;来源：美团2017年CodeM大赛-初赛A轮&lt;/strong&gt;&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13230&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个字符串A和B，合并成一个串C，属于A和B的字符在C中顺序保持不变。如”abc”和”xyz”可以被组合成”axbycz”或”abxcyz”等。&lt;br&gt;我们定义字符串的价值为其最长回文子串的长度（回文串表示从正反两边看完全一致的字符串，如”aba”和”xyyx”）。&lt;br&gt;需要求出所有可能的C中价值最大的字符串，输出这个最大价值即可 输入描述:&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="区间dp" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4dp/"/>
    
      <category term="字符串" scheme="http://Jozky.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】3月25日 tokitsukaze and Soldier</title>
    <link href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/"/>
    <id>http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/</id>
    <published>2020-04-06T14:51:59.000Z</published>
    <updated>2020-04-06T14:57:17.978Z</updated>
    
    <content type="html"><![CDATA[<p>@<a href="牛客网【每日一题】3月25">TOC</a></p><p> 题号：NC50439<br>名称： tokitsukaze and Soldier<br>来源：练习赛50-C<br>链接: <a href="https://ac.nowcoder.com/acm/problem/50439" target="_blank" rel="noopener">牛客网</a>.</p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。<br>第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。<br>但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)<br>tokitsukaze想知道，团的战力最大为多少。</p></blockquote><a id="more"></a><p>输入描述:</p><p>第一行包含一个正整数n(1≤n≤10^5)。<br>接下来n行，每行包括2个正整数v,s(1≤v≤10^9,1≤s≤n)。</p><p>输出描述:</p><p>输出一个正整数，表示团的最大战力。</p><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>示例2<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">100 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><p><strong><em>思路</em></strong><br>所求的最大战斗力由v和s这两个因素限制。<br>结构体数组a存放v和s，然后对其排序，先按照s从大到小，如果s相同再排v，也是从大到小（先要保证足够的人数，后面好进行取舍）。<br>定义一个从小到大的优先队列q，ans相互跟随q，（q每次添加一个战力值，同时用ans加上战力值；ans删去，q也弹出），战力值的先后加入由s的排序决定，当q的元素数量大于当前s的值时（s是由大到小的排序的），就将多出的部分pop出（q是从小到大排序，所以弹出的总是其中最小值），再用ans减去，这样ans的值即为在人数限定在s内的最佳情况（因为弹出的是最小值，相对于前s个数的和，所以之后也不用再考虑被弹出的数），记录ans的最大值<br><del>我刚开始提交是70多分，想了一阵子才发现是数组开小了（笑哭）</del> </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100004</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> v,s;</span><br><span class="line">&#125;;</span><br><span class="line">node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.s!=b.s)<span class="keyword">return</span> a.s&gt;b.s;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> a.v&gt;a.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i].v&gt;&gt;a[i].s;</span><br><span class="line">&#125;</span><br><span class="line">sort (a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="comment">//int tot=0;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minn=maxn;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">q.push(a[i].v);</span><br><span class="line">ans+=a[i].v;</span><br><span class="line"><span class="keyword">while</span>(q.size()&gt;a[i].s)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans-=q.top();</span><br><span class="line"><span class="comment">//printf("q.size=%d,a[i].s=%d,ans=%d\n",q.size(),a[i].s,ans);</span></span><br><span class="line">q.pop();</span><br><span class="line"><span class="comment">//tot--;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;maxx)maxx=ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;maxx;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@&lt;a href=&quot;牛客网【每日一题】3月25&quot;&gt;TOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 题号：NC50439&lt;br&gt;名称： tokitsukaze and Soldier&lt;br&gt;来源：练习赛50-C&lt;br&gt;链接: &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50439&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 524288K，其他语言1048576K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个游戏中，tokitsukaze需要在n个士兵中选出一些士兵组成一个团去打副本。&lt;br&gt;第i个士兵的战力为v[i]，团的战力是团内所有士兵的战力之和。&lt;br&gt;但是这些士兵有特殊的要求：如果选了第i个士兵，这个士兵希望团的人数不超过s[i]。(如果不选第i个士兵，就没有这个限制。)&lt;br&gt;tokitsukaze想知道，团的战力最大为多少。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="优先队列" scheme="http://Jozky.top/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】4月6日数码</title>
    <link href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/"/>
    <id>http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/</id>
    <published>2020-04-06T12:59:12.000Z</published>
    <updated>2020-04-06T15:01:56.489Z</updated>
    
    <content type="html"><![CDATA[<p>题目：<a href="https://ac.nowcoder.com/acm/problem/13221" target="_blank" rel="noopener">数码</a><br>来源：<a href="https://ac.nowcoder.com/acm/contest/5#description" target="_blank" rel="noopener">美团2017年CodeM大赛-资格赛</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x<br>的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 </p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>一行，两个整数 l 和 r (1 ≤ l ≤ r ≤ 10^9^)。</p></blockquote><p>输出描述:</p><p>输出9行。</p><blockquote><p>第 i 行，输出数码 i 出现的次数。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>题解：<br>先介绍一个函数：<br>solve（a，b）就是从1<del>a中数码b的倍数出现的次数<br>solve(a,b)=a/b<br>那么求[l,r]的话，就用solve(r,b)-solve(l-1,b)，大致可以理解成前缀和那种<br>num就是0</del>9，计算每个num对应的区间<br>最高位是1的话：1,10 ~ 19,100 ~ 199， 1000 ~ 1999….<br>最高位是2的话：2,20 ~ 29,200 ~ 299， 2000 ~ 2999….</p><p>因为我们只记录约数的最高位，像1999，约数就是1和1999，我们只记录最高位，那么就是有两个1<br>那么我们枚举以num开头的数，计算它的倍数在[l,r]中出现的次数。<br>按照几位数和最高位是几进行枚举，有多少这样的数直接统计就ok<br>solve(r,num)-solve(l-1,num)<br>枚举num的值<br>让最高位等于x时num枚举相对应的区间（从x<em>10^y-1^~(x+1)</em>10^y-1^-1）y=1.2.3….<br>有部分数会被算重复，因为有完全平方数存在，<br>再运用整除分块技巧，让复杂度降到O(根号n)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define ll long long</span></span><br><span class="line">ll minn(ll a,ll b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a&gt;=b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">return</span> b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">//cout&lt;&lt;a;</span><br><span class="line"> <span class="built_in">return</span> a;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ll solve(ll a, ll b) &#123;</span><br><span class="line">  ll res = 0;</span><br><span class="line">   ll beg;</span><br><span class="line">   ll end;</span><br><span class="line">  <span class="keyword">for</span> (ll i = 1; i &lt;= a / b; i *= 10) &#123;</span><br><span class="line">    beg = b * i;//区间开头</span><br><span class="line">    </span><br><span class="line"> end = minn(a, beg + i - 1);//区间结尾</span><br><span class="line"> int k;</span><br><span class="line">    <span class="keyword">for</span> (int j = beg; j &lt;= end; j = k + 1) &#123;</span><br><span class="line">      k = min(a / (a / j), end);</span><br><span class="line">      //cout&lt;&lt;a/(a/i)&lt;&lt;<span class="string">" "</span>&lt;&lt;end&lt;&lt;endl;</span><br><span class="line">      res += (k - j + 1) * (a / j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">ll l,r;</span><br><span class="line">int <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">   cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(ll i=1;i&lt;=9;i++)&#123;</span><br><span class="line">        cout&lt;&lt;solve(r,i)-solve(l-1,i)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13221&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;数码&lt;/a&gt;&lt;br&gt;来源：&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5#description&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;美团2017年CodeM大赛-资格赛&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定两个整数 l 和 r ，对于所有满足1 ≤ l ≤ x ≤ r ≤ 10^9 的 x ，把 x&lt;br&gt;的所有约数全部写下来。对于每个写下来的数，只保留最高位的那个数码。求1～9每个数码出现的次数。 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="整除分块" scheme="http://Jozky.top/tags/%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>【每日一题】4月1日题目 Rinne Loves Edges </title>
    <link href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/"/>
    <id>http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/</id>
    <published>2020-04-05T16:17:13.000Z</published>
    <updated>2020-04-05T16:20:28.242Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/22598" target="_blank" rel="noopener">牛客网</a></p><ol><li>题目：</li></ol><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><blockquote><p>题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m<br>条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为<br>1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1<br>了！作为回报，她会让你的排名上升一定的数量。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行三个整数 N,M,S，意义如「题目描述」所述。</p><p>接下来 M 行，每行三个整数 u,v,w 代表点 u 到点 v 之间有一条长度为 w 的无向边。</p></blockquote><p>输出描述:</p><p>一个整数表示答案。</p><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 1 </span><br><span class="line">1 3 1 </span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><p>说明</p><p>需要使得点 2,3,4 不能到达点 1，显然只能删除所有的边，答案为 3</p><p>示例2<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3 1 </span><br><span class="line">1 2 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 4 2</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>说明</p><blockquote><p>需要使得点 4 不能到达点 1，显然删除边 2↔3是最优的。</p></blockquote><p>备注:</p><blockquote><p>2≤S≤N≤10^5^,M=N−1保证答案在 C++ long long 范围内</p></blockquote><ol start="2"><li>题解：</li></ol><p>仔细观察题中给的数据m=n-1，其实就是给你一个树，而被删除度为1的点就是这个树的叶子节点，给你的s就是这个树的根<br>那一切就很清楚了：给你一个树和根节点，让你通过删边使得根节点与叶子节点不相连，问你怎么删值最小<br>这个是树形dp问题，我们要做的就是在搜索树的过程中不断处理数据<br>凡是dp问题，都有状态转移，就是一个大问题可以小问题<br>s为根节点时，要删去一些边让s与每个叶子节点不连通，其实就是让x为根节点的子树删去一些边，使得s和x的子树上每个叶子节点不连通。<br>两种情况：一个就是删去x与他儿子y的边<br>另一个就是看以y为子树的根节点的最小情况。<br>我们取较小值<br>    f[x]+=min(f[y],edge[i].w);<br>    edge[i].w是指当前节点x与其子节点y的距离<br>    具体看代码吧</p><ol start="3"><li>代码：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn=1e5+3;</span><br><span class="line">int f[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">int u,v,w,next;</span><br><span class="line">&#125;edge[maxn*2];</span><br><span class="line">int root[maxn];</span><br><span class="line">int head[maxn];</span><br><span class="line">int cnt=0;</span><br><span class="line">int n,m,s;</span><br><span class="line">void addt(int u,int v,int w)</span><br><span class="line">&#123;</span><br><span class="line">edge[++cnt].v=v;</span><br><span class="line">edge[cnt].w=w;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int x,int fa)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x!=s&amp;&amp;root[x]==1)f[x]=-1;//如果这个是叶子节点，就断绝与父亲的关系 </span><br><span class="line">//根节点s也有可能度为1，所以要除s之外</span><br><span class="line">int now;//当前点x的子节点</span><br><span class="line">//关系(fa--&gt;x--&gt;now)</span><br><span class="line"><span class="keyword">for</span>(int i=head[x];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">now=edge[i].v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(now==fa)<span class="built_in">continue</span>;//因为是无向图，我们要防止返回到父亲节点</span><br><span class="line"></span><br><span class="line">dfs(now,x);//继续向下</span><br><span class="line"><span class="keyword">if</span>(f[now]==-1)f[x]+=edge[i].w;//这个我们已经给断绝关系了，只加当前边的权值</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">f[x]+=min(f[now],edge[i].w);//考虑两个方面</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">int u,v,w;</span><br><span class="line"><span class="keyword">for</span>(int i=1;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">addt(u,v,w);</span><br><span class="line">addt(v,u,w);//链式前向星</span><br><span class="line">root[u]++;</span><br><span class="line">root[v]++;</span><br><span class="line"> &#125; </span><br><span class="line"> dfs(s,0);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d"</span>,f[s]);</span><br><span class="line"> <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/22598&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;题目：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述 Rinne  最近了解了如何快速维护可支持插入边删除边的图，并且高效的回答一下奇妙的询问。 她现在拿到了一个 n 个节点 m&lt;br&gt;条边的无向连通图，每条边有一个边权 wi 现在她想玩一个游戏：选取一个 “重要点” S，然后选择性删除一些边，使得原图中所有除 S 之外度为&lt;br&gt;1 的点都不能到达 S。 定义删除一条边的代价为这条边的边权，现在 Rinne 想知道完成这个游戏的最小的代价，这样她就能轻松到达 rk1&lt;br&gt;了！作为回报，她会让你的排名上升一定的数量。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>牛客每日一题3.31 城市网络</title>
    <link href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/"/>
    <id>http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/</id>
    <published>2020-04-05T11:42:46.000Z</published>
    <updated>2020-04-05T11:56:01.376Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13331" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:<br>%lld</p></blockquote><blockquote><p>题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。<br>你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。</p></blockquote><a id="more"></a><blockquote><p>在每次行程开始时，你手上有价值为 c 的珠宝（每次行程可能不同），并且每经过一个城市时（包括 u 和 v<br>），假如那个城市中售卖的珠宝比你现在手上的每一种珠宝都要优秀（价值更高，即严格大于），那么你就会选择购入。<br>现在你想要对每一次行程，求出会进行多少次购买事件。</p></blockquote><p>输入描述:</p><blockquote><p>第一行，两个正整数 n , q (2 ≤ n ≤ 10^5^ , 1 ≤ q ≤ 10^5^)。 第二行，n 个正整数 a_i (1 ≤<br>a_i ≤ 10^5) 描述每个城市售卖的珠宝的价值。 接下来 n-1 行，每行描述一条道路 x , y (1 ≤ x,y ≤<br>n)，表示有一条连接 x 和 y 的道路。 接下来 q 行，每行描述一次行程 u , v , c (1 ≤ u,v ≤ n , 1 ≤ c<br>≤ 10^5^)。</p></blockquote><p>输出描述:</p><blockquote><p>对于每次行程输出一行，为所购买次数。</p></blockquote><p>示例1<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3 5 1 2 4</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">3 5</span><br><span class="line">4 2 1</span><br><span class="line">4 2 2</span><br><span class="line">4 2 3</span><br><span class="line">5 1 5</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>题解:<br>毋庸置疑就是用倍增来做<br>那什么是倍增呢？<br>（先挖个坑，有空做个倍增的讲解）<br>递推式fa[i][j] = fa[fa[i][j-1]][j - 1],只要倍增得到fa[i][0]就行，因为有了这个后面都可以推出<br>fa[i][j] 代表i节点往上走2^j的距离，且比当前大的点<br>每次查询时，在所有需要问的点加一条新点，连在u的下方，新点的权值就是询问的初始权值，从这个新点往上倍增就可以了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;vector&gt;</span></span><br><span class="line">const int maxn=2e5+2;</span><br><span class="line">using namespace std;</span><br><span class="line">int a[maxn];</span><br><span class="line">int dis[maxn];</span><br><span class="line">int fa[maxn][23];</span><br><span class="line">int n,q;</span><br><span class="line">int to[maxn];</span><br><span class="line">vector&lt;int&gt; W[2*maxn];</span><br><span class="line">void dfs(int u,int f)</span><br><span class="line">&#123;</span><br><span class="line">int pos=f;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(int i=21;i&gt;=0;i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[pos][i]&amp;&amp;a[fa[pos][i]]&lt;=a[u])</span><br><span class="line">pos=fa[pos][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[pos]&gt;a[u])fa[u][0]=f;</span><br><span class="line"><span class="keyword">else</span> fa[u][0]=fa[pos][0];</span><br><span class="line"><span class="keyword">for</span>(int i=1;fa[fa[u][i-1]][i-1];i++)</span><br><span class="line">&#123;</span><br><span class="line">fa[u][i]=fa[fa[u][i-1]][i-1];</span><br><span class="line">&#125;</span><br><span class="line">dis[u]=dis[f]+1;</span><br><span class="line"><span class="keyword">for</span>(int v=0;v&lt;W[u].size();v++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(W[u][v]==f)<span class="built_in">continue</span>;</span><br><span class="line">dfs(W[u][v],u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt;= n; ++i) </span><br><span class="line">&#123;</span><br><span class="line">scanf(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">        int a;</span><br><span class="line">  int b;</span><br><span class="line">        scanf(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        W[a].push_back(b);</span><br><span class="line">        W[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(int i =1; i &lt;= q ; ++i)&#123;//增加新点</span><br><span class="line">        int aa,b,c;</span><br><span class="line">        scanf(<span class="string">"%d%d%d"</span>,&amp;aa,&amp;b,&amp;c);</span><br><span class="line">        W[n+i].push_back(aa);</span><br><span class="line">        W[aa].push_back(i+n);</span><br><span class="line">        a[n+i] = c;</span><br><span class="line">        to[n+i] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(1,0);</span><br><span class="line">   int sum = 0; </span><br><span class="line">   int pos;</span><br><span class="line">    <span class="keyword">for</span>(int i = n+1; i &lt;= n+q; ++i)&#123;</span><br><span class="line">       pos=i;</span><br><span class="line">      sum=0;</span><br><span class="line">        <span class="keyword">for</span>(int j = 21; j &gt;= 0; --j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[fa[pos][j]] &gt;= dis[to[i]]) &#123;</span><br><span class="line">                sum += (1 &lt;&lt; j);</span><br><span class="line">pos= fa[pos][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13331&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;题目描述 有一个树状的城市网络（即 n 个城市由 n-1 条道路连接的连通图），首都为 1 号城市，每个城市售卖价值为 a_i 的珠宝。&lt;br&gt;你是一个珠宝商，现在安排有 q 次行程，每次行程为从 u 号城市前往 v 号城市（走最短路径），保证 v 在 u 前往首都的最短路径上。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="倍增" scheme="http://Jozky.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>清明追思家国永念</title>
    <link href="http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/"/>
    <id>http://jozky.top/2020/04/04/%E6%B8%85%E6%98%8E%E8%BF%BD%E6%80%9D%E5%AE%B6%E5%9B%BD%E6%B0%B8%E5%BF%B5/</id>
    <published>2020-04-04T14:59:20.000Z</published>
    <updated>2020-04-13T16:08:13.148Z</updated>
    
    <content type="html"><![CDATA[<p>我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行<img src="https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>本来想睡觉，企鹅群不小心看见一些发言气醒了。</p><p>4月4日默哀是形式主义?</p><p>你知道什么是形式主义吗?这种公共活动都是形式主义?死去的同胞、牺牲的医护都配不上，那谁还配得上这样的国礼?这算哪门子形式?</p><p>你可以说，我觉得宣传口的工作不够到位;你也可以说，我觉得现在才发布通知过于仓促;你还可以说，禁止的范围有待商榷。</p><p>无动于衷不是罪过，没有感同身受不是罪过，做不到泪流满面不是罪过，私下继续娱乐活动也不是罪过。你可以不爱听歌功颂德的文本，可以用自己的方式怀缅，可以用其他途径玩得.昏天黑地。</p><p>娱乐至死的时代，只有无聊才让人如临大敌，都懂。</p><p>做了不代表尊重，没做也不代表不尊重。</p><p>没有卫兵站在你家里用枪抵着你的后脑勺让你哭天抢地，没有条子叔叔把看电视打游戏听音乐的人逮起来，也没有人让你排着长队对着什么东西跪地哀嚎。事实上，没有人强迫你。只是有一点，自身的态度和对外界的要求要-致。若是不以流程怀念，就不要对着默哀的人喊你们是一群被形式主义迫害的粉红，缄默到底。若是以流程怀缅，也不必逼迫他人做超出公报内容的事，真挚只能自发。</p><p>你可以不立正，可以不起床。但是在鸣笛的那几分钟里，你必须清楚，你还活着，没有失去年长的亲人、远方的朋友是因为谁。你也得清楚，这样的祭奠，那些人配得上。<br>———转载<br><img src="https://img-blog.csdnimg.cn/20200404230406288.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200404230410721.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我站在窗边，竟然听着鸣笛声眼泪掉了下来，2020年好像我们什么都还没做就已经过了1/4，哪有什么岁月静好，只因有人为你负重前行&lt;img src=&quot;https://img-blog.csdnimg.cn/20200404230205816.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="文章" scheme="http://Jozky.top/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
