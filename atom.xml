<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-04-16T16:27:40.443Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>完全平方数</title>
    <link href="http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</id>
    <published>2020-04-16T16:23:01.000Z</published>
    <updated>2020-04-16T16:27:40.443Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/C" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>多次查询[l,r]范围内的完全平方数个数</p><p>定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x</p></blockquote><a id="more"></a> <p>输入描述:</p><blockquote><p>第一行一个数n表示查询次数 之后n行每行两个数l,r 输出描述: 对于每个查询，输出一个数表示答案</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1000000000</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>31622<br>备注:<br>n &lt;= 100000<br>0&lt;= l &lt;= r &lt;= 1000000000</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>签到题<br>l,r直接开方，注意l开方后向上取整。<br>r1-l1+1就是答案</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000005</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">int</span> l1=<span class="built_in">sqrt</span>(l);</span><br><span class="line"><span class="keyword">int</span> r1=<span class="built_in">sqrt</span>(r);</span><br><span class="line"><span class="keyword">if</span>(l1*l1!=l)l1++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r1-l1+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;多次查询[l,r]范围内的完全平方数个数&lt;/p&gt;
&lt;p&gt;定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="区间处理" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Music Problem</title>
    <link href="http://jozky.top/2020/04/17/Music-Problem/"/>
    <id>http://jozky.top/2020/04/17/Music-Problem/</id>
    <published>2020-04-16T16:22:49.000Z</published>
    <updated>2020-04-16T16:27:44.625Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/B" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>Listening to the music is relax, but for obsessive(强迫症), it may be<br>unbearable. HH is an obsessive, he only start to listen to music at<br>12:00:00, and he will never stop unless the song he is listening ends</p><a id="more"></a> <p>at integral points (both minute and second are 0 ), that is, he can<br>stop listen at 13:00:00 or 14:00:00,but he can’t stop at 13:01:03 or<br>13:01:00, since 13:01:03 and 13:01：00 are not an integer hour time.<br>Now give you the length of some songs, tell HH whether it’s possible<br>to choose some songs so he can stop listen at an integral point, or<br>tell him it’s impossible. Every song can be chosen at most once.</p></blockquote><p>输入描述:</p><blockquote><p> The first line contains an positive integer T(1≤T≤60), represents<br>there are T test cases.   For each test case:   The first line<br>contains an integer n(1≤n≤105), indicating there are n songs.   The<br>second line contains n integers a1,a2…an (1≤ai≤109 ), the ith integer<br>ai indicates the ith song lasts ai seconds.</p></blockquote><p>输出描述:</p><blockquote><p>For each test case, output one line “YES” (without quotes) if HH is<br>possible to stop listen at an integral point, and “NO” (without<br>quotes) otherwise.</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">1000</span> <span class="number">3000</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">3000</span> <span class="number">1600</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5400</span> <span class="number">1800</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>说明<br>In the first example it’s impossible to stop at an integral point.<br>In the second example if we choose the first and the third songs, they cost 3600 seconds in total, so HH can stop at 13:00:00<br>In the third example if we choose the first and the second songs, they cost 7200 seconds in total, so HH can stop at 14:00:00</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你n个数，这些数自由组合能不能凑出3600的倍数</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始想到的是前缀和，后来感觉dp最直接<br>dp[x]=1表示能组成x这个数<br>dp = 0表示组不了<br>cnt是中间数组，暂时存储本轮的数值<br>因为求能不能组成3600，可以用mod，3600的倍数mod后都是0，直接求dp[0]是否等于1<br>每读取一个a，就把a与之前所求的值进行相加存在cnt里，然后再给dp[]，cnt就是工具人</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">3600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    mem(dp);</span><br><span class="line">    mem(cnt);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    a%=<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">if</span>(!dp[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j]&gt;<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    cnt[(a+j)%<span class="number">3600</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[j])dp[j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[j]==<span class="number">1</span>)cnt[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mem(cnt);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!dp[<span class="number">0</span>])<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个很玄学的地方我把读入n放在两个mem之前，数据就过了一半，放后面就ac了，不知道为什么<br><img src="https://img-blog.csdnimg.cn/20200416235545673.png" alt="在这里插入图片描述">看来卡时间卡的太紧了（笑哭）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Listening to the music is relax, but for obsessive(强迫症), it may be&lt;br&gt;unbearable. HH is an obsessive, he only start to listen to music at&lt;br&gt;12:00:00, and he will never stop unless the song he is listening ends&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>相反数</title>
    <link href="http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/"/>
    <id>http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/</id>
    <published>2020-04-16T16:22:10.000Z</published>
    <updated>2020-04-16T16:27:42.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="https://ac.nowcoder.com/acm/contest/5203/A" target="_blank" rel="noopener">传送</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一个数加上他的相反数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况</p><a id="more"></a> <h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>&amp;&amp;f==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">  f=<span class="number">1</span>;</span><br><span class="line">sum2=sum2*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum+sum2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-相反数&quot;&gt;&lt;a href=&quot;#A-相反数&quot; class=&quot;headerlink&quot; title=&quot;A 相反数&quot;&gt;&lt;/a&gt;A 相反数&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h3&gt;&lt;p&gt;一个数加上他的相反数&lt;/p&gt;
&lt;h3 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class=&quot;headerlink&quot; title=&quot;题解：&quot;&gt;&lt;/a&gt;题解：&lt;/h3&gt;&lt;p&gt;用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="http://Jozky.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 282E Sausage Maximization</title>
    <link href="http://jozky.top/2020/04/16/CodeForces-282E-Sausage-Maximization/"/>
    <id>http://jozky.top/2020/04/16/CodeForces-282E-Sausage-Maximization/</id>
    <published>2020-04-16T14:51:52.000Z</published>
    <updated>2020-04-16T14:54:18.610Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">传送cf题目</a><br> <a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">传送牛客网题目</a><br><del>看了半个多小时的题解才搞明白，一下题解为自己的心得</del><br>参考博客（这两个讲的很详细）：<br><a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html" target="_blank" rel="noopener">参考二</a></p><blockquote><p>题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？</p><a id="more"></a><p>比如 一组数  1 2 3 4 5 6 你可以选择前缀为1 2，前缀异或和为3 选择后缀为4 5 6，后缀异或和为7<br>（前缀异或和）与（后缀异或和）异或值为4，但此时4并不是最大情况，求出最大情况</p></blockquote><p><strong>思路：</strong><br>首先讲个小例题：</p><blockquote><p>  给一个数 a，还有一堆数，怎么在这一堆数中找出一个数 b，a 和 b 的异或值最大？</p></blockquote><p>最暴力的方法无疑是（<del>老办法</del>）  枚举，枚举每一个b，但这样肯定不行<del>（不然我写这个博客干什么）</del> ，想想计算机的本质是啥？对，二进制。我们把a与这堆数转化成二进制，把后面这堆数装进一个字典树，当然要从最高位装，比如这堆数是123456，如图<img src="https://uploadfiles.nowcoder.com/files/20200326/543071257_1585188887053_20200326000539458.jpg" alt="这堆数是123456">根据异或规则不同为一，所以我们要使a与b异或最大，就要让b尽可能与a不同，a已经给定，b已经形成字典树，我们就从字典树root开始，尽量找出于a当前位置不同的数，直到找到最低位为止，那么这样找到的b满足条件。</p><p><strong>回到这个题：</strong><br>首先这些n个数组成一个区间w，w的全部异或结果是定值K,所以问题可以改成在区间w中取连续一段区间m，m的异或结果为X，m的前部分就成为区间w的前缀，后半部分就是区间w的后缀。<br>我们知道相同的数异或为零，那么X与K异或，重复的那部分区间异或后为零，就相当于是我们题目所求的<br>，所以就是求什么情况下X xor K最大。<br>发现现在的情况和一开始讲的例题很像了吧，我们假设有个Y，Y与K的每一个二进制相异，我们就要让X尽可能接近Y。<br>怎么实现呢？也是建一个字典树，将f[i]放进去（f[i]=a[1] ^ a[2]  ^ a[3] ^ …^ a[i]）,那么f[i]^f[j]=a[i+1] ^ a[i+2] ^ … ^a<a href="i之前的部分为i和j共有，一异或就相当于没了">j</a>可以表示i+1到j这段区间的异或值。<br>我们枚举区间m的结尾，每次用一个f[i]去匹配一个f[k]，使得f[k]^f[i]的值在高位上尽可能去接近Y，这样就相当于选出区间[k+1,i]de异或值作为X，每次在[1,i]区间内匹配出来一个最佳区间后，不断更新答案。<br>看懂了吗？这些神奇的操作，巧妙利用字典树（工具人石锤）来匹配。<br>(太晚了就不重新打代码了，借用下<a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a>的代码)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//范围是10的12次方，我们就将每个数固定为40位</span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define LL long long</span></span><br><span class="line"><span class="comment">#define rep(i,j,k) for(int i = j; i &lt;= k; i++ )</span></span><br><span class="line"><span class="comment">#define Rrep(i,j,k) for(int i = j; i &gt;= k; i-- )</span></span><br><span class="line"><span class="comment">#define Clean(x,y) memset(x,y,sizeof(x)) </span></span><br><span class="line">int n;</span><br><span class="line">LL a[100009];</span><br><span class="line">LL temp;</span><br><span class="line">LL ans;</span><br><span class="line"> </span><br><span class="line">LL p[45];</span><br><span class="line">int aim[45];</span><br><span class="line">int Next[1000000][2];</span><br><span class="line">int len;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    Clean(Next,0);</span><br><span class="line">    len = 0;</span><br><span class="line">&#125;</span><br><span class="line">void insert(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( !Next[now][k] ) Next[now][k] = ++len;</span><br><span class="line">        now = Next[now][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL query(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    LL ans = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( ( aim[i] &amp;&amp; Next[now][1-k] ) || ( !aim[i] &amp;&amp; Next[now][k] )  )</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=p[i];</span><br><span class="line">            now = aim[i]==1?Next[now][1-k]:Next[now][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now = aim[i]==0?Next[now][1-k]:Next[now][k];</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    rep(i,1,40) p[i] = p[i-1]&lt;&lt;1;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        ans = 0;</span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(<span class="string">"%I64d"</span>,&amp;temp);</span><br><span class="line">            a[i] = temp ^ a[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,a[n]);</span><br><span class="line">        rep(i,0,39)</span><br><span class="line">            <span class="keyword">if</span> ( a[n] &amp; p[i] ) aim[i] = 0; //计算Y</span><br><span class="line">            <span class="keyword">else</span> aim[i] = 1;</span><br><span class="line">        init();</span><br><span class="line">        insert(a[0]); </span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(a[i]);</span><br><span class="line">            ans = max(ans,query(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/282/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送cf题目&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/109910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送牛客网题目&lt;/a&gt;&lt;br&gt;&lt;del&gt;看了半个多小时的题解才搞明白，一下题解为自己的心得&lt;/del&gt;&lt;br&gt;参考博客（这两个讲的很详细）：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考二&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字典树" scheme="http://Jozky.top/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="前缀异或和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月14日题目精讲 Xorto</title>
    <link href="http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/"/>
    <id>http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/</id>
    <published>2020-04-16T14:47:16.000Z</published>
    <updated>2020-04-16T14:54:21.231Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14247" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；<br>第二行n个整数表示数组； 1&lt;=n&lt;=1000,0&lt;=数组元素&lt;100000。</p></blockquote><a id="more"></a><p>输出描述:<br>一行一个整数表示答案。<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>说明<br>([1,1],[2,2]),([1,1],[3,3]),([1,1],[2,3]),([1,2],[3,3]),([2,2],[3,3])</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>枚举？TLE√<br>暴力肯定过不了，我们可以先考虑只枚举一个区间[x,y]，这个区间可以通过前缀异或和得到。pre来存前缀<br>我们用[x,y]表示右边的区间，题目要求左右区间异或和为0，也就是问[x,y]左边有多少和它值一样的区间。<br>我们可以用a[i]来存，a[i]表示左边异或和为i区间个数，数组a反应的数量，i反映的是值。<br>先将区间[k,i]存进a中，再用a[ ]来查看左边有多少区间异或和值与右区间[i+1 , j]值相同。<br>因为a存的是数量，所以直接用ans+=a [ pre[i] ^ [j] ]</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]^x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) a[pre[i]^pre[k]]++;<span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) ans += a[pre[i]^pre[j]];<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>关于异或的题我最近做了个<br>CF282E    Sausage Maximization<br><a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">牛客网题目链接</a><br>异或的题，解法挺新颖，不过不知道为什么牛客网这里不能 提交？<br>原题是cf的<a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">cf题目链接</a><br><a href="https://blog.nowcoder.net/n/2369369adcb44ebcbaf9be0a1894aa4a" target="_blank" rel="noopener">我自己写的题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14247&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；&lt;br&gt;第二行n个整数表示数组； 1&amp;lt;=n&amp;lt;=1000,0&amp;lt;=数组元素&amp;lt;100000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="前缀异或和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网 【每日一题】4月10日 二分图染色(弱化版)</title>
    <link href="http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/"/>
    <id>http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/</id>
    <published>2020-04-16T09:31:39.000Z</published>
    <updated>2020-04-16T09:34:12.627Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/13229" target="_blank" rel="noopener">题目传送</a></p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p></blockquote><p>题目描述 </p><blockquote><p>给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。<br>计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>二分图单边的顶点数目n(n ≤ 10^7)</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数,即所求的答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure><h2 id="题意-amp-amp-题解：："><a href="#题意-amp-amp-题解：：" class="headerlink" title="题意&amp;&amp;题解：："></a>题意&amp;&amp;题解：：</h2><p>完全二分图:是一种特殊的二分图，可以把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连。<br>我们可以把左右各有n个点的二分图的题转化成n*n的棋盘问题。（离散上学过）<br>题目：让染三个颜色，红蓝绿，但是绿色并没有什么要求，我们可以最后再随便放。所以我们先考虑红和蓝。<br>红和蓝都是不能共享端点，同步到棋盘上（行和列分别表示二分图两个集合），也就是棋盘上行和列只能有一个红或蓝</p><p>现在的题目就是：<br>在n*n的棋盘上，放任意红和蓝棋子，任一行和列不能有相同颜色的棋子，有多少种放的方法？<br>F<del>n</del>表示棋盘大小为 n * n时的答案<br>先只考虑一个颜色： F<del>n</del>=<img src="https://img-blog.csdnimg.cn/20200416162741561.png" alt="在这里插入图片描述">)种方案(先在n行里选若干行，然后每一行选若干列，行没有顺序区分，就是选两行，选第一行和第三行与选第一行和第二行没差，所以选行用组合；而列不一样，因为行列只能放一个，我们可以先放在一行上，然后分散到其他行，所以选列的时候要考虑顺序问题，要用的是排列而不是组合)<br>如图：<br><img src="https://img-blog.csdnimg.cn/20200416164224892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如我们选两行（C^2^ <del>n</del> ），然后每行放一个，我们先考虑都放在一行上，看图中最上面两行（黄色和绿色），都是选的第一个格和第二个格，但是分散开不一样，（图中4 * 4的表格）说明我们要考虑顺序，所以选列是A^2^<del>n</del>，将所以情况加起来就是选一个颜色的方案</p><p>选两个颜色：从上面我们能得到一个颜色是F<del>n</del>，两个就是F<del>n</del>* F<del>n</del>，非也，因为这样会出现一个格子放两个棋子，我们还要将这种情况删去。需要容斥。<br>我们用g<del>i</del>表示最少有i个点放了两个棋子（颜色不一样）的方案数。那么除去i 行和i 列（i个点所在），我们在剩下n-i行与列里就不会有重复的，g<del>i</del> = f ^2^<del>n-i</del> 。被除去的 i 行与 i列选法和之前一样是 C^i^<del>n</del>A^i^<del>n</del> ，最后得到容斥公式：<br><img src="https://img-blog.csdnimg.cn/20200416170156368.png" alt="在这里插入图片描述"><br>（这一部分好好理解）</p><p>C^k^<del>n</del>A^k^<del>n</del>都可以求好，但是Fn提前求会超时，说明上面的公式不能用，我们要换一个想法来求<br>我们来考虑F<del>n</del>能不能递推出来，从F<del>n-1</del>推出F<del>n</del><br>考虑n-1到n的过程：<br>一共增加了2n-1个格子（n^2^-(n-1)^2^）,n-1之前的格子都已经放好了，我们只需要考虑多出的这些格子该怎么放。<br>如果只放一个棋子，就有2n-1个方案，如果都不放，一个方案，一共是2n种方案，也就是2n<em>F<del>n-1</del>，（F<del>n-1</del>是之前n-1行列已经放好的方案数）<br>但是有限制条件，每一行不能有相同颜色，每放一个棋子，意味着这一行这一列都不能放了，就会出现n-1种重复情况（因为是从n-1的扩展来的），我们之前n-1行列的棋子都平移靠边，因为之前都是不同行同列，所以靠边后，正好占了一行一列，也就是我们在新增部分可以放的棋子，实际上是F<del>n-2</del>而非F<del>n-1</del>（这里可以看看图），那一共（n-1）F<del>n-2</del>次重复情况，可以选n-1行，而且每一列也可以进行相同操作,总的方案数就是2×(n−1) ^2^ ∗F(n−2)<br>借鉴邓老师的图：<br><img src="https://img-blog.csdnimg.cn/2020041617195483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还要考虑放两个的情况;<br>即最后一行和列分别放一个，这样不重复嘛<br>方案就是：（n-1）^2^</em>F(n-2)<br><img src="https://img-blog.csdnimg.cn/20200416172115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：得到公式<br>F[n]=2<em>n</em>F[n-1]-(n-1)^2^F[n-2]<br>（<del>我真的是把我所能理解都写出来了</del> ）</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000004</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N],s[N],F[N];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[m] % mod * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        g[i] = <span class="number">1l</span>l * g[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        </span><br><span class="line">         ll ans1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y &gt;&gt;= <span class="number">1</span>,x = x * x % mod)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans1 = ans1 * x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    s[n] = ans1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        s[i] = <span class="number">1l</span>l * s[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;F[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">        F[i] = (<span class="number">2l</span>l * i * F[i - <span class="number">1</span>] - <span class="number">1l</span>l * F[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod * (i - <span class="number">1</span>) % mod) % mod;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">     ll k ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">       k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) k = <span class="number">-1</span>;</span><br><span class="line">        ans += k * C(n,i) * A(n,i) % mod * F[n - i] % mod * F[n - i] % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans + mod) % mod);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 524288K，其他语言1048576K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。&lt;br&gt;计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合" scheme="http://Jozky.top/tags/%E7%BB%84%E5%90%88/"/>
    
      <category term="容斥" scheme="http://Jozky.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】合集</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/</id>
    <published>2020-04-15T11:53:47.000Z</published>
    <updated>2020-04-16T09:39:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C"><a href="#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C" class="headerlink" title="2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C"></a>2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/">题解</a></p><h2 id="2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮"><a href="#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮"></a>2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">题解</a></p><a id="more"></a><h2 id="2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛"><a href="#2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛" class="headerlink" title="2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛"></a>2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/">题解</a></p><h2 id="2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5"><a href="#2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5" class="headerlink" title="2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5"></a>2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5</h2><p><a href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">题解</a></p><h2 id="2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛"><a href="#2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛" class="headerlink" title="2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛"></a>2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛</h2><p><a href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/">题解</a></p><h2 id="2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11"><a href="#2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11" class="headerlink" title="2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11"></a>2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/">题解</a></p><h2 id="2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12"><a href="#2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12" class="headerlink" title="2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12"></a>2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12</h2><p><a href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/">题解</a></p><h2 id="2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛"><a href="#2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛" class="headerlink" title="2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛"></a>2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛</h2><p><a href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/">题解</a></p><h2 id="2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛"><a href="#2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛" class="headerlink" title="2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛"></a>2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/">题解</a></p><h2 id="2020年4月7日-NC13611-树-牛客练习赛1"><a href="#2020年4月7日-NC13611-树-牛客练习赛1" class="headerlink" title="2020年4月7日 NC13611 树 牛客练习赛1"></a>2020年4月7日 NC13611 树 牛客练习赛1</h2><p><a href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/">题解</a></p><h2 id="2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮"><a href="#2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮" class="headerlink" title="2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮"></a>2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮</h2><p><a href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/">题解</a></p><h2 id="2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05"><a href="#2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05" class="headerlink" title="2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05"></a>2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05</h2><p><a href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/">题解</a></p><h2 id="2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮"><a href="#2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮"></a>2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/16/牛客网-【每日一题】4月10日-二分图染色-弱化版/">题解</a></p><h2 id="2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54"><a href="#2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54" class="headerlink" title="2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54"></a>2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54</h2><p><a href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/">题解</a></p><h2 id="2020年4月14日-NC14247-Xorto-Wannafly挑战赛1"><a href="#2020年4月14日-NC14247-Xorto-Wannafly挑战赛1" class="headerlink" title="2020年4月14日 NC14247 Xorto Wannafly挑战赛1"></a>2020年4月14日 NC14247 Xorto Wannafly挑战赛1</h2><h2 id="2020年4月15日-NC14248-Treepath-Wannafly挑战赛1"><a href="#2020年4月15日-NC14248-Treepath-Wannafly挑战赛1" class="headerlink" title="2020年4月15日 NC14248 Treepath Wannafly挑战赛1"></a>2020年4月15日 NC14248 Treepath Wannafly挑战赛1</h2><h2 id="2020年4月16日-NC14731-逆序对-Wannafly挑战赛6"><a href="#2020年4月16日-NC14731-逆序对-Wannafly挑战赛6" class="headerlink" title="2020年4月16日 NC14731 逆序对 Wannafly挑战赛6"></a>2020年4月16日 NC14731 逆序对 Wannafly挑战赛6</h2><h2 id="未完再续。。。"><a href="#未完再续。。。" class="headerlink" title="未完再续。。。"></a>未完再续。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C&quot;&gt;&lt;a href=&quot;#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C&quot; class=&quot;headerlink&quot; title=&quot;2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C&quot;&gt;&lt;/a&gt;2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮&quot;&gt;&lt;a href=&quot;#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮&quot; class=&quot;headerlink&quot; title=&quot;2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮&quot;&gt;&lt;/a&gt;2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客算法周周练2</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/</id>
    <published>2020-04-15T11:53:10.000Z</published>
    <updated>2020-04-15T11:53:10.035Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月13号 Accumulation Degree</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/</id>
    <published>2020-04-15T11:37:51.000Z</published>
    <updated>2020-04-15T11:39:34.471Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/51180" target="_blank" rel="noopener">本题目传送</a></p><p>题目树学是这个题的简易版，也涉及换根问题，可以先看看这个<br><a href="https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92" target="_blank" rel="noopener">树学</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit<br>IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>Trees are an important component of the natural landscape because of<br>their prevention of erosion and the provision of a specific<br>ather-sheltered ecosystem in and under their foliage. Trees have also</p><a id="more"></a><p>been found to play an important role in producing oxygen and reducing<br>carbon dioxide in the atmosphere, as well as moderating ground<br>temperatures. They are also significant elements in landscaping and<br>agriculture, both for their aesthetic appeal and their orchard crops<br>(such as apples). Wood from trees is a common building material.</p><p>Trees also play an intimate role in many of the world’s mythologies.<br>Many scholars are interested in finding peculiar properties about<br>trees, such as the center of a tree, tree counting, tree coloring.<br>A(x) is one of such properties.</p></blockquote><p>A(x) (accumulation degree of node x) is defined as follows:</p><ol><li>Each edge of the tree has an positive capacity.</li><li>The nodes with degree of one in the tree are named terminals.</li><li>The flow of each edge can’t exceed its capacity.</li><li>A(x) is the maximal flow that node x can flow to other terminal nodes.</li></ol><p>Since it may be hard to understand the definition, an example is showed below:<br><img src="https://img-blog.csdnimg.cn/20200415184510424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="样例分析："><a href="#样例分析：" class="headerlink" title="样例分析："></a>样例分析：</h2><p>A(1)=11+5+8=24<br>Details:<br>1-&gt;2    11<br>1-&gt;4-&gt;3    5<br>1-&gt;4-&gt;5    8(since 1-&gt;4 has capacity of 13)</p><hr><p>A(2)=5+6=11<br>Details:<br>2-&gt;1-&gt;4-&gt;3    5<br>2-&gt;1-&gt;4-&gt;5    6</p><hr><p>A(3)=5<br>Details:    3-&gt;4-&gt;5    5</p><hr><p>A(4)=11+5+10=26<br>Details:    4-&gt;1-&gt;2    11<br>4-&gt;3    5<br>4-&gt;5    10</p><hr><p>A(5)=10<br>Details:    5-&gt;4-&gt;1-&gt;2    10</p><hr><p>The accumulation degree of a tree is the maximal accumulation degree among its nodes. Here your task is to find the accumulation degree of the given trees.</p><p>输入描述:<br>The first line of the input is an integer T which indicates the number of test cases. The first line of each test case is a positive integer n. Each of the following n - 1 lines contains three integers x, y, z separated by spaces, representing there is an edge between node x and node y, and the capacity of the edge is z. Nodes are numbered from 1 to n.<br>All the elements are nonnegative integers no more than 200000. You may assume that the test data are all tree metrics.<br>输出描述:<br>For each test case, output the result on a single line.<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>看看样例分析应该就明白了<br>每个节点都有流量，求出最大流量是多少？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>flow【i】表示i点的流量：<br>一个点的流量是怎么来的？如果j（j是i的子节点）的流量小于i与j边的容量，flow【i】=flow[j]，如果大于两点之间的容量，flow[i]=i与j的流量<br>i与j的流量就是i与j的边权，我们用edge[i][j]表示。<br>可以得到公式：flow[i]=∑min(flow[j],edge[i][j])<br>因为i有可能有很多子节点，所以加在一起<br>考虑完i之后，我们来考虑换根<br>如图：<img src="https://img-blog.csdnimg.cn/20200415185955370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们将根从x换成y<br>题一中（以x为根）<br>x的流量来自于y，子树2，子树3<br>y的流量来自于子树1<br>图二中（以y为根）<br>x的流量来自子树2，子树3<br>y的流量来自子树1，x</p><p>我们发现换根后，x的流量就没有了y的部分，其他都还在，此时x的流量就是原本的减去从y流向x的部分，new[x]=flow[ x ] - min ( flow[ y ] , edge[ x ] [ y ] ),这个new表示x新的流量</p><p>我们再看y，y的流量多了从x流来的部分，y的流量就是flow[y]+min(new[x],edge[x][y])，，因为换根x的流量发生改变（上一段所讲），那流向y的是现在x的流量，而不是换跟前的flow[x].</p><p>换根前后，图二中绿色区域没有发生改变，也就是父节点改变影响不到子节点</p><p>还要注意叶子节点，如果x从根变成叶子节点（x的儿子只有y，当y成为根节点之后，x没有了儿子），x的流量不是上面的公式，而是变成了edge[x][y]，因为没有子节点的流量流向x，只有x与y的边权值，也就是上面讲的式子使用条件是min（x，y），x和y不能为0。</p><p>先求出x为根的流量，然后依次换根求出最大值</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt = <span class="number">0</span>, d[maxn], deg[maxn], f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].x = x;</span><br><span class="line">    edge[cnt].y = y;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg[y] == <span class="number">1</span>)&#123;<span class="comment">//如果y只有一个子节点，y的流量只能是root与y的边权值 </span></span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(y, root);</span><br><span class="line">            ans += min(d[y], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[root] = ans </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//先求出节点x的流量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg[x] == <span class="number">1</span>)&#123;</span><br><span class="line">            f[y] = d[y] + edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[y] = d[y] + min(f[x] - min(d[y], edge[i].w), edge[i].w);<span class="comment">//核心公式 </span></span><br><span class="line">        &#125;</span><br><span class="line">        dp(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//从x不断换根 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">       <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();<span class="comment">//初始化 </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">         </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            addedge(x, y, w);<span class="comment">//添边 </span></span><br><span class="line">            addedge(y, x, w);<span class="comment">//添边 </span></span><br><span class="line">                deg[x]++;<span class="comment">//deg用于判断这个点有几个子节点 </span></span><br><span class="line">     deg[y]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        dfs(s, <span class="number">0</span>);<span class="comment">//求x的流量 </span></span><br><span class="line">        f[s] = d[s];</span><br><span class="line">        dp(s, <span class="number">0</span>);<span class="comment">//不断换根 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ans = max(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51180&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本题目传送&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目树学是这个题的简易版，也涉及换根问题，可以先看看这个&lt;br&gt;&lt;a href=&quot;https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树学&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit&lt;br&gt;IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Trees are an important component of the natural landscape because of&lt;br&gt;their prevention of erosion and the provision of a specific&lt;br&gt;ather-sheltered ecosystem in and under their foliage. Trees have also&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="换根" scheme="http://Jozky.top/tags/%E6%8D%A2%E6%A0%B9/"/>
    
      <category term="二次扫描" scheme="http://Jozky.top/tags/%E4%BA%8C%E6%AC%A1%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>树学</title>
    <link href="http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/"/>
    <id>http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/</id>
    <published>2020-04-14T14:35:39.000Z</published>
    <updated>2020-04-14T14:39:06.221Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/201400" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:&gt; %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep<del>root</del>为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep<del>i</del>=dep<del>fa</del> <del>i</del>+1,整棵树的价值W=<img src="https://img-blog.csdnimg.cn/20200414204932422.png" alt="在这里插入图片描述"> ，即所有点的深度和</p><a id="more"></a><p>牛妹希望这棵树的W最小，请你告诉她，选择哪个点可以使W最小<br>输入描述:<br>第一行，一个数，n<br>接下来n-1行，每行两个数x,y，代表x-y是树上的一条边<br>输出描述:<br>一行，一个数，最小的W<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>备注:<br>对于30%30%的数据，1&lt;= n&lt;=1000<br>对于100%100%的数据，1&lt;=n &lt;=10^6^</p><h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>树形dp+换根<br>用到的几个函数：<br>dep[i]：节点i的深度<br>ant[i]：i的子树的个数（含本身）<br>f[x]：以x为根的每个节点深度的和<br><img src="https://img-blog.csdnimg.cn/20200414211409638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图一为以u为根节点<br>图二为以v为根节点<br>从u转到v 之后，图二中黄色区域（u和子树1和子树2）根节点都加1（因为成为别人的子节点），绿色区域（v和根节点2）根节点减1（因为成为别人的根节点）<br>那转换成公式是什么样的？<br>f[v]=（f[u]-ant[v]）+(n-ant[v]);<br>怎么理解呢？<br>第一个括号里，是将图二的绿色区域根节点减一，因为黄色区域一共ant[v]个节点，这个区域内每个节点都减1，所以整个区域f[u]要减ant[v].<br>第二个括号就是黄色区域每个节点都加一，那整个区域就加这个区域的节点数，这个区域的节点数=整个区域-绿色区域，所以就是n-ant[v]<br>我们从1开始dfs，求出每个节点的深度，即dep[]<br>然后再dfs求出每个点子树数量,再dfs换成其他根，利用公式求出f来</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//链式前项星 </span></span><br><span class="line">ll head[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//无向边，所以乘2</span></span><br><span class="line">ll dep[maxn];<span class="comment">//节点的深度 </span></span><br><span class="line">ll ant[maxn];<span class="comment">//节点x的子树数量（包含本身） </span></span><br><span class="line">ll f[maxn];<span class="comment">//以i为根的时候每个点深度的和 </span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll minn=<span class="number">1e7</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++cnt].v=v;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">forr(n)f[<span class="number">1</span>]+=dep[i];<span class="comment">//在dfs1求完每个点深度后，接着求出以1为根的时候每个点深度的和  </span></span><br><span class="line">forr(n)ant[i]=<span class="number">1</span>;<span class="comment">//每个节点的子树一开始都是本身 </span></span><br><span class="line">&#125;</span><br><span class="line">ll v=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">dfs1(v,now);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//以1为根节点开始，计算出每个节点的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> dfs2(v,now);</span><br><span class="line"> ant[now]+=ant[v]; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="comment">//求出x节点的子树数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> f[v]=f[now]-ant[v]+(n-ant[v]); </span><br><span class="line"> dfs3(v,now);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1开始换成其他根，并求出其他根的f值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">init(n);<span class="comment">//初始化 </span></span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">dfs3(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,f[i]);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minn;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看会发现dfs1与dfs2结构相似，完全可以和在一起写<br>或者用vector写更简洁</p><h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p>我看有很多大佬都用重心的性质来做<br>树的重心有一个这样的性质：在树中所有点到某点的距离和 当中，到树的重心的距离和是最小的，如果有多个重心，那他们距离和一样。<br>树中所有点到重心的距离和最小，不就是我们要求的那个值吗。<br>先用dfs树形dp求出重心，再求出重心与每个点的距离进行累加求和</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ant[maxn],root[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">ll res;</span><br><span class="line">ll point=maxn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ant[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(u,v);</span><br><span class="line">            </span><br><span class="line">            ant[v]+=(ant[u]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            maxx=max(ant[u],maxx);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxx=max(n-ant[v]<span class="number">-1</span>,maxx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(maxx&lt;point)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">        point=maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxx==point)</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res+=dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">            dfs2(u,v,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关树的重心其他性质，有空专门讲讲</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/201400&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format:&amp;gt; %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep&lt;del&gt;root&lt;/del&gt;为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep&lt;del&gt;i&lt;/del&gt;=dep&lt;del&gt;fa&lt;/del&gt; &lt;del&gt;i&lt;/del&gt;+1,整棵树的价值W=&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414204932422.png&quot; alt=&quot;在这里插入图片描述&quot;&gt; ，即所有点的深度和&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="换根" scheme="http://Jozky.top/tags/%E6%8D%A2%E6%A0%B9/"/>
    
      <category term="树的重心" scheme="http://Jozky.top/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
  </entry>
  
  <entry>
    <title>使用一段时间牛客网的心得</title>
    <link href="http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/</id>
    <published>2020-04-13T16:06:43.000Z</published>
    <updated>2020-04-14T14:39:10.022Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（<del>心痛</del> ）<br>牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉<br>一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。<br>等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200414000658411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414000643124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>背包等着我<del>~</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（&lt;del&gt;心痛&lt;/del&gt; ）&lt;br&gt;牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉&lt;br&gt;一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。&lt;br&gt;等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="文章" scheme="http://Jozky.top/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月9日题目精讲 Running Median</title>
    <link href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/"/>
    <id>http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/</id>
    <published>2020-04-12T16:32:26.000Z</published>
    <updated>2020-04-12T16:33:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://ac.nowcoder.com/acm/problem/50940" target="_blank" rel="noopener">–&gt;链接&lt;—</a></p><blockquote><p>时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit<br> IO Format:%lld</p></blockquote><p>题目描述 </p><blockquote><p>For this problem, you will write a program that reads in a sequence of<br>32-bit signed integers. After each odd-indexed value is read, output<br>the median (middle value) of the elements received so far.</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>The first line of input contains a single integerP(1≤P≤1000), which is the number of data sets that follow. The<br>first line of each data set contains the data set number, followed by<br>a space, followed by an odd decimal integer (1≤M≤9999), giving the total number of signed integers to be<br>processed. The remaining line(s) in the dataset consists of the<br>values, 10 per line, separated by a single space. The last line in the<br>dataset may contain less than 10 values.</p></blockquote><p>输出描述:</p><blockquote><p>For each data set the first line of output contains the data set<br>number, a single space and the number of medians output (which should<br>be one-half the number of input values plus one). The output medians<br>will be on the following lines, 10 per line separated by a single<br>space. The last line may have less than 10 elements, but at least 1<br>element. There should be no blank lines in the output.</p></blockquote><p>示例1<br>输入<br>3<br>1 9<br>1 2 3 4 5 6 7 8 9<br>2 9<br>9 8 7 6 5 4 3 2 1<br>3 23<br>23 41 13 22 -3 24 -31 -11 -8 -7<br>3 5 103 211 -311 -45 -67 -73 -81 -99<br>-33 24 56<br>输出<br>1 5<br>1 2 3 4 5<br>2 5<br>9 8 7 6 5<br>3 12<br>23 23 22 22 13 3 5 5 3 -3<br>-7 -3</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你m个数，一次输入，每当输入的个数为奇数时，输出按大小排列最中间的数<br>比如1 5 6 7 8<br>一开始输入1，输出1<br>然后输入1 5，不输出<br>输入1 5 6，输出5<br>输入1 5 6 7，不输出<br>输入1 5 6 7 8，输出6</p><h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>可以用堆来做<br>w1为大堆，w1用于存放小值<br>w2为小堆，w2存放大值<br>比如上面那个例子1 5 6 7 8<br>奇数位存在w1，偶数存在w2<br>如果w1.top()&gt;w2.top(),就是w1的最大比w2的最小值大，就将这两个值互换，始终保证，w1的值比w2的任意一个都小，这样无论数据怎么读入，w1的最大值始终都是最中间的数<br>看下面模拟：<br>第一轮：<br>w1:1<br>w2：0<br>二：<br>w1:1<br>w2:5<br>三：<br>w1:1 6<br>w2:5<br>6&gt;5<br>w1:1 5<br>w2:6<br>四<br>w1:1 5<br>w2: 7 6<br>五<br>w1:1 5 8<br>w2: 7 6<br>8&gt;6<br>w1:1 5 6<br>w2; 7 8<br>这样每奇数轮，w1的top位就是答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;w1;<span class="comment">//默认为大堆，从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;w2;<span class="comment">//默认为小堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">  <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p,m,x;</span><br><span class="line">    <span class="keyword">int</span> minn,maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;m;</span><br><span class="line">        case1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p,m/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)w1.push(x);</span><br><span class="line">            <span class="keyword">else</span> w2.push(x);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                minn=w1.top();</span><br><span class="line">                maxx=w2.top();</span><br><span class="line">                <span class="keyword">if</span>(minn&gt;maxx)</span><br><span class="line">                &#123;</span><br><span class="line">                    w1.pop();</span><br><span class="line">                    w2.pop();</span><br><span class="line">                    w1.push(maxx);</span><br><span class="line">                    w2.push(minn);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(case1!=<span class="number">0</span>&amp;&amp;case1%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                case1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==m)<span class="built_in">cout</span>&lt;&lt;w1.top();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,w1.top());</span><br><span class="line">                case1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(!w1.empty())w1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!w2.empty())w2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这个题的格式我一开始一直没注意。。。）</p><h2 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h2><p>我看很多人都是这么做的，但是只能过50%的数据。。包括我自己<br>我看了清楚姐姐的代码稍微改一下：<br>我们在读入一个数后，直接与w1.top比较，小于就存进去，大了就存w2里<br>当w1的数量多了，就把堆顶拿出给w2（小根堆）<br>w2多了就给大根堆<br>这样维护出来其实和上面的方法差不多<br>因为总数是奇数，两个堆数量一定不一样，多的那方，堆顶就是答案<br>代码：<br>清楚阿姨（<del>狗头</del> ）代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//小根堆 ，存较大的一半的数</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">//大根堆 ，存较小的一半的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty()) q2.pop();  <span class="comment">//优先队列没有clear函数，要一个一个弹出</span></span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m ,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m, (n+<span class="number">1</span>)/ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &lt;= q1.top()) q1.push(x); <span class="comment">//如果当前值比大根堆堆顶小，说明在小的这二分之一，塞进大根堆</span></span><br><span class="line">            <span class="keyword">else</span>  q2.push(x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> num1= q1.size();</span><br><span class="line">            <span class="keyword">int</span> num2= q2.size();</span><br><span class="line">            <span class="keyword">if</span> (num1 - num2 &gt; <span class="number">1</span>)   <span class="comment">//大根堆里面元素多了，把堆顶拿出来塞近小根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.top());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(num2 - num1 &gt;<span class="number">1</span>) <span class="comment">//小根堆里面元素多了，把堆顶拿出来塞近大根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.top());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//目前的元素个数是奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                num1 = q1.size();</span><br><span class="line">                num2 = q2.size();</span><br><span class="line">                <span class="keyword">if</span>(num1 &gt; num2) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q1.top()); <span class="comment">//中位数在大根堆</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, q2.top());           <span class="comment">//中位数在小根堆</span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">19</span> &amp;&amp; i!=n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;–&amp;gt;链接&amp;lt;—&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit&lt;br&gt; IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this problem, you will write a program that reads in a sequence of&lt;br&gt;32-bit signed integers. After each odd-indexed value is read, output&lt;br&gt;the median (middle value) of the elements received so far.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="堆" scheme="http://Jozky.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>浅谈LCA</title>
    <link href="http://jozky.top/2020/04/12/%E6%B5%85%E8%B0%88LCA/"/>
    <id>http://jozky.top/2020/04/12/%E6%B5%85%E8%B0%88LCA/</id>
    <published>2020-04-12T09:30:59.000Z</published>
    <updated>2020-04-12T10:21:22.428Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="LCA介绍"><a href="#LCA介绍" class="headerlink" title="LCA介绍"></a>LCA介绍</h2><p>lca是啥？最近公共祖先<br>就是：两个点在这棵树上距离最近的公共祖先节点<br>LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）<br>来看一个经典图<br><img src="https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>LCA（4,5）=2<br>LCA（4,3）=1<br>LCA（2,1）=1</p><h2 id="解决方法概括："><a href="#解决方法概括：" class="headerlink" title="解决方法概括："></a>解决方法概括：</h2><p>常用四种方法 ：</p><ol><li>用倍增法求解，预处理复杂度是 O(nlogn) ,每次询问的复杂度是 O(logn), 属于在线解法。</li><li>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)，每次询问的复杂度为 O(1)，也是在线算法。</li><li>采用Tarjan算法求解，复杂度 O(α(n)+Q)，属于离线算法。</li><li>利用树链剖分求解，复杂度预处理O(n)，单次查询 O(logn) ，属于在线算法。</li></ol><h2 id="倍增法："><a href="#倍增法：" class="headerlink" title="倍增法："></a>倍增法：</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;LCA介绍&quot;&gt;&lt;a href=&quot;#LCA介绍&quot; class=&quot;headerlink&quot; title=&quot;LCA介绍&quot;&gt;&lt;/a&gt;LCA介绍&lt;/h2&gt;&lt;p&gt;lca是啥？最近公共祖先&lt;br&gt;就是：两个点在这棵树上距离最近的公共祖先节点&lt;br&gt;LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）&lt;br&gt;来看一个经典图&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LCA" scheme="http://Jozky.top/tags/LCA/"/>
    
  </entry>
  
  <entry>
    <title>牛客算法周周练1</title>
    <link href="http://jozky.top/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/"/>
    <id>http://jozky.top/2020/04/11/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%831/</id>
    <published>2020-04-11T08:45:11.000Z</published>
    <updated>2020-04-15T11:52:43.195Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="A-Maximize-The-Beautiful-Value"><a href="#A-Maximize-The-Beautiful-Value" class="headerlink" title="A Maximize The Beautiful Value"></a>A Maximize The Beautiful Value</h2><p><a href="http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/">站内题解</a></p><h2 id="B-身体训练"><a href="#B-身体训练" class="headerlink" title="B 身体训练"></a>B 身体训练</h2><p><a href="http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/">站内题解</a></p><a id="more"></a><h2 id="C-Borrow-Classroom"><a href="#C-Borrow-Classroom" class="headerlink" title="C Borrow Classroom"></a>C Borrow Classroom</h2><p>待定。。。</p><h2 id="D-景区路线规划"><a href="#D-景区路线规划" class="headerlink" title="D 景区路线规划"></a>D 景区路线规划</h2><p>待定。。。</p><h2 id="E-幸运数字Ⅱ"><a href="#E-幸运数字Ⅱ" class="headerlink" title="E 幸运数字Ⅱ"></a>E 幸运数字Ⅱ</h2><p><a href="http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/">站内题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;A-Maximize-The-Beautiful-Value&quot;&gt;&lt;a href=&quot;#A-Maximize-The-Beautiful-Value&quot; class=&quot;headerlink&quot; title=&quot;A Maximize The Beautiful Value&quot;&gt;&lt;/a&gt;A Maximize The Beautiful Value&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/&quot;&gt;站内题解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;B-身体训练&quot;&gt;&lt;a href=&quot;#B-身体训练&quot; class=&quot;headerlink&quot; title=&quot;B 身体训练&quot;&gt;&lt;/a&gt;B 身体训练&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/&quot;&gt;站内题解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>幸运数字Ⅱ </title>
    <link href="http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/"/>
    <id>http://jozky.top/2020/04/11/%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%E2%85%A1/</id>
    <published>2020-04-11T08:38:26.000Z</published>
    <updated>2020-04-11T08:50:51.099Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/E" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld</p></blockquote><p>题目描述</p><blockquote><p>定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。<br>定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r</p><ul><li>1) + next(r)。 输入描述:</li></ul><p>两个整数l和r (1 &lt;= l &lt;= r &lt;= 1000,000,000)。</p></blockquote><a id="more"></a> <p>输出描述:</p><blockquote><p>一个数字表示答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span></span><br></pre></td></tr></table></figure><p>示例2<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span> <span class="number">7</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure><p>题意：<br>打表出奇迹<br>你可以提前打好表，记录在数组里<br>或者现打表，有两个方法<br>一个是用vector，<br>或者自身递归查找，存在pre中<br>打完表后，直接从l开始对比数到r<br>直接if判断然后sum加有点慢<br>你可以看每两个pre之间的数最后都做一样相加，比如47~74之间（不含47）的数都算作74，那有多少个数？就是74-47+1，然后直接乘74，加起来就ok了<br>注意注意！！！不要忘了longlong，可坑死我了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll pre[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b?b:a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&gt;<span class="number">1e10</span>+<span class="number">2</span>)<span class="keyword">return</span> ; </span><br><span class="line">pre[cnt++]=n;</span><br><span class="line">dfs(n*<span class="number">10</span>+<span class="number">4</span>);</span><br><span class="line">dfs(n*<span class="number">10</span>+<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void dfs(ll x)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">if(n-1e9&gt;0)return ;</span></span><br><span class="line"><span class="comment">q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">dfs((x&lt;&lt;3)+(x&lt;&lt;1)+4);</span></span><br><span class="line"><span class="comment">dfs((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">q.push_back((x&lt;&lt;3)+(x&lt;&lt;1)+7);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">dfs(0);</span></span><br><span class="line"><span class="comment">sort(q.begin(),q.end());</span></span><br><span class="line"><span class="comment">q.push_back(4444444444); </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll r,l;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;l,&amp;r);</span><br><span class="line">dfs(<span class="number">0</span>);</span><br><span class="line">sort(pre+<span class="number">1</span>,pre+<span class="number">1</span>+cnt);</span><br><span class="line"><span class="comment">//cout&lt;&lt;pre[cnt-1]&lt;&lt;endl;</span></span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line">ll ant=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i=l;i&lt;=r;)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//if(i&gt;pre[ant])ant++;</span></span><br><span class="line"><span class="comment">//sum+=pre[ant];</span></span><br><span class="line"><span class="keyword">while</span>(i&gt;pre[ant])ant++;</span><br><span class="line">sum+=pre[ant]*(min(r,pre[ant])-i+<span class="number">1</span>);</span><br><span class="line">i=pre[ant]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 262144K，其他语言524288K 64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个数字为幸运数字当且仅当它的所有数位都是4或者7。 比如说，47、744、4都是幸运数字而5、17、467都不是。&lt;br&gt;定义next(x)为大于等于x的第一个幸运数字。给定l，r，请求出next(l) + next(l + 1) + … + next(r&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1) + next(r)。 输入描述:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个整数l和r (1 &amp;lt;= l &amp;lt;= r &amp;lt;= 1000,000,000)。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="DFS" scheme="http://Jozky.top/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>身体训练 </title>
    <link href="http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/"/>
    <id>http://jozky.top/2020/04/11/%E8%BA%AB%E4%BD%93%E8%AE%AD%E7%BB%83/</id>
    <published>2020-04-11T08:38:19.000Z</published>
    <updated>2020-04-11T08:50:53.483Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/B" target="_blank" rel="noopener">牛客网</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:<br>%lld</p></blockquote><p>题目描述</p><blockquote><p>美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v<br>米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v</p><a id="more"></a> <p>米/秒。每个人最初的最高速度为c[i] 米/秒，每轮衰减d[i]<br>米/秒，也就是说，如果i是第j个跑的，那么他的速度就是c[i]-(j-1)*d[i] 米/秒。<br>n个人初始以随机的顺序排列，每种顺序的概率完全相等，跑完一轮（每个人都追到排头一次，序列恢复原样）的期望需要的时间是多少？</p></blockquote><p>输入描述:</p><blockquote><p>第一行整数n（&lt;=1000）, 实数v(&lt;=100) , 实数u(&lt;=10) 第二行n个实数每个人的速度c<a href="<=50000">i</a><br>第三行n个实数值每个人衰减量d<a href="<=10">i</a></p><p>输入数据保证每个人的速度不会衰减到&lt;=v</p></blockquote><p>输出描述:</p><p>答案保留3位小数。</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="number">37.618</span> <span class="number">0.422</span></span><br><span class="line"></span><br><span class="line"><span class="number">72.865</span> <span class="number">126.767</span> <span class="number">202.680</span> <span class="number">106.102</span> <span class="number">99.516</span> <span class="number">134.418</span> <span class="number">167.952</span> <span class="number">173.646</span> <span class="number">120.210</span> <span class="number">136.571</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.941</span> <span class="number">3.664</span> <span class="number">7.363</span> <span class="number">4.161</span> <span class="number">0.246</span> <span class="number">8.046</span> <span class="number">5.521</span> <span class="number">7.473</span> <span class="number">7.178</span> <span class="number">5.649</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.815</span></span><br></pre></td></tr></table></figure><p>题解：<br>因为除了最后一个人，其他人速率相同，那么就可以把大家都看做静止的，最后一个人的速度就是V（原本）-V（其他人的速度），可以理解成相对速度<br>题目问跑完一轮，说明每个人在每个位置都会经历一遍。虽然每个快递员位置未定，在每个位置上概率都是1/n,但是无论是什么位置，快递员要跑的相对路长是一定的，都是u<em>n。<br>（相对路长就是在相对时间内跑的距离，大家都是静止的，一共n个人，最后一名前面有n-1个人，他要从最后跑到比排头还远u，跨过了n个间隙，距离是u</em>n）<br>如果i是第j个跑的，那么他的速度就是c[i]-(j-1)<em>d[i] 米/秒。v是其他人的速度<br>相对速度就是c[i]-(j-1)</em>d[i]-v<br>距离有了速度有了，相除就可以求时间<br>可以求出每个快递员跑过每个位置所需要的的时间，累加起来就可以<br>啥是期望？数学期望(mean)是试验中每次可能结果的概率乘以其结果的总和<br>所以最后再乘以概率 1/n</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">6e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">double</span> c[maxn],d[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> v,u,sum=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;v&gt;&gt;u;</span><br><span class="line">forr(n)<span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">forr(n)<span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=u/( c[i] - v - ( j<span class="number">-1</span> ) * d[i] );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.3f"</span>,sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:&lt;br&gt;%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;美团外卖的配送员用变速跑的方式进行身体训练。 他们训练的方式是：n个人排成一列跑步，前后两人之间相隔 u 米，每个人正常速度均为 v&lt;br&gt;米/秒。 当某个配送员排在最后的时候，他需要以当时自己的最高速度往前跑，直到超过排头的人 u 米，然后降回到原始速度 v&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Maximize The Beautiful Value </title>
    <link href="http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/"/>
    <id>http://jozky.top/2020/04/11/Maximize-The-Beautiful-Value/</id>
    <published>2020-04-11T08:37:37.000Z</published>
    <updated>2020-04-16T14:52:15.352Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5086/A" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒<br>空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he<br>thinks it’s not beautiful so he wants to make it beautiful. To make<br>it, HH will choose exactly one number and move it forward at least k<br>steps(i.e. you can move ai to aj if k≤i−j), and then he defines the<br>beautiful value F(n) as  HH asks you to calculate max(F(n))</p></blockquote><a id="more"></a> <blockquote><p><img src="https://uploadfiles.nowcoder.com/files/20200411/543071257_1586538298107_20200411005140649.png" alt="在这里插入图片描述"></p></blockquote><p>输入描述:</p><blockquote><p> The first line contains an positive integer T(1≤T≤10), represents<br>there are T test cases.   For each test case:   The first line<br>contains two positive integers n,k(1≤n≤105,1≤k&lt;n)，the length of the<br>sequence ,the least steps you need to move.   The second line contains<br>n integers a1,a2…an(1≤ai≤108) - the sequence.</p><p>输出描述:</p><p>For each test case, you should output the max F(n).</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">50</span></span><br><span class="line"><span class="number">53</span></span><br></pre></td></tr></table></figure><p>说明</p><blockquote><p>In the first example, you can move the fifth number 4 for 3 steps and<br>make the sequence become [4,1,1,3,5], then the beautiful value is<br>4×1+1×2+1×3+3×4+5×5=46. You can also move the fifth number to make it<br>become [1,5,1,3,4], the beautiful value is also 46. In the second<br>example, you can move the  fifth number 5 for 2 steps and make the<br>sequence become [1,1,5,3,4] In the second example, you can move the<br>second number 1 for 1 steps and then the sequence is still [1,1,3,4,5]</p></blockquote><p>备注:</p><p>scanf is commended。</p><p> <strong>题解：</strong><br>比如：A B C D E<br>对应：1 2 3 4 5<br>此时的值为ans1=1<em>A+2<em>B+3</em>C+4<em>D+5</em>E<br>现在D移动到B前面，移动了两步<br>A D B C E<br>此时的值：ans2 = 1<em>A+2</em>D+3<em>B+4</em>C+5<em>E<br> =1</em>A+2<em>B+3</em>C+4<em>D+5</em>E-3<em>D+（B+C+D）<br>观察ans1与ans2相比有什么变化<br>发生改变就是减去这个数字的k倍，再加上被移动数字（共k个）的和<br>因为D向前移动k，说明D</em>i–&gt;D</em>(i-k)<br>BC因为D向前而被拱到后面，从B<em>i—&gt;b</em>(i+1)<br>被移动数字之和我们可以用前缀和pre实现<br>看代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(w) for(int i=w;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> sum[maxn],pre[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t,n,k;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;t);</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line">tot=<span class="number">0</span>;</span><br><span class="line">ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span>(pre));</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>,&amp;n,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cin&gt;&gt;a[i];</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">ans=ans+a[i]*i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">pre[i]=pre[i<span class="number">-1</span>]+a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>((k+<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">tot=max(tot,ans-a[i]*k+(pre[i<span class="number">-1</span>]-pre[i-k<span class="number">-1</span>]));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;tot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5086/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒&lt;br&gt;空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Today HH finds a non-decreasing sequence(a1,a2….an,ai≤ai+1), he&lt;br&gt;thinks it’s not beautiful so he wants to make it beautiful. To make&lt;br&gt;it, HH will choose exactly one number and move it forward at least k&lt;br&gt;steps(i.e. you can move ai to aj if k≤i−j), and then he defines the&lt;br&gt;beautiful value F(n) as  HH asks you to calculate max(F(n))&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="前缀后缀和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%90%8E%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>[SDOI2008]仪仗队</title>
    <link href="http://jozky.top/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/"/>
    <id>http://jozky.top/2020/04/09/SDOI2008-%E4%BB%AA%E4%BB%97%E9%98%9F/</id>
    <published>2020-04-09T14:47:44.000Z</published>
    <updated>2020-04-09T14:50:11.296Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/20313" target="_blank" rel="noopener">牛客网</a><br>题目描述</p><blockquote><p>作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *<br>N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200409214206553.png" alt="在这里插入图片描述"><br>  <a id="more"></a><br>现在，C君希望你告诉他队伍整齐时能看到的学生人数。<br>输入描述:</p><p>共一个数N。</p><p>输出描述:</p><p>共一个数，即C君应看到的学生人数。</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure><p>题解：<br>无限接近裸的欧拉函数<br>可以自己画图看看<br><img src="https://img-blog.csdnimg.cn/20200409214430241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">我来解释下我这个图，我把n=4和5画在了一起，紫色区域是4<em>4区域，红色区域（也是整个区域）是5</em>5，左上角围成一个三角形区域，我们暂时不考虑对角线上的情况（因为对角线只能看见一个，后面的都被挡住了）。<br>左下角坐标是（0,0），我们发现能看的坐标（x，y），x与y为互质，如果不是互质，就一定会被挡住，（比如（2,4）会被（1,2）挡住，而1与2互质，（1,2）就不会被挡住）<br>我们用ans记录三角区域的情况数<br>就是ans=每行的情况加一起<br>那每行有多少种，可以用欧拉函数求<br>欧拉函数的ϕ(x)表示小于x的且与x互质的数有多少个<br>ϕ(3)=2（与3互质的有1和2，一共有两个）<br>特别注意ϕ(1)=1<br>公式法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="comment">// 直接求3</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Euler</span><span class="params">( <span class="keyword">long</span> <span class="keyword">long</span> n )</span></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> res = n;</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">long</span> <span class="keyword">long</span> i =<span class="number">2</span> ;i*i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="keyword">if</span>( n %i == <span class="number">0</span> )&#123;</span><br><span class="line">n/=i;</span><br><span class="line">res = res - res/i;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">while</span>( n % i==<span class="number">0</span>)</span><br><span class="line"> n/=i;</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">if</span>( n &gt; <span class="number">1</span> )</span><br><span class="line">     res = res - res/n;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += Euler(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>筛法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n, phi[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="keyword">if</span>(!phi[i]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!phi[j]) phi[j] = j;</span><br><span class="line">            phi[j] = phi[j] / i * (i<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    get_phi(n);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) ans += phi[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, ans * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>记录下欧拉函数的模板：<br>筛法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">特性 :</span></span><br><span class="line"><span class="comment">1.若a为质数,phi[a]=a-1;</span></span><br><span class="line"><span class="comment">2.若a为质数,b mod a=0,phi[a*b]=phi[b]*a</span></span><br><span class="line"><span class="comment">3.若a,b互质,phi[a*b]=phi[a]*phi[b](当a为质数时,if b mod a!=0 ,phi[a*b]=phi[a]*phi[b])</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> m[n],phi[n],p[n],nump;</span><br><span class="line"><span class="comment">//m[i]标记i是否为素数,0为素数,1不为素数;p是存放素数的数组;nump是当前素数个数;phi[i]为欧拉函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        phi[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!m[i])<span class="comment">//i为素数</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[++nump]=i;<span class="comment">//将i加入素数数组p中</span></span><br><span class="line">            phi[i]=i<span class="number">-1</span>;<span class="comment">//因为i是素数,由特性得知    </span></span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=nump&amp;&amp;p[j]*i&lt;n;j++)  <span class="comment">//用当前已的到的素数数组p筛,筛去p[j]*i</span></span><br><span class="line">        &#123;</span><br><span class="line">            m[p[j]*i]=<span class="number">1</span>;<span class="comment">//可以确定i*p[j]不是素数 </span></span><br><span class="line">            <span class="keyword">if</span> (i%p[j]==<span class="number">0</span>) <span class="comment">//看p[j]是否是i的约数,因为素数p[j],等于判断i和p[j]是否互质 </span></span><br><span class="line">            &#123;</span><br><span class="line">                phi[p[j]*i]=phi[i]*p[j]; <span class="comment">//特性2</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> phi[p[j]*i]=phi[i]*(p[j]<span class="number">-1</span>); <span class="comment">//互质,特性3其,p[j]-1就是phi[p[j]]   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公式法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eular</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">1</span>,i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            n/=i,ret*=i<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) n/=i,ret*=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) ret*=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Phi</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(N + <span class="number">0.5</span>), ans = N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">        <span class="keyword">if</span>(N % i == <span class="number">0</span>) &#123;</span><br><span class="line">            ans = ans / i * (i<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">while</span>(N % i == <span class="number">0</span>) N /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(N &gt; <span class="number">1</span>) ans = ans / N * (N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/20313&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;作为体育委员，C君负责这次运动会仪仗队的训练。 仪仗队是由学生组成的N *&lt;br&gt;N的方阵，为了保证队伍在行进中整齐划一，C君会跟在仪仗队的左后方，根据其视线所及的学生人数来判断队伍是否整齐(如下图)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409214206553.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉函数" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>子序列</title>
    <link href="http://jozky.top/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://jozky.top/2020/04/09/%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2020-04-09T14:47:11.000Z</published>
    <updated>2020-04-09T14:50:13.446Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/18203" target="_blank" rel="noopener">牛客网题目</a><br>题目描述</p><blockquote><p>给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果</p></blockquote><p>输入描述:</p><blockquote><p>第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示</p><p>接下来一行N个整数，表示给出的序列</p><p>保证序列内的数互不相同</p></blockquote><a id="more"></a><p>输出描述:</p><blockquote><p>对于每组数据，输出一个整数表示答案，对10^9^ + 7 取模 每组数据之间以换行分割</p></blockquote><p> 示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> </span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">3</span> </span><br><span class="line"><span class="number">100</span> <span class="number">1020</span> <span class="number">2050</span> <span class="number">102</span> <span class="number">12</span> <span class="number">235</span> <span class="number">4</span> <span class="number">57</span> <span class="number">32135</span> <span class="number">54354</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">144</span></span><br><span class="line"><span class="number">81000</span></span><br><span class="line"><span class="number">521918013</span></span><br></pre></td></tr></table></figure><p>说明：<br>第一组数据解释<br>所有长度为3的子序列为 (5,3,1) (5,3,4) (3,1,4) (5,1,4)<br>最终答案为3∗4∗3∗4=1443<br><img src="https://img-blog.csdnimg.cn/20200409222358794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">题解：<br>对于子序列一个数a，a会以三种形式存在<br>1.最大值<br>2.最小值<br>3.中间值<br>我们现将序列从小到大排序（从0开始），并不影响结果，但是有利于计算<br> a在长度为 k 的子序列中出现的次数为 C^k−1^<del>n−1</del>(因为如果它出现在子序列中，那么总数还有 n−1 个 数字，序列的长度还有 k−1 个)<br>对于第一种情况，a作为最大值的下表为i，a之前的i个数都比a小，所选出的子序列一定有以下标i为结尾的，我们需要从前i个中选出k-1个，组成长度为k的子序列，个数为C^k-1^<del>i</del>(组合数）<br>同理：ai 是最小值的情况的方法数为 C^k−1^<del>n−i−1</del><br>pi=C^k−1^<del>n−1</del>−C^k−1^<del>i</del>−C^k−1^<del>n−i−1</del> 对于 ai这个数来说，它对答案的贡献为 a^pi^<del>i</del><br>最终的答案为 ：ans=∏^n−1^<del>i=0</del>a^pi^<del>i</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> LL MOD = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"><span class="function">LL <span class="title">Pow</span><span class="params">(LL a, LL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans=ans*a%MOD;</span><br><span class="line">        b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        a=a*a%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL c[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="keyword">sizeof</span> c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;MAXN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            c[i][j] = (c[i<span class="number">-1</span>][j] + c[i<span class="number">-1</span>][j<span class="number">-1</span>]) % (MOD<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Init();</span><br><span class="line">    <span class="keyword">int</span> T; <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k; <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        sort(a, a+n);</span><br><span class="line">        LL tmp = c[n<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">        LL ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            LL b = tmp-c[i][k<span class="number">-1</span>]-c[n-i<span class="number">-1</span>][k<span class="number">-1</span>];</span><br><span class="line">            b = (b%(MOD<span class="number">-1</span>)+(MOD<span class="number">-1</span>))%(MOD<span class="number">-1</span>);</span><br><span class="line">            ans = ans*Pow(a[i], b)%MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为那个是指数，比如说 a^b^%p，可以用费马小定理 a^(b%(p-1))^ % p</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/18203&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网题目&lt;/a&gt;&lt;br&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个长度为n的序列，你需要计算出所有长度为k的子序列中，除最大最小数之外所有数的乘积相乘的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入描述:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第一行一个整数T，表示数据组数。 对于每组数据，第一行两个整数N，k，含义如题所示&lt;/p&gt;
&lt;p&gt;接下来一行N个整数，表示给出的序列&lt;/p&gt;
&lt;p&gt;保证序列内的数互不相同&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数" scheme="http://Jozky.top/tags/%E7%BB%84%E5%90%88%E6%95%B0/"/>
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="欧拉函数" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月8日题目精讲 黑白树</title>
    <link href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/"/>
    <id>http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/</id>
    <published>2020-04-09T10:54:52.000Z</published>
    <updated>2020-04-09T11:00:07.425Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/problem/13249" target="_blank" rel="noopener">试题链接</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld</p></blockquote><p>题目描述</p><blockquote><p>一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。<br>你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行一个整数n (1 ≤ n ≤ 10^5^) 接下来n-1行，每行一个整数，依次为2号点到n号点父亲的编号。 最后一行n个整数为k[i]<br>(1 ≤ k[i] ≤ 10^5^)</p><p>样例解释:<br> 对节点3操作，导致节点2与节点3变黑 对节点4操作，导致节点4变黑 对节点1操作，导致节点1变黑</p></blockquote><p>输出描述:</p><p>一个数表示最少操作次数</p><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>题解：<br>一开始以为是红黑树的姐妹黑白树。。<br>求出最少的操作，用dfs</p><p>我们要不断更新染色的最远距离，还要把子节点的染色范围更新的父亲节点<br>比如1-&gt;2-&gt;3-.&gt;4-&gt;5-&gt;6-&gt;7<br>f[2]=5,f[3]=2<br>2节点就可以直接染色到6<br>操作完2之后，如果3就已经被染色了，如果3能染色的范围比fa[ 2 ]-1（因为2已经染色了本身，所以减一）还大，那染色范围可以更远<br>如果fa[3]&lt;fa[2]-1，就把f3的最远距离更新到fa[2]-1<br>总结就是fa[fa]=max（ fa [ fa ] , fa [ son ] - 1 ）<br>fa=0说明这个点无法被处理到<br>因为染色都是从下向上的。如果一个节点没办法被它子树的节点染色，那这个节点的父亲节点也没办法将它染色，他只能自己染色了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100004</span>;</span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;w[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;w[x].size();j++)</span><br><span class="line">&#123;</span><br><span class="line">dfs(w[x][j]);</span><br><span class="line">fa[x]=max( fa[ w[x][j] ]<span class="number">-1</span> , fa[x] );</span><br><span class="line">a[x]=max( a[ w[x][j] ]<span class="number">-1</span> , a[x] );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum++;</span><br><span class="line">fa[x]=a[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">forr(n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">w[m].push_back(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;试题链接&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一棵n个点的有根树，1号点为根，相邻的两个节点之间的距离为1。树上每个节点i对应一个值k[i]。每个点都有一个颜色，初始的时候所有点都是白色的。&lt;br&gt;你需要通过一系列操作使得最终每个点变成黑色。每次操作需要选择一个节点i，i必须是白色的，然后i到根的链上（包括节点i与根）所有与节点i距离小于k[i]的点都会变黑，已经是黑的点保持为黑。问最少使用几次操作能把整棵树变黑。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="dfs" scheme="http://Jozky.top/tags/dfs/"/>
    
      <category term="贪心" scheme="http://Jozky.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
</feed>
