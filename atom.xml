<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jozky Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jozky.top/"/>
  <updated>2020-04-20T13:40:42.425Z</updated>
  <id>http://jozky.top/</id>
  
  <author>
    <name>Jozky</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>欧拉序与DFS序</title>
    <link href="http://jozky.top/2020/04/20/%E6%AC%A7%E6%8B%89%E5%BA%8F%E4%B8%8EDFS%E5%BA%8F/"/>
    <id>http://jozky.top/2020/04/20/%E6%AC%A7%E6%8B%89%E5%BA%8F%E4%B8%8EDFS%E5%BA%8F/</id>
    <published>2020-04-20T13:39:31.000Z</published>
    <updated>2020-04-20T13:40:42.425Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br>欧拉序与DFS序相似又不同</p><p>欧拉序的定义<br>树在dfs过程中的节点访问顺序称为欧拉序.<br>那有人会问：dfs序和欧拉序啥区别？</p><p>dfs序：是指将一棵树被dfs时所经过的节点顺序（不绕回原点）。<br>欧拉序：就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序。</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200420152716218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欧拉序与dfs序不同地方在于，欧拉序中每个节点可以出现多次，比如进入一次退出一次，又比如每次回溯时记录一次。<br> 代码：</p><p>s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</p><h2 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h2><p>核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> s[maxn], e[maxn];<span class="comment">//s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</span></span><br><span class="line"><span class="keyword">int</span> n,id,len;</span><br><span class="line"><span class="keyword">int</span> dfsxu[<span class="number">20000</span>];<span class="comment">//存放dfs序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">s[u] = ++id;</span><br><span class="line">dfsxu[++len]=u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v, u);</span><br><span class="line">&#125;</span><br><span class="line">e[u] = id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[maxn]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> s[maxn], e[maxn];<span class="comment">//s[maxn]存放“入时间戳”，e[maxn]存放“出时间戳”；</span></span><br><span class="line"><span class="keyword">int</span> n,id,len;</span><br><span class="line"><span class="keyword">int</span> dfsxu[<span class="number">20000</span>];<span class="comment">//存放dfs序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">s[u] = ++id;</span><br><span class="line">dfsxu[++len]=u;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g[u].size(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = g[u][i];</span><br><span class="line"><span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">dfs(v, u);</span><br><span class="line">&#125;</span><br><span class="line">e[u] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(e,<span class="number">0</span>,<span class="keyword">sizeof</span>(e));</span><br><span class="line">    <span class="built_in">memset</span>(dfsxu,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfsxu));</span><br><span class="line">ios::sync_with_stdio(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">g[u].push_back(v);</span><br><span class="line">g[v].push_back(u);</span><br><span class="line">&#125;</span><br><span class="line">id = <span class="number">0</span>;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"DFS序:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;s[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dfsxu[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"入时间戳:"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;s[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"出时间戳:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;e[i]!=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>核心代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">40010</span>]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> oulaxu[<span class="number">80020</span>]; <span class="comment">//存放欧拉序在，在欧拉序中第一次出现为“入时间戳”，第二次出现为“出时间戳”。</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">    <span class="keyword">int</span> sz=g[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">            dfs(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">40010</span>]; <span class="comment">//存放节点</span></span><br><span class="line"><span class="keyword">int</span> oulaxu[<span class="number">80020</span>]; <span class="comment">//存放欧拉序在，在欧拉序中第一次出现为“入时间戳”，第二次出现为“出时间戳”。</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">    <span class="keyword">int</span> sz=g[u].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;sz; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">            dfs(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    oulaxu[++len]=u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(oulaxu,<span class="number">0</span>,<span class="keyword">sizeof</span>(oulaxu));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            g[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> from,to;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;from,&amp;to);</span><br><span class="line">            g[from].push_back(to);</span><br><span class="line">            g[to].push_back(from);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,oulaxu[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;欧拉序与DFS序相似又不同&lt;/p&gt;
&lt;p&gt;欧拉序的定义&lt;br&gt;树在dfs过程中的节点访问顺序称为欧拉序.&lt;br&gt;那有人会问：dfs序和欧拉序啥区别？&lt;/p&gt;
&lt;p&gt;dfs序：是指将一棵树被dfs时所经过的节点顺序（不绕回原点）。&lt;br&gt;欧拉序：就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="DFS序" scheme="http://Jozky.top/tags/DFS%E5%BA%8F/"/>
    
      <category term="欧拉序" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>LCA总结</title>
    <link href="http://jozky.top/2020/04/20/LCA%E6%80%BB%E7%BB%93/"/>
    <id>http://jozky.top/2020/04/20/LCA%E6%80%BB%E7%BB%93/</id>
    <published>2020-04-20T08:29:05.000Z</published>
    <updated>2020-04-20T08:32:53.545Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><strong>我们通过这个题<a href="https://www.luogu.com.cn/problem/P3379" target="_blank" rel="noopener">洛谷P3379 【模板】最近公共祖先来讲LCA</a></strong></p><h2 id="LCA介绍"><a href="#LCA介绍" class="headerlink" title="LCA介绍"></a>LCA介绍</h2><p>lca是啥？最近公共祖先<br>就是：两个点在这棵树上距离最近的公共祖先节点<br>LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）<br>来看一个经典图<br><img src="https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a><p>LCA（4,5）=2<br>LCA（4,3）=1<br>LCA（2,1）=1</p><h2 id="解决方法概括："><a href="#解决方法概括：" class="headerlink" title="解决方法概括："></a>解决方法概括：</h2><p>常用四种方法 ：</p><ol><li>用倍增法求解，预处理复杂度是 O(nlogn) ,每次询问的复杂度是 O(logn), 属于在线解法。</li><li>利用欧拉序转化为RMQ问题，用ST表求解RMQ问题，预处理复杂度 O(n+nlogn)，每次询问的复杂度为 O(1)，也是在线算法。</li><li>采用Tarjan算法求解，复杂度 O(α(n)+Q)，属于离线算法。</li><li>利用树链剖分求解，复杂度预处理O(n)，单次查询 O(logn) ，属于在线算法。</li></ol><h2 id="倍增法："><a href="#倍增法：" class="headerlink" title="倍增法："></a>倍增法：</h2><p>倍增：将两个点调到一个高度之后不断同时向上调到两点重合，即为两点的最近公共祖先<br>所用到的函数： grand[x][i] ,这个数组表示标号为x节点向上跳2^i步的节点<br>例如grand[5][0]=2（上图）, 节点5向上跳2^0^次（1次）到达节点2<br>grand[5][0]就是x的父节点<br>grand[x][1]就是x的父亲节点的父亲节点,就是grand[grand[x][0]][0]<br>这样就能得到一个递推式grand [ x ] [ i ] = grand [ grand [ x ] [ i-1 ] ] [ i-1 ]<br>先让x与y处于同一层，然后一起往上跳<br>跳多少呢？<br>比如dep[u]&gt;dep[v]<br>u要向上爬h=dep[u]-dep[v]，才能和v相同深度<br>将h进行二进制拆分，比如<br>h=(15)<del>10</del>=(1111)<del>2</del><br>h=(5)<del>10</del>=(101)<del>2</del><br>从低位开始i=0，如果是这一位是1，就grand[u][i]<br>任何调动次数都可以用2的指数幂之和来表示O（log n）<br>h = 5 = 2^2^ + 2^0^<br>h = 15 = 2^3^ + 2^2^ + 2^1^ + 2^0^<br>dep[]表示节点的深度<br>一开始跳log<del>2</del>^dep[x]-dep[y]^，log我们可以打表预处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>当两点汇合时，就可以返回了<br>查询m组，总的复杂度应该是O(m log n)<br>输入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">6</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">8</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">3</span>) + (x &lt;&lt; <span class="number">1</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, nxt;</span><br><span class="line">edge() &#123;&#125;</span><br><span class="line">edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn) &#123;to = tt, nxt = nn;&#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[maxn], k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">e[k] = edge(v, head[u]);</span><br><span class="line">head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn][<span class="number">25</span>], dep[maxn], lg[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fath)</span><span class="comment">//初始化深度及祖祖辈辈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dep[now] = dep[fath] + <span class="number">1</span>;</span><br><span class="line">fa[now][<span class="number">0</span>] = fath;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= dep[now]; i++)</span><br><span class="line">fa[now][i] = fa[fa[now][i - <span class="number">1</span>]][i - <span class="number">1</span>];<span class="comment">//前文的递推式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = head[now]; ~i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span>(e[i].to != fath) dfs(e[i].to, now);<span class="comment">//继续往下遍历</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[x] &lt; dep[y]) swap(x, y);<span class="comment">//保证x的深度更大，跳x</span></span><br><span class="line"><span class="keyword">while</span>(dep[x] &gt; dep[y]) x = fa[x][lg[dep[x] - dep[y]]];</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">return</span> x;<span class="comment">//特判</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = lg[dep[x]]; i &gt;= <span class="number">0</span>; i--)<span class="comment">//倍增一起往上跳</span></span><br><span class="line"><span class="keyword">if</span>(fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">n = read(), m = read(), root = read();</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">u = read(), v = read();</span><br><span class="line">add(u, v);</span><br><span class="line">add(v, u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dfs(root, <span class="number">0</span>);</span><br><span class="line">lg[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line"><span class="comment">//lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);//log打表，后面那一坨是特判一下i是否进位了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">&#123;</span><br><span class="line">u = read(), v = read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Tarjan"><a href="#Tarjan" class="headerlink" title="Tarjan"></a>Tarjan</h2><p>倍增是在线算法<br>Tarjan是离线算法<br><img src="https://img-blog.csdnimg.cn/20200413143549700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Tarjan主要用到和并查集差不多的方法<br>比如查询7和5<br>我们从根节点出发，1-&gt;2-&gt;4-&gt;7，发现另一点5还没被查询，然后回溯，再遍历，7-&gt;4-&gt;8-&gt;4-&gt;2-&gt;5,遍历到点5，我们发现另外一个点7已经访问过，就到此结束。在这过程中我们用fa[]来表示父节点，就和并查集一样，回溯时，7-&gt;4 , fa[7]=4 ；8-&gt;4 , fa[8]=4； 4-&gt;2,fa[4]=2； 5-&gt;2,fa[5]=2。<br>这样当发现另外一个点已经标记了，那么这个点的祖先一定是两个点的lca（可以通过路径压缩）<br>在访问一个点时，我们会将与这点相关的一同询问，所以tarjan是强制离线<br>lca用于存结果，每个询问都存了两次（因为还要查询另外一个点是否已经访问过），最后输出时 i * 2<br>每组答案lca[i*2]（i-&gt;m）<br>大概时间复杂度为O(n+m）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root, lca[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn) &#123;to = tt, nxt = nn;&#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>], qe[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> head[maxn], k = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[k] = edge(v, head[u]);</span><br><span class="line">    head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> qhead[maxn], qk = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qadd</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qe[qk] = edge(v, qhead[u]);</span><br><span class="line">    qhead[u] = qk++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x? x : fa[x] = get(fa[x]);&#125;<span class="comment">//记得路径压缩！！</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> v;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)<span class="comment">//先深优遍历下去</span></span><br><span class="line">    &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;<span class="comment">//vis过了，就说明是父亲</span></span><br><span class="line">        tarjan(v);</span><br><span class="line">        fa[v] = u;<span class="comment">//回溯时记录</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = qhead[u]; ~i; i = qe[i].nxt)<span class="comment">//开始扫一遍关于u的所有询问</span></span><br><span class="line">    &#123;</span><br><span class="line">        v = qe[i].to;</span><br><span class="line">        <span class="keyword">if</span>(vis[v])<span class="comment">//另一个点访问过了，可以得出答案了</span></span><br><span class="line">        &#123;</span><br><span class="line">            lca[i] = get(v);</span><br><span class="line">            <span class="keyword">if</span>(i &amp; <span class="number">1</span>) lca[i - <span class="number">1</span>] = lca[i];<span class="comment">//这里特殊处理是因为每个询问存了两次</span></span><br><span class="line">            <span class="keyword">else</span> lca[i + <span class="number">1</span>] = lca[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    <span class="built_in">memset</span>(qhead, <span class="number">-1</span>, <span class="keyword">sizeof</span> qhead);</span><br><span class="line">    n = read(), m = read(), root = read();</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">        fa[i] = i;<span class="comment">//顺便初始化fa</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fa[n] = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();<span class="comment">//存储询问</span></span><br><span class="line">        qadd(u, v);</span><br><span class="line">        qadd(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tarjan(root);<span class="comment">//开始遍历</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lca[i &lt;&lt; <span class="number">1</span>]);<span class="comment">//每个询问都存了两次，所以要*2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>m较小时用倍增，较大时用Tarjan</strong></p><h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>欧拉序的定义<br>树在dfs过程中的节点访问顺序称为欧拉序.<br>那有人会问：dfs序和欧拉序啥区别？</p><p>dfs序：是指将一棵树被dfs时所经过的节点顺序（不绕回原点）。<br>欧拉序：就是从根结点出发，按dfs的顺序在绕回原点所经过所有点的顺序。</p><p><img src="https://img-blog.csdnimg.cn/20200420152716218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>欧拉序与dfs序不同地方在于，欧拉序中每个节点可以出现多次，比如进入一次退出一次，又比如每次回溯时记录一次。</p><p>因此两个点的LCA，就是在该序列上两个点第一次出现的区间内深度最小的那个点<br>比如求D和E的LCA，D和E第一次出现的区间是DDCBE。这里面深度最小的就是点B，所以LCA（D，E）=B<br>这样就转化为区间RMQ问题，所以可以用ST表。<br>具体怎么做呢？<br>先求出欧拉序和每个节点的深度，同时用start[]记录每个节点第一次出现的位置<br>LCA ( T , u , v ) = RMQ ( B , start ( u ) , start ( v ) )<br> 然后直接用ST表求RMQ就行<br> <a href="https://editor.csdn.net/md/?articleId=105636769" target="_blank" rel="noopener">ST表详解</a> </p><p> 所用到数组：</p><blockquote><p> a.欧拉序：图的遍历（几种存储结构写法不太一样）</p><p>cnt:序列长度（每个元素一进一出共两次，记得最大初始化为2*MAXN）<br>oula[]:欧拉序列，记录编号   dfs前记录一次，dfs后（回溯）再记录一次<br>depth[]:每个编号的深度（也可以记录每个下标的深度，见注释）</p><p>start[]:每个编号第一次出现的序列下标</p><p>b.ST表  </p><p>minl[i][j]    记得第一层初始化为depth[]</p><p>pos[][]最值下标，第一层初始化为i</p><p>注意这里i是欧拉序列的下标，最终要的是编号（这里经常下标搞混！！）</p><p>欧拉序列下标=start【编号】</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 500010  </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;G[N]; </span><br><span class="line"><span class="keyword">int</span> oula[N&lt;&lt;<span class="number">1</span>],depth[N],start[N];<span class="comment">//N*2</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> minl[N&lt;&lt;<span class="number">1</span>][<span class="number">19</span>],pos[N&lt;&lt;<span class="number">1</span>][<span class="number">19</span>],len[N&lt;&lt;<span class="number">1</span>],vis[N],tmp; <span class="comment">//开20以上就TLE，自闭</span></span><br><span class="line"><span class="comment">//struct node&#123;int deep,order;&#125;minl[N][19];</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,m,s,x,y;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch=<span class="string">'*'</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch=getchar()));</span><br><span class="line">    <span class="keyword">int</span> num=ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch=getchar()))num=num*<span class="number">10</span>+ch-<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> fa,<span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">    oula[++cnt]=now;<span class="comment">//入 </span></span><br><span class="line">    <span class="comment">//depth[cnt]=deep;</span></span><br><span class="line">    <span class="keyword">if</span>(depth[now]==<span class="number">0</span>)depth[now]=deep;</span><br><span class="line">    <span class="keyword">if</span>(start[now]==<span class="number">0</span>)start[now]=cnt;</span><br><span class="line">    <span class="keyword">int</span> z=G[now].size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;z;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(G[now][i]!=fa)&#123;</span><br><span class="line">            dfs(G[now][i],now,deep+<span class="number">1</span>);</span><br><span class="line">            oula[++cnt]=now;<span class="comment">//出 </span></span><br><span class="line">            <span class="comment">//depth[cnt]=deep;</span></span><br><span class="line">            <span class="comment">//index[now]=cnt;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">S_table</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">2</span>*N;++i) len[i]=(<span class="number">1</span>&lt;&lt;(tmp+<span class="number">1</span>))==i?++tmp:tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) minl[i][<span class="number">0</span>]= depth[oula[i]],pos[i][<span class="number">0</span>]=i;<span class="comment">//depth[i]</span></span><br><span class="line">    <span class="comment">//int l = log2((double)cnt);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;j)&lt;=cnt;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) ) - <span class="number">1</span> &lt;=cnt;++i)&#123;</span><br><span class="line">            <span class="comment">//minl[i][j] = min(minl[i][j-1], minl[i + (1 &lt;&lt; (j-1) )][j-1]);</span></span><br><span class="line">          <span class="keyword">if</span>(minl[i][j<span class="number">-1</span>]&lt;minl[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>])minl[i][j]=minl[i][j<span class="number">-1</span>],pos[i][j]=pos[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">else</span> minl[i][j]=minl[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) )][j<span class="number">-1</span>],pos[i][j]=pos[i + (<span class="number">1</span> &lt;&lt; (j<span class="number">-1</span>) )][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rmq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) swap(l,r);</span><br><span class="line">    <span class="keyword">int</span> k=len[r-l+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//int k = log2((double)(r-l+1));</span></span><br><span class="line">    <span class="keyword">int</span> mid=r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(minl[l][k]&lt;=minl[mid][k])<span class="keyword">return</span> pos[l][k];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> pos[mid][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read();m=read();s=read(); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">      x=read();y=read();</span><br><span class="line">      G[x].push_back(y);</span><br><span class="line">      G[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dfs(s,<span class="number">-1</span>,<span class="number">1</span>);<span class="comment">//求欧拉序列</span></span><br><span class="line">    S_table();<span class="comment">//初始化st表</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        x=read();y=read();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,oula[rmq(start[x],start[y])]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树剖解法："><a href="#树剖解法：" class="headerlink" title="树剖解法："></a>树剖解法：</h2><p>树剖比Tarjan慢，但比倍增快</p><p>树剖详讲</p><p>树剖是把一棵树按子树大小分为链。树剖基本操作中有一个是求x到y的路径的边权和，或者是所有边权进行修改。我们可以用树剖的思路来写LCA。直接看点x和y是否在一条链上，不在则深度较大者跳到链头的父亲节点处，也就是跳出这条链；在则深度较浅者为LCA。<br>树剖一跳就是一条链，对于n极大的情况就相当于是倍增的再一优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;//都是树剖模板操作，就不做多解释了。</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 500005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, root;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="string">'0'</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, nxt;</span><br><span class="line">    edge()&#123;&#125;</span><br><span class="line">    edge(<span class="keyword">int</span> tt, <span class="keyword">int</span> nn)</span><br><span class="line">    &#123;</span><br><span class="line">        to = tt, nxt = nn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, head[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[k] = edge(v, head[u]);</span><br><span class="line">    head[u] = k++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fa[maxn], dep[maxn], size[maxn], son[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_getson</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">        dep[v] = dep[u] + <span class="number">1</span>;</span><br><span class="line">        fa[v] = u;</span><br><span class="line">        dfs_getson(v);</span><br><span class="line">        size[u] += size[v];</span><br><span class="line">        <span class="keyword">if</span>(size[v] &gt; size[son[u]]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> top[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs_rewrite</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = tp;</span><br><span class="line">    <span class="keyword">if</span>(son[u]) dfs_rewrite(son[u], tp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nxt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(v != fa[u] &amp;&amp; v != son[u]) dfs_rewrite(v, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x] != top[y])<span class="comment">//不同则跳</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]] &gt; dep[top[y]]) swap(x, y);</span><br><span class="line">        y = fa[top[y]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);<span class="comment">//输出深度较小者</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">    n = read(), m = read(), root = read();</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u = read(), v = read();</span><br><span class="line">        add(u, v);</span><br><span class="line">        add(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//树剖初始化</span></span><br><span class="line">    dfs_getson(root);</span><br><span class="line">    dfs_rewrite(root, root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    u = read(), v = read();</span><br><span class="line">        ask(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;strong&gt;我们通过这个题&lt;a href=&quot;https://www.luogu.com.cn/problem/P3379&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;洛谷P3379 【模板】最近公共祖先来讲LCA&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;LCA介绍&quot;&gt;&lt;a href=&quot;#LCA介绍&quot; class=&quot;headerlink&quot; title=&quot;LCA介绍&quot;&gt;&lt;/a&gt;LCA介绍&lt;/h2&gt;&lt;p&gt;lca是啥？最近公共祖先&lt;br&gt;就是：两个点在这棵树上距离最近的公共祖先节点&lt;br&gt;LCA（x，y）=z，z是x与y的最近公共祖先，（换句话说z的深度要尽可能大）&lt;br&gt;来看一个经典图&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200411230206669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="LCA" scheme="http://Jozky.top/tags/LCA/"/>
    
      <category term="倍增" scheme="http://Jozky.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="欧拉序" scheme="http://Jozky.top/tags/%E6%AC%A7%E6%8B%89%E5%BA%8F/"/>
    
      <category term="ST表" scheme="http://Jozky.top/tags/ST%E8%A1%A8/"/>
    
      <category term="Tarjan" scheme="http://Jozky.top/tags/Tarjan/"/>
    
      <category term="树链剖分" scheme="http://Jozky.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>ST表讲解</title>
    <link href="http://jozky.top/2020/04/20/ST%E8%A1%A8%E8%AE%B2%E8%A7%A3/"/>
    <id>http://jozky.top/2020/04/20/ST%E8%A1%A8%E8%AE%B2%E8%A7%A3/</id>
    <published>2020-04-20T08:28:45.000Z</published>
    <updated>2020-04-20T08:30:17.323Z</updated>
    
    <content type="html"><![CDATA[<p>ST表主要用于解决RMQ问题（区间最值问题）<br>当然你可以用线段树等，但今天用一种ST表（倍增算法）</p><p>ST表是倍增算法的一个典型应用<br>暴力做RMQ问题，往往会超时，ST表利用对其进行优化</p><a id="more"></a><p>给定一段序列A，ST算法能在O(NlogN)的时间预处理后，以O(1) 的复杂度查询，在线回答在一段区间l,r 中最大（小）值是多少。</p><p>f[i][j]用于表示在序列a中， 从第i位数字往后数2^j^个数，这个区间内的最大值，即区间[ i , i + 2 ^j^  ]内取得的最大值。</p><p>而这段区域的最大值等于左右子区间的最大值,2^j^ = 2 * 2 ^j-1^ = 2^j-1^ + 2^j-1^,把区间[i,i+2^j^]分成[i , i + 2^j-1^ ] [ i + 2^j-1^ + 1,2^j^]<br>(即f [ i ] [  j - 1 ] 与 f [ i + 2 ^j-1^ - 1 ] [ j -1 ]  ）</p><p>我们可得：F [ i ] [ j ] = max ( F [ i ] [ j - 1 ] , F [ i + 2 ^j-1^ - 1 ] [ j - 1 ] )<br>递推边界为f[i][0]=a[i]</p><p>其实说白了就是：相求大区间就先求出小区间，求小区间就求小小区间，一直这样套娃到最低层。</p><p>但是我们查询的区间不一定总是2的倍数，也有可能会超出区间<br>所以我们询问区间[l,r]时要用一个k，k=log<del>2</del>(len)，len为区间的长度，k向下取整<br>len=r-l+1<br>2^t^&lt;len&lt;2^t+1^<br>左右区间最大值分别是F [ l , k ] 与F [ r - 2^k^ + 1 , k ]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> f[<span class="number">100001</span>][<span class="number">40</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ST</span><span class="params">()</span><span class="comment">//预处理</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=(<span class="keyword">int</span>)log2(n);k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            f[i][k]=max(f[i][k<span class="number">-1</span>],f[i+(<span class="number">1</span>&lt;&lt;(k<span class="number">-1</span>))][k<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span><span class="comment">//查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k=log2(r-l+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max(f[l][k],f[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        </span><br><span class="line">        f[i][<span class="number">0</span>]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;l,&amp;r);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;query(l,r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ST表主要用于解决RMQ问题（区间最值问题）&lt;br&gt;当然你可以用线段树等，但今天用一种ST表（倍增算法）&lt;/p&gt;
&lt;p&gt;ST表是倍增算法的一个典型应用&lt;br&gt;暴力做RMQ问题，往往会超时，ST表利用对其进行优化&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法讲解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/"/>
    
    
      <category term="倍增" scheme="http://Jozky.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="ST表" scheme="http://Jozky.top/tags/ST%E8%A1%A8/"/>
    
      <category term="RMQ" scheme="http://Jozky.top/tags/RMQ/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树(模板)</title>
    <link href="http://jozky.top/2020/04/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/"/>
    <id>http://jozky.top/2020/04/19/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-04-19T15:38:24.000Z</published>
    <updated>2020-04-19T15:39:16.607Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br>昨天做蓝桥杯的题，最后一题最小生成树，但好久没用一下子生疏了。。。<br>最小生成树两种方法：<br>Prim和Kruskal</p><h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2><p>prim:该算法的时间复杂度为O(n2)。与图中边数无关，该算法适合于稠密图。</p><p>kruskal:需要对图的边进行访问，所以克鲁斯卡尔算法的时间复杂度只和边又关系，可以证明其时间复杂度为O（eloge）。适合稀疏图。</p><a id="more"></a><p> <strong>模板：</strong></p><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,i,j,u,v,total;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start,to;<span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">&#125;bian[<span class="number">2000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//并查集部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[x]==x) <span class="keyword">return</span> x; </span><br><span class="line"><span class="keyword">else</span>  <span class="keyword">return</span> find(f[x]);</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(edge a,edge b)</span><span class="comment">//结构体快排时用到的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span><span class="comment">//最小生成树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u=find(bian[i].start);</span><br><span class="line">        v=find(bian[i].to);</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">continue</span>;<span class="comment">//判断在不在同一个并查集里面，在就下一个循环</span></span><br><span class="line">            ans+=bian[i].val;<span class="comment">//不在，就加上</span></span><br><span class="line">            f[u]=v;<span class="comment">//连接两个并查集</span></span><br><span class="line">            total++;</span><br><span class="line">            <span class="keyword">if</span>(total==n<span class="number">-1</span>) <span class="keyword">break</span>;<span class="comment">//当形成了最小生成树后，退出（之后做的也没用了）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;bian[i].start,&amp;bian[i].to,&amp;bian[i].val);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(bian+<span class="number">1</span>,bian+m+<span class="number">1</span>,cmp);<span class="comment">//快排边长</span></span><br><span class="line">    kruskal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;<span class="comment">//快读，不理解的同学用cin代替即可</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 123456789</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w,next;</span><br><span class="line">&#125;e[maxm&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//注意是无向图，开两倍数组</span></span><br><span class="line"><span class="keyword">int</span> head[maxn],dis[maxn],cnt,n,m,tot,now=<span class="number">1</span>,ans;</span><br><span class="line"><span class="comment">//已经加入最小生成树的的点到没有加入的点的最短距离，比如说1和2号节点已经加入了最小生成树，那么dis[3]就等于min(1-&gt;3,2-&gt;3)</span></span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="comment">//链式前向星加边</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++cnt].v=v;</span><br><span class="line">    e[cnt].w=w;</span><br><span class="line">    e[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n=read(),m=read();</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,u,v,w;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        u=read(),v=read(),w=read();</span><br><span class="line">        add(u,v,w),add(v,u,w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先把dis数组附为极大值</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[i]=inf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里要注意重边，所以要用到min</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[<span class="number">1</span>];i;i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[e[i].v]=min(dis[e[i].v],e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(++tot&lt;n)<span class="comment">//最小生成树边数等于点数-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        re <span class="keyword">int</span> minn=inf;<span class="comment">//把minn置为极大值</span></span><br><span class="line">        vis[now]=<span class="number">1</span>;<span class="comment">//标记点已经走过</span></span><br><span class="line">        <span class="comment">//枚举每一个没有使用的点</span></span><br><span class="line">        <span class="comment">//找出最小值作为新边</span></span><br><span class="line">        <span class="comment">//注意这里不是枚举now点的所有连边，而是1~n</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i]&amp;&amp;minn&gt;dis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                minn=dis[i];</span><br><span class="line">                now=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans+=minn;</span><br><span class="line">        <span class="comment">//枚举now的所有连边，更新dis数组</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=head[now];i;i=e[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            re <span class="keyword">int</span> v=e[i].v;</span><br><span class="line">            <span class="keyword">if</span>(dis[v]&gt;e[i].w&amp;&amp;!vis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=e[i].w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,prim());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;昨天做蓝桥杯的题，最后一题最小生成树，但好久没用一下子生疏了。。。&lt;br&gt;最小生成树两种方法：&lt;br&gt;Prim和Kruskal&lt;/p&gt;
&lt;h2 id=&quot;关于时间复杂度：&quot;&gt;&lt;a href=&quot;#关于时间复杂度：&quot; class=&quot;headerlink&quot; title=&quot;关于时间复杂度：&quot;&gt;&lt;/a&gt;关于时间复杂度：&lt;/h2&gt;&lt;p&gt;prim:该算法的时间复杂度为O(n2)。与图中边数无关，该算法适合于稠密图。&lt;/p&gt;
&lt;p&gt;kruskal:需要对图的边进行访问，所以克鲁斯卡尔算法的时间复杂度只和边又关系，可以证明其时间复杂度为O（eloge）。适合稀疏图。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法模板" scheme="http://Jozky.top/categories/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
    
      <category term="最小生成树" scheme="http://Jozky.top/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月16日 逆序对</title>
    <link href="http://jozky.top/2020/04/19/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8816%E6%97%A5-%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <id>http://jozky.top/2020/04/19/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8816%E6%97%A5-%E9%80%86%E5%BA%8F%E5%AF%B9/</id>
    <published>2020-04-19T03:43:11.000Z</published>
    <updated>2020-04-19T03:45:06.629Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14731" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>求所有长度为n的01串中满足如下条件的二元组个数： 设第i位和第j位分别位ai和aj（i&lt;j），则ai=1,aj=0。<br>答案对1e9+7取模。</p></blockquote><a id="more"></a><p>输入描述:<br>输入一个n。<br>输出描述:<br>输出答案对1e9+7取模<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>说明<br><img src="https://img-blog.csdnimg.cn/2020041911312348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注:<br> n &lt;= 10^18^</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>就是一个求逆序对<br>我们看如果1后面有5个0，就能构成5个逆序对<br>也就是我们考虑任意两个位置，只要前面是1，后面是0，无论其他位置是什么数，都能构成一个逆序对。而这样的情况有多少种，就说明有多少逆序对<br>接下来我们就要用到组合排列<br>在n个位置任选两个位置的方案数C^2^<del>n</del> ,<br>其他n-2个位置就是放0和1，随便放，那就是n-2个2相乘，就是2^n-2^,所以总逆序对是C^2^<del>n*</del> 2^n-2^</p><p>C^2^<del>n*</del> 2^n-2^=n<em>(n-1)/2 *2^n-2^= n *(n-1)</em>2^n-3^</p><p>因为n可以很大，所以要用到快速幂<br>n=1要特判一下<br>我提交后一直卡在95%，原来当n=2时程序就死循环了，所以n=2也要特判</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">poww</span><span class="params">(ll a,ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll sum=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>)sum=sum*a%mod;</span><br><span class="line">a=a*a%mod;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ll n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;( ( ( n%mod )* ( ( n<span class="number">-1</span> ) % mod ) %mod )*(poww(<span class="number">2l</span>l,n<span class="number">-3</span>)%mod))%mod&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14731&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;求所有长度为n的01串中满足如下条件的二元组个数： 设第i位和第j位分别位ai和aj（i&amp;lt;j），则ai=1,aj=0。&lt;br&gt;答案对1e9+7取模。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="逆序对" scheme="http://Jozky.top/tags/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    
      <category term="排列组合" scheme="http://Jozky.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
      <category term="快速幂" scheme="http://Jozky.top/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>牛客网 【每日一题】4月15日 Treepath</title>
    <link href="http://jozky.top/2020/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8815%E6%97%A5-Treepath/"/>
    <id>http://jozky.top/2020/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8815%E6%97%A5-Treepath/</id>
    <published>2020-04-17T15:04:09.000Z</published>
    <updated>2020-04-17T15:04:58.728Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14248" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定一棵n个点的树，问其中有多少条长度为偶数的路径。路径的长度为经过的边的条数。x到y与y到x被视为同一条路径。路径的起点与终点不能相同。</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>第一行一个数n表示点的个数； 接下来n-1行，每行两个整数x，y表示边； 保证输入数据形成一棵树； 1&lt;=n&lt;=100000</p></blockquote><p>输出描述:</p><blockquote><p>一行一个整数表示答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>求长度为偶数的路径<br>偶数层的点到偶数层的点长度是偶数<br>奇数层到奇数层的点的路径长度也是偶数<br>奇数层的点到偶数层的点路径长度就算奇数<br>所以需要统计多少个奇数层多少点偶数层多少点<br>我们发现如果层数奇偶性一样，路径长度就是偶数<br>为什么呢？引用邓老师的讲解</p><blockquote><p>我们可以考虑先让两个点里深度深的那个往上走，走到和另外一个点一样的高度，这个显然是偶数步完成的，之后两个点一起往上走直到汇合，走到步数是一样的，所以最终加起来也是偶数。</p></blockquote><p>然后我们会用到数组dp[][]<br>dp[i][0/1]表示以i为根的子树，与根节点i的距离<br>因为距离长度只有偶数奇数两种情况，所以我们把偶数设为0，奇数设为1，这样好统计<br>u是v的父亲，<br>也就是一个来自v的子树的点，到u点的路径会比到v的路径长度 长1<br>这样我们有：<br>dp[u][0]+=dp[v][1]<br>以u为根的子树，与u的距离长度为偶数的情况一个本身，另一个来自dp[v][i].因为以v为根节点，与v的距离为奇数，那到u的距离就要加1，也就是偶数<br>dp[u][1]+=dp[v][0]<br>同理</p><p>sum + = dp [ u ] [ 0 ] * dp [ v ] [ 1 ] + dp [ u] [ 1 ] * dp [ v ] [ 0 ]<br>已有dp[u][0]条以u为端点长度为偶数的路径，与dp[v][1]条以v为端点长度为奇数的路径合并可以得到 dp [ u ] [ 0 ] * dp [ v ] [ 1 ]   条长度为偶数的路径<br>同理dp[u][i]*dp[v][0]也是一样</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">ll dp[maxn][<span class="number">3</span>];</span><br><span class="line">ll sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dp[u][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> v : edge[u]) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">dfs(v,u);</span><br><span class="line"></span><br><span class="line">sum+=dp[u][<span class="number">0</span>]*dp[v][<span class="number">1</span>]+dp[u][<span class="number">1</span>]*dp[v][<span class="number">0</span>];</span><br><span class="line">dp[u][<span class="number">0</span>]+=dp[v][<span class="number">1</span>];</span><br><span class="line">dp[u][<span class="number">1</span>]+=dp[v][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">edge[a].push_back(b);</span><br><span class="line">edge[b].push_back(a);</span><br><span class="line">&#125;</span><br><span class="line">dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14248&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一棵n个点的树，问其中有多少条长度为偶数的路径。路径的长度为经过的边的条数。x到y与y到x被视为同一条路径。路径的起点与终点不能相同。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>水题(water)（非详细解答）</title>
    <link href="http://jozky.top/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/"/>
    <id>http://jozky.top/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/</id>
    <published>2020-04-17T12:37:45.000Z</published>
    <updated>2020-04-17T12:40:35.718Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5203/E" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K<br>64bit IO Format: %lld</p></blockquote><p>题目描述<br><img src="https://img-blog.csdnimg.cn/20200417185530435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><a id="more"></a> <blockquote><p>其中，f(1)=1;f(2)=1;Z皇后的方案数：即在Z×Z的棋盘上放置Z个皇后，使其互不攻击的方案数。</p></blockquote><p>输入描述:</p><blockquote><p>输入数据共一行，两个正整数x,m，意义如“题目描述”。</p></blockquote><p>输出描述:</p><blockquote><p>一个正整数k，表示输出结尾0 的个数或者放置皇后的方案数</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">375</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14200</span></span><br></pre></td></tr></table></figure><p>说明<br><img src="https://img-blog.csdnimg.cn/20200417185538216.png" alt="在这里插入图片描述"><br>题解：<br>看了一阵子没明白，也是从其他人那学完之后，自己总结着再写<br>这个题内含三个小题：<br>1.判断是否存在k使得f(k)=xf(k)=x<br>2.n!在m进制下末尾零的个数<br>3.Z皇后方案数<br>解答：（非详细）<br>1.F函数其实就是斐波那契数列</p><p>斐波那契数列平方和的性质：（就是题目中所给公式）<br><img src="https://img-blog.csdnimg.cn/20200417185913695.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fi[<span class="number">1</span>] = <span class="number">1</span>, fi[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>;; ++i) &#123;</span><br><span class="line">    fi[i] = fi[i - <span class="number">1</span>] + fi[i - <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">if</span> (fi[i] &gt; <span class="number">1e18</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.求n!在m进制的末尾0个数</p><p>首先一个结论：n!的质因子p的个数等于：1~n中p的倍数(n/p)加上(n/p)!中质因子p的个数</p><p>然后：<br>写出<br>将数W转化成m进制的末尾0的个数<br>的暴力代码是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(W%m==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">tot++;</span><br><span class="line">W/m;</span><br><span class="line">&#125;<span class="comment">//tot计数</span></span><br></pre></td></tr></table></figure><p>可以得到 W=a * m^tot^（n是m^tot^的倍数）</p><p>末尾几个0，tot就是几（tot是记录末尾0<br>的数量）</p><p>我们看 n ! 最多可以分解出多少个m<br>质因数 pi<br>设m=p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^<br>W = n!<br> n！= a  *  m ^tot^<br>n！=a * （p<del>1</del>^a1^ <em>p<del>2</del>^a2^ *….</em>p<del>k</del>^ak^）^tot^</p><p>n!=a * p<del>1</del>^b1^ <em>p<del>2</del>^b2^ *….</em>p<del>k</del>^bk^</p><p>b<del>k</del>=a<del>k</del> *tot</p><p>求出！x最多可以分解出多少个p<del>i</del></p><p>tot=min(b<del>k</del>/a<del>k</del>)<br>枚举k</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ll prime[maxn] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">getsum</span><span class="params">(ll n,ll m)</span></span>&#123;</span><br><span class="line">    ll sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+=n/m;</span><br><span class="line">        n/=m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;<span class="comment">//n!的质因子p的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ans_solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">ll ans=<span class="number">1e18</span>+<span class="number">3</span>;</span><br><span class="line">M=m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; prime[i] &lt;= M; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (M % prime[i] == <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">++ans1[prime[i]];</span><br><span class="line">M /= prime[i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">&#123;</span><br><span class="line">            ans2[prime[i]]=getsum(x,prime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">25</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans1[prime[i]])</span><br><span class="line">        ans=min(ans,ans2[prime[i]]/ans1[prime[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.求z皇后方案数<br>z=x%min(13,m)+1<br>根据式子就能得到z的范围在1~13，范围不大直接打表就可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">dabiao</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  z[<span class="number">1</span>]=<span class="number">1</span>;z[<span class="number">2</span>]=<span class="number">0</span>;z[<span class="number">3</span>]=<span class="number">0</span>;z[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">      z[<span class="number">5</span>]=<span class="number">10</span>;z[<span class="number">6</span>]=<span class="number">4</span>;z[<span class="number">7</span>]=<span class="number">40</span>;z[<span class="number">8</span>]=<span class="number">92</span>;</span><br><span class="line">      z[<span class="number">9</span>]=<span class="number">352</span>;z[<span class="number">10</span>]=<span class="number">724</span>;z[<span class="number">11</span>]=<span class="number">2680</span>;</span><br><span class="line">  z[<span class="number">12</span>]=<span class="number">14200</span>;z[<span class="number">13</span>]=<span class="number">73712</span>;</span><br><span class="line"> </span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; z[x%min(<span class="number">13</span>*<span class="number">1l</span>l,k)+<span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200417185530435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>小H和游戏</title>
    <link href="http://jozky.top/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/"/>
    <id>http://jozky.top/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/</id>
    <published>2020-04-17T12:37:31.000Z</published>
    <updated>2020-04-17T12:40:38.906Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/D" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit<br>IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><pre><code>小H正在玩一个战略类游戏，她可以操纵己方的飞机对敌国的N座城市(编号为1~N)进行轰炸敌国的城市形成了一棵树，小H会依次进行Q次轰炸，每次会选择一个城市A进行轰炸，和这座城市距离不超过2的城市都会受损(这里距离的定义是两点最短路径上的边数)，轰炸结束后，小H还想知道当前城市A受损的次数作为游戏的开发者之一，你有义务回答小H的问题 </code></pre></blockquote><a id="more"></a> <p>  输入描述:</p><blockquote><p>第1行，两个整数N(1≤N≤750000)、Q(1≤Q≤750000) 第2<del>N行，每行两个整数表示树上的一条边<br>第N+1</del>N+Q行，每行一个整数，表示小H这次轰炸的城市 </p></blockquote><p>输出描述:</p><blockquote><p> 输出Q行，每行一个整数表示这一次轰炸的城市在此次轰炸后共计受损几次</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">3</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始以为一个城市被轰炸后还在。。。发现并不是<br>我们来分析一个点被轰炸，哪些点会受到牵连<br><img src="https://img-blog.csdnimg.cn/20200417122447514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图中点1被轰炸，1的父亲的父亲，儿子的儿子还有兄弟（父亲的儿子）这些点会受损，同理这些点被轰炸，1也会被受损。</p><p>fa[]表示父子关系<br>我们可以用二维数组表示dp[i][j]来表示i节点攻击范围<br>j = 1 为结点i被轰炸的次数<br>j = 2 结点i的子结点被轰炸的次数<br>j = 3 结点i的子结点的子结点被轰炸的次数<br>而每个节点的父亲节点只有一个，我们可以用fa[x]来实现，而儿子节点可以有多个我们通过二维数组来实现。</p><p>总结图中节点x被轰炸的情况;<br>1.本身被轰炸 dp[x][1]<br>2.子节点被轰炸 dp[x][2]<br>3.子节点的子节点被轰炸 dp[x][3]<br>4.父亲节点被轰炸 dp[fa[x]][1]<br>5.父亲的父亲节点被轰炸 dp [ fa [ fa [ x ] ] ] [ 1 ]<br>6.兄弟节点被轰炸 dp[fa [ x ] ] [ 2 ] - dp [x ] <a href="第一个dp求出来的还包含x本身，去掉x的情况就是x的兄弟情况"> 1 </a></p><p>维护好这些，这样我们就可轻松进行查询<br>当x被轰炸时,就让上面6种情况++,注意第六种情况和第一种情况可以合并，所以这两个合成一个 dp[fa [ x ] ] [ 2 ]++就行。<br>最后输出距离x距离为0，1,2的点<br>距离为0即本身 dp[x][1]<br>距离为1 dp[fa[x]][2]<br>距离为2 dp [ fa [ fa [ x ] ] ]  [ 3 ]<br>加起来就是x的答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">750003</span>;</span><br><span class="line"><span class="keyword">int</span> n,q,fa[maxn],dp[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[u]=f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v:edge[u])</span><br><span class="line">        <span class="keyword">if</span>(v!=f)</span><br><span class="line">        dfs(v,u);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">int</span> u,v,x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u,&amp;v);</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    dp[fa[x]][<span class="number">2</span>]++;<span class="comment">//父亲的儿子，情况1和6</span></span><br><span class="line">    dp[fa[x]][<span class="number">1</span>]++;<span class="comment">//父亲本身 情况4</span></span><br><span class="line">    dp [ fa [ fa [ x ] ] ] [ <span class="number">1</span> ] ++;<span class="comment">//父亲的父亲 情况5</span></span><br><span class="line">    dp [ x ] [ <span class="number">2</span> ] ++;<span class="comment">//儿子 情况2</span></span><br><span class="line">    dp [ x ] [ <span class="number">3</span> ] ++;<span class="comment">//儿子的儿子 情况3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp[x][<span class="number">1</span>]+dp[fa[x]][<span class="number">2</span>]+dp[fa[fa[x]]][<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/D&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K 64bit&lt;br&gt;IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;小H正在玩一个战略类游戏，她可以操纵己方的飞机对敌国的N座城市(编号为1~N)进行轰炸
敌国的城市形成了一棵树，小H会依次进行Q次轰炸，每次会选择一个城市A进行轰炸，和这座城市距离不超过2的城市都会受损(这里距离的定义是两点最短路径上的边数)，轰炸结束后，小H还想知道当前城市A受损的次数
作为游戏的开发者之一，你有义务回答小H的问题 &lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
  </entry>
  
  <entry>
    <title>完全平方数</title>
    <link href="http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <id>http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</id>
    <published>2020-04-16T16:23:01.000Z</published>
    <updated>2020-04-16T16:27:40.443Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/C" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>多次查询[l,r]范围内的完全平方数个数</p><p>定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x</p></blockquote><a id="more"></a> <p>输入描述:</p><blockquote><p>第一行一个数n表示查询次数 之后n行每行两个数l,r 输出描述: 对于每个查询，输出一个数表示答案</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">1000000000</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>31622<br>备注:<br>n &lt;= 100000<br>0&lt;= l &lt;= r &lt;= 1000000000</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>签到题<br>l,r直接开方，注意l开方后向上取整。<br>r1-l1+1就是答案</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000005</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">int</span> l,r;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">int</span> l1=<span class="built_in">sqrt</span>(l);</span><br><span class="line"><span class="keyword">int</span> r1=<span class="built_in">sqrt</span>(r);</span><br><span class="line"><span class="keyword">if</span>(l1*l1!=l)l1++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r1-l1+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;多次查询[l,r]范围内的完全平方数个数&lt;/p&gt;
&lt;p&gt;定义整数x为完全平方数当且仅当可以找到整数y使得y*y=x&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="区间处理" scheme="http://Jozky.top/tags/%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Music Problem</title>
    <link href="http://jozky.top/2020/04/17/Music-Problem/"/>
    <id>http://jozky.top/2020/04/17/Music-Problem/</id>
    <published>2020-04-16T16:22:49.000Z</published>
    <updated>2020-04-16T16:27:44.625Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/contest/5203/B" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K<br>64bit IO Format: %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>Listening to the music is relax, but for obsessive(强迫症), it may be<br>unbearable. HH is an obsessive, he only start to listen to music at<br>12:00:00, and he will never stop unless the song he is listening ends</p><a id="more"></a> <p>at integral points (both minute and second are 0 ), that is, he can<br>stop listen at 13:00:00 or 14:00:00,but he can’t stop at 13:01:03 or<br>13:01:00, since 13:01:03 and 13:01：00 are not an integer hour time.<br>Now give you the length of some songs, tell HH whether it’s possible<br>to choose some songs so he can stop listen at an integral point, or<br>tell him it’s impossible. Every song can be chosen at most once.</p></blockquote><p>输入描述:</p><blockquote><p> The first line contains an positive integer T(1≤T≤60), represents<br>there are T test cases.   For each test case:   The first line<br>contains an integer n(1≤n≤105), indicating there are n songs.   The<br>second line contains n integers a1,a2…an (1≤ai≤109 ), the ith integer<br>ai indicates the ith song lasts ai seconds.</p></blockquote><p>输出描述:</p><blockquote><p>For each test case, output one line “YES” (without quotes) if HH is<br>possible to stop listen at an integral point, and “NO” (without<br>quotes) otherwise.</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">1000</span> <span class="number">3000</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2000</span> <span class="number">3000</span> <span class="number">1600</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">5400</span> <span class="number">1800</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><p>说明<br>In the first example it’s impossible to stop at an integral point.<br>In the second example if we choose the first and the third songs, they cost 3600 seconds in total, so HH can stop at 13:00:00<br>In the third example if we choose the first and the second songs, they cost 7200 seconds in total, so HH can stop at 14:00:00</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你n个数，这些数自由组合能不能凑出3600的倍数</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>我一开始想到的是前缀和，后来感觉dp最直接<br>dp[x]=1表示能组成x这个数<br>dp = 0表示组不了<br>cnt是中间数组，暂时存储本轮的数值<br>因为求能不能组成3600，可以用mod，3600的倍数mod后都是0，直接求dp[0]是否等于1<br>每读取一个a，就把a与之前所求的值进行相加存在cnt里，然后再给dp[]，cnt就是工具人</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a) memset(a,0,sizeof(a))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> dp[maxn],cnt[maxn];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">3600</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t,n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">    mem(dp);</span><br><span class="line">    mem(cnt);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    a%=<span class="number">3600</span>;</span><br><span class="line">    <span class="keyword">if</span>(!dp[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[j]&gt;<span class="number">0</span>||j==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    cnt[(a+j)%<span class="number">3600</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3600</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[j])dp[j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[j]==<span class="number">1</span>)cnt[j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//mem(cnt);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!dp[<span class="number">0</span>])<span class="built_in">cout</span>&lt;&lt;<span class="string">"NO"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"YES"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个很玄学的地方我把读入n放在两个mem之前，数据就过了一半，放后面就ac了，不知道为什么<br><img src="https://img-blog.csdnimg.cn/20200416235545673.png" alt="在这里插入图片描述">看来卡时间卡的太紧了（笑哭）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 131072K，其他语言262144K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Listening to the music is relax, but for obsessive(强迫症), it may be&lt;br&gt;unbearable. HH is an obsessive, he only start to listen to music at&lt;br&gt;12:00:00, and he will never stop unless the song he is listening ends&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>相反数</title>
    <link href="http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/"/>
    <id>http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/</id>
    <published>2020-04-16T16:22:10.000Z</published>
    <updated>2020-04-16T16:27:42.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="https://ac.nowcoder.com/acm/contest/5203/A" target="_blank" rel="noopener">传送</a></p><h3 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h3><p>一个数加上他的相反数</p><h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况</p><a id="more"></a> <h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> w[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">bool</span> f=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,sum2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)sum=sum*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">if</span>(s[i]==<span class="string">'0'</span>&amp;&amp;f==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">  f=<span class="number">1</span>;</span><br><span class="line">sum2=sum2*<span class="number">10</span>+s[i]-<span class="string">'0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;sum+sum2;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;A-相反数&quot;&gt;&lt;a href=&quot;#A-相反数&quot; class=&quot;headerlink&quot; title=&quot;A 相反数&quot;&gt;&lt;/a&gt;A 相反数&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/contest/5203/A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;题意：&quot;&gt;&lt;a href=&quot;#题意：&quot; class=&quot;headerlink&quot; title=&quot;题意：&quot;&gt;&lt;/a&gt;题意：&lt;/h3&gt;&lt;p&gt;一个数加上他的相反数&lt;/p&gt;
&lt;h3 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class=&quot;headerlink&quot; title=&quot;题解：&quot;&gt;&lt;/a&gt;题解：&lt;/h3&gt;&lt;p&gt;用字符串存数，分出求出本身和相反数的值，然后相加输出，注意判断相反后出现0的情况&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="模拟" scheme="http://Jozky.top/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 282E Sausage Maximization</title>
    <link href="http://jozky.top/2020/04/16/CodeForces-282E-Sausage-Maximization/"/>
    <id>http://jozky.top/2020/04/16/CodeForces-282E-Sausage-Maximization/</id>
    <published>2020-04-16T14:51:52.000Z</published>
    <updated>2020-04-16T14:54:18.610Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">传送cf题目</a><br> <a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">传送牛客网题目</a><br><del>看了半个多小时的题解才搞明白，一下题解为自己的心得</del><br>参考博客（这两个讲的很详细）：<br><a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a><br><a href="https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html" target="_blank" rel="noopener">参考二</a></p><blockquote><p>题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？</p><a id="more"></a><p>比如 一组数  1 2 3 4 5 6 你可以选择前缀为1 2，前缀异或和为3 选择后缀为4 5 6，后缀异或和为7<br>（前缀异或和）与（后缀异或和）异或值为4，但此时4并不是最大情况，求出最大情况</p></blockquote><p><strong>思路：</strong><br>首先讲个小例题：</p><blockquote><p>  给一个数 a，还有一堆数，怎么在这一堆数中找出一个数 b，a 和 b 的异或值最大？</p></blockquote><p>最暴力的方法无疑是（<del>老办法</del>）  枚举，枚举每一个b，但这样肯定不行<del>（不然我写这个博客干什么）</del> ，想想计算机的本质是啥？对，二进制。我们把a与这堆数转化成二进制，把后面这堆数装进一个字典树，当然要从最高位装，比如这堆数是123456，如图<img src="https://uploadfiles.nowcoder.com/files/20200326/543071257_1585188887053_20200326000539458.jpg" alt="这堆数是123456">根据异或规则不同为一，所以我们要使a与b异或最大，就要让b尽可能与a不同，a已经给定，b已经形成字典树，我们就从字典树root开始，尽量找出于a当前位置不同的数，直到找到最低位为止，那么这样找到的b满足条件。</p><p><strong>回到这个题：</strong><br>首先这些n个数组成一个区间w，w的全部异或结果是定值K,所以问题可以改成在区间w中取连续一段区间m，m的异或结果为X，m的前部分就成为区间w的前缀，后半部分就是区间w的后缀。<br>我们知道相同的数异或为零，那么X与K异或，重复的那部分区间异或后为零，就相当于是我们题目所求的<br>，所以就是求什么情况下X xor K最大。<br>发现现在的情况和一开始讲的例题很像了吧，我们假设有个Y，Y与K的每一个二进制相异，我们就要让X尽可能接近Y。<br>怎么实现呢？也是建一个字典树，将f[i]放进去（f[i]=a[1] ^ a[2]  ^ a[3] ^ …^ a[i]）,那么f[i]^f[j]=a[i+1] ^ a[i+2] ^ … ^a<a href="i之前的部分为i和j共有，一异或就相当于没了">j</a>可以表示i+1到j这段区间的异或值。<br>我们枚举区间m的结尾，每次用一个f[i]去匹配一个f[k]，使得f[k]^f[i]的值在高位上尽可能去接近Y，这样就相当于选出区间[k+1,i]de异或值作为X，每次在[1,i]区间内匹配出来一个最佳区间后，不断更新答案。<br>看懂了吗？这些神奇的操作，巧妙利用字典树（工具人石锤）来匹配。<br>(太晚了就不重新打代码了，借用下<a href="https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">参考一</a>的代码)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">//范围是10的12次方，我们就将每个数固定为40位</span><br><span class="line"><span class="comment">#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">#define LL long long</span></span><br><span class="line"><span class="comment">#define rep(i,j,k) for(int i = j; i &lt;= k; i++ )</span></span><br><span class="line"><span class="comment">#define Rrep(i,j,k) for(int i = j; i &gt;= k; i-- )</span></span><br><span class="line"><span class="comment">#define Clean(x,y) memset(x,y,sizeof(x)) </span></span><br><span class="line">int n;</span><br><span class="line">LL a[100009];</span><br><span class="line">LL temp;</span><br><span class="line">LL ans;</span><br><span class="line"> </span><br><span class="line">LL p[45];</span><br><span class="line">int aim[45];</span><br><span class="line">int Next[1000000][2];</span><br><span class="line">int len;</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    Clean(Next,0);</span><br><span class="line">    len = 0;</span><br><span class="line">&#125;</span><br><span class="line">void insert(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( !Next[now][k] ) Next[now][k] = ++len;</span><br><span class="line">        now = Next[now][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL query(LL t)</span><br><span class="line">&#123;</span><br><span class="line">    int now = 0;</span><br><span class="line">    LL ans = 0;</span><br><span class="line">    int k;</span><br><span class="line">    Rrep(i,39,0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( p[i] &amp; t ) k = 1;</span><br><span class="line">        <span class="keyword">else</span> k = 0;</span><br><span class="line">        <span class="keyword">if</span> ( ( aim[i] &amp;&amp; Next[now][1-k] ) || ( !aim[i] &amp;&amp; Next[now][k] )  )</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=p[i];</span><br><span class="line">            now = aim[i]==1?Next[now][1-k]:Next[now][k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now = aim[i]==0?Next[now][1-k]:Next[now][k];</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="built_in">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    p[0] = 1;</span><br><span class="line">    rep(i,1,40) p[i] = p[i-1]&lt;&lt;1;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span>(scanf(<span class="string">"%d"</span>,&amp;n)==1)</span><br><span class="line">    &#123;</span><br><span class="line">        a[0] = 0;</span><br><span class="line">        ans = 0;</span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            scanf(<span class="string">"%I64d"</span>,&amp;temp);</span><br><span class="line">            a[i] = temp ^ a[i-1];</span><br><span class="line">        &#125;</span><br><span class="line">        ans = max(ans,a[n]);</span><br><span class="line">        rep(i,0,39)</span><br><span class="line">            <span class="keyword">if</span> ( a[n] &amp; p[i] ) aim[i] = 0; //计算Y</span><br><span class="line">            <span class="keyword">else</span> aim[i] = 1;</span><br><span class="line">        init();</span><br><span class="line">        insert(a[0]); </span><br><span class="line">        rep(i,1,n)</span><br><span class="line">        &#123;</span><br><span class="line">            insert(a[i]);</span><br><span class="line">            ans = max(ans,query(a[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://codeforces.com/problemset/problem/282/E&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送cf题目&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/109910&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送牛客网题目&lt;/a&gt;&lt;br&gt;&lt;del&gt;看了半个多小时的题解才搞明白，一下题解为自己的心得&lt;/del&gt;&lt;br&gt;参考博客（这两个讲的很详细）：&lt;br&gt;&lt;a href=&quot;https://blog.csdn.net/chy20142109/article/details/50706248?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考一&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://www.cnblogs.com/zhj5chengfeng/archive/2013/05/14/3077621.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考二&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题意：有一个长度有n的整数序列，你要在这个序列中选择一个前缀和后缀，前后缀不想交，前后缀任何一方都可以为空，问你前缀异或值与后缀异或值的异或最大是多少？&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="字典树" scheme="http://Jozky.top/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
      <category term="前缀异或和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月14日题目精讲 Xorto</title>
    <link href="http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/"/>
    <id>http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8814%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Xorto/</id>
    <published>2020-04-16T14:47:16.000Z</published>
    <updated>2020-04-16T14:54:21.231Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/14247" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K<br> 64bit IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；<br>第二行n个整数表示数组； 1&lt;=n&lt;=1000,0&lt;=数组元素&lt;100000。</p></blockquote><a id="more"></a><p>输出描述:<br>一行一个整数表示答案。<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>说明<br>([1,1],[2,2]),([1,1],[3,3]),([1,1],[2,3]),([1,2],[3,3]),([2,2],[3,3])</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>枚举？TLE√<br>暴力肯定过不了，我们可以先考虑只枚举一个区间[x,y]，这个区间可以通过前缀异或和得到。pre来存前缀<br>我们用[x,y]表示右边的区间，题目要求左右区间异或和为0，也就是问[x,y]左边有多少和它值一样的区间。<br>我们可以用a[i]来存，a[i]表示左边异或和为i区间个数，数组a反应的数量，i反映的是值。<br>先将区间[k,i]存进a中，再用a[ ]来查看左边有多少区间异或和值与右区间[i+1 , j]值相同。<br>因为a存的是数量，所以直接用ans+=a [ pre[i] ^ [j] ]</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e7</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        pre[i]=pre[i<span class="number">-1</span>]^x;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++) a[pre[i]^pre[k]]++;<span class="comment">//</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++) ans += a[pre[i]^pre[j]];<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>关于异或的题我最近做了个<br>CF282E    Sausage Maximization<br><a href="https://ac.nowcoder.com/acm/problem/109910" target="_blank" rel="noopener">牛客网题目链接</a><br>异或的题，解法挺新颖，不过不知道为什么牛客网这里不能 提交？<br>原题是cf的<a href="http://codeforces.com/problemset/problem/282/E" target="_blank" rel="noopener">cf题目链接</a><br><a href="https://blog.nowcoder.net/n/2369369adcb44ebcbaf9be0a1894aa4a" target="_blank" rel="noopener">我自己写的题解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/14247&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 32768K，其他语言65536K&lt;br&gt; 64bit IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个长度为n的整数数组，问有多少对互不重叠的非空区间，使得两个区间内的数的异或和为0。 输入描述: 第一行一个数n表示数组长度；&lt;br&gt;第二行n个整数表示数组； 1&amp;lt;=n&amp;lt;=1000,0&amp;lt;=数组元素&amp;lt;100000。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="前缀异或和" scheme="http://Jozky.top/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>牛客网 【每日一题】4月10日 二分图染色(弱化版)</title>
    <link href="http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/"/>
    <id>http://jozky.top/2020/04/16/%E7%89%9B%E5%AE%A2%E7%BD%91-%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8810%E6%97%A5-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2-%E5%BC%B1%E5%8C%96%E7%89%88/</id>
    <published>2020-04-16T09:31:39.000Z</published>
    <updated>2020-04-16T09:34:12.627Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/13229" target="_blank" rel="noopener">题目传送</a></p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒<br>空间限制：C/C++ 524288K，其他语言1048576K<br>64bit IO Format: %lld</p></blockquote><p>题目描述 </p><blockquote><p>给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。<br>计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>二分图单边的顶点数目n(n ≤ 10^7)</p></blockquote><p>输出描述:</p><blockquote><p>输出一个整数,即所求的答案。</p></blockquote><p>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">35</span></span><br></pre></td></tr></table></figure><h2 id="题意-amp-amp-题解：："><a href="#题意-amp-amp-题解：：" class="headerlink" title="题意&amp;&amp;题解：："></a>题意&amp;&amp;题解：：</h2><p>完全二分图:是一种特殊的二分图，可以把图中的顶点分成两个集合，使得第一个集合中的所有顶点都与第二个集合中的所有顶点相连。<br>我们可以把左右各有n个点的二分图的题转化成n*n的棋盘问题。（离散上学过）<br>题目：让染三个颜色，红蓝绿，但是绿色并没有什么要求，我们可以最后再随便放。所以我们先考虑红和蓝。<br>红和蓝都是不能共享端点，同步到棋盘上（行和列分别表示二分图两个集合），也就是棋盘上行和列只能有一个红或蓝</p><p>现在的题目就是：<br>在n*n的棋盘上，放任意红和蓝棋子，任一行和列不能有相同颜色的棋子，有多少种放的方法？<br>F<del>n</del>表示棋盘大小为 n * n时的答案<br>先只考虑一个颜色： F<del>n</del>=<img src="https://img-blog.csdnimg.cn/20200416162741561.png" alt="在这里插入图片描述">)种方案(先在n行里选若干行，然后每一行选若干列，行没有顺序区分，就是选两行，选第一行和第三行与选第一行和第二行没差，所以选行用组合；而列不一样，因为行列只能放一个，我们可以先放在一行上，然后分散到其他行，所以选列的时候要考虑顺序问题，要用的是排列而不是组合)<br>如图：<br><img src="https://img-blog.csdnimg.cn/20200416164224892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>比如我们选两行（C^2^ <del>n</del> ），然后每行放一个，我们先考虑都放在一行上，看图中最上面两行（黄色和绿色），都是选的第一个格和第二个格，但是分散开不一样，（图中4 * 4的表格）说明我们要考虑顺序，所以选列是A^2^<del>n</del>，将所以情况加起来就是选一个颜色的方案</p><p>选两个颜色：从上面我们能得到一个颜色是F<del>n</del>，两个就是F<del>n</del>* F<del>n</del>，非也，因为这样会出现一个格子放两个棋子，我们还要将这种情况删去。需要容斥。<br>我们用g<del>i</del>表示最少有i个点放了两个棋子（颜色不一样）的方案数。那么除去i 行和i 列（i个点所在），我们在剩下n-i行与列里就不会有重复的，g<del>i</del> = f ^2^<del>n-i</del> 。被除去的 i 行与 i列选法和之前一样是 C^i^<del>n</del>A^i^<del>n</del> ，最后得到容斥公式：<br><img src="https://img-blog.csdnimg.cn/20200416170156368.png" alt="在这里插入图片描述"><br>（这一部分好好理解）</p><p>C^k^<del>n</del>A^k^<del>n</del>都可以求好，但是Fn提前求会超时，说明上面的公式不能用，我们要换一个想法来求<br>我们来考虑F<del>n</del>能不能递推出来，从F<del>n-1</del>推出F<del>n</del><br>考虑n-1到n的过程：<br>一共增加了2n-1个格子（n^2^-(n-1)^2^）,n-1之前的格子都已经放好了，我们只需要考虑多出的这些格子该怎么放。<br>如果只放一个棋子，就有2n-1个方案，如果都不放，一个方案，一共是2n种方案，也就是2n<em>F<del>n-1</del>，（F<del>n-1</del>是之前n-1行列已经放好的方案数）<br>但是有限制条件，每一行不能有相同颜色，每放一个棋子，意味着这一行这一列都不能放了，就会出现n-1种重复情况（因为是从n-1的扩展来的），我们之前n-1行列的棋子都平移靠边，因为之前都是不同行同列，所以靠边后，正好占了一行一列，也就是我们在新增部分可以放的棋子，实际上是F<del>n-2</del>而非F<del>n-1</del>（这里可以看看图），那一共（n-1）F<del>n-2</del>次重复情况，可以选n-1行，而且每一列也可以进行相同操作,总的方案数就是2×(n−1) ^2^ ∗F(n−2)<br>借鉴邓老师的图：<br><img src="https://img-blog.csdnimg.cn/2020041617195483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们还要考虑放两个的情况;<br>即最后一行和列分别放一个，这样不重复嘛<br>方案就是：（n-1）^2^</em>F(n-2)<br><img src="https://img-blog.csdnimg.cn/20200416172115547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>总结：得到公式<br>F[n]=2<em>n</em>F[n-1]-(n-1)^2^F[n-2]<br>（<del>我真的是把我所能理解都写出来了</del> ）</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10000004</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> g[N],s[N],F[N];</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[m] % mod * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">A</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1l</span>l * g[n] * s[n - m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    g[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;++i)</span><br><span class="line">        g[i] = <span class="number">1l</span>l * g[i - <span class="number">1</span>] * i % mod;</span><br><span class="line">        </span><br><span class="line">         ll ans1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y &gt;&gt;= <span class="number">1</span>,x = x * x % mod)</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="keyword">if</span>(y &amp; <span class="number">1</span>) ans1 = ans1 * x % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    s[n] = ans1;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)</span><br><span class="line">        s[i] = <span class="number">1l</span>l * s[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod;</span><br><span class="line">        </span><br><span class="line">    F[<span class="number">0</span>] = <span class="number">1</span>;F[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;++i)</span><br><span class="line">        F[i] = (<span class="number">2l</span>l * i * F[i - <span class="number">1</span>] - <span class="number">1l</span>l * F[i - <span class="number">2</span>] * (i - <span class="number">1</span>) % mod * (i - <span class="number">1</span>) % mod) % mod;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">     ll k ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= n;++i) &#123;</span><br><span class="line">       k=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &amp; <span class="number">1</span>) k = <span class="number">-1</span>;</span><br><span class="line">        ans += k * C(n,i) * A(n,i) % mod * F[n - i] % mod * F[n - i] % mod;</span><br><span class="line">        ans %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(ans + mod) % mod);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/13229&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目传送&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;br&gt;空间限制：C/C++ 524288K，其他语言1048576K&lt;br&gt;64bit IO Format: %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个完全二分图，图的左右两边的顶点数目相同。我们要给图中的每条边染成红色、蓝色、或者绿色，并使得任意两条红边不共享端点、同时任意两条蓝边也不共享端点。&lt;br&gt;计算所有满足条件的染色的方案数，并对10^9^+7取模。 (ps：本题数据量与实际比赛中数据量相比，少了一些)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="数论" scheme="http://Jozky.top/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="组合" scheme="http://Jozky.top/tags/%E7%BB%84%E5%90%88/"/>
    
      <category term="容斥" scheme="http://Jozky.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】合集</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91%E5%90%88%E9%9B%86/</id>
    <published>2020-04-15T11:53:47.000Z</published>
    <updated>2020-04-16T09:39:03.852Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C"><a href="#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C" class="headerlink" title="2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C"></a>2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/">题解</a></p><h2 id="2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮"><a href="#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮"></a>2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/">题解</a></p><a id="more"></a><h2 id="2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛"><a href="#2020年3月27日-NC15553-数学考试-2018年长沙理工大学程序设计竞赛" class="headerlink" title="2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛"></a>2020年3月27日 NC15553 数学考试 2018年长沙理工大学程序设计竞赛</h2><p><a href="http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8827%E6%97%A5-%E6%95%B0%E5%AD%A6%E8%80%83%E8%AF%95/">题解</a></p><h2 id="2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5"><a href="#2020年3月30日-NC50528-滑动窗口-《信息学奥赛一本通》Part5-5" class="headerlink" title="2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5"></a>2020年3月30日 NC50528 滑动窗口 《信息学奥赛一本通》Part5.5</h2><p><a href="http://jozky.top/2020/04/01/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/">题解</a></p><h2 id="2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛"><a href="#2020年3月31日-NC13331-城市网络-美团2017年CodeM大赛-复赛" class="headerlink" title="2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛"></a>2020年3月31日 NC13331 城市网络 美团2017年CodeM大赛-复赛</h2><p><a href="http://jozky.top/2020/04/05/%E7%89%9B%E5%AE%A2%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983-31-%E5%9F%8E%E5%B8%82%E7%BD%91%E7%BB%9C-%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E/">题解</a></p><h2 id="2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11"><a href="#2020年4月1日-NC22598-Rinne-Loves-Edges-牛客小白月赛11" class="headerlink" title="2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11"></a>2020年4月1日 NC22598 Rinne Loves Edges 牛客小白月赛11</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%881%E6%97%A5%E9%A2%98%E7%9B%AE-Rinne-Loves-Edges/">题解</a></p><h2 id="2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12"><a href="#2020年4月2日-NC23053-月月查华华的手机-牛客小白月赛12" class="headerlink" title="2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12"></a>2020年4月2日 NC23053 月月查华华的手机 牛客小白月赛12</h2><p><a href="http://jozky.top/2020/04/02/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%882%E6%97%A5-%E6%9C%88%E6%9C%88%E6%9F%A5%E5%8D%8E%E5%8D%8E%E7%9A%84%E6%89%8B%E6%9C%BA/">题解</a></p><h2 id="2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛"><a href="#2020年4月3日-NC13886-Shortest-Path-西南交通大学第十三届ACM决赛" class="headerlink" title="2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛"></a>2020年4月3日 NC13886 Shortest Path 西南交通大学第十三届ACM决赛</h2><p><a href="http://jozky.top/2020/04/04/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%91Shortest-Path-4%E6%9C%883%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-DFS/">题解</a></p><h2 id="2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛"><a href="#2020年4月6日-NC13221-数码-美团2017年CodeM大赛-资格赛" class="headerlink" title="2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛"></a>2020年4月6日 NC13221 数码 美团2017年CodeM大赛-资格赛</h2><p><a href="http://jozky.top/2020/04/06/%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%886%E6%97%A5%E6%95%B0%E7%A0%81/">题解</a></p><h2 id="2020年4月7日-NC13611-树-牛客练习赛1"><a href="#2020年4月7日-NC13611-树-牛客练习赛1" class="headerlink" title="2020年4月7日 NC13611 树 牛客练习赛1"></a>2020年4月7日 NC13611 树 牛客练习赛1</h2><p><a href="http://jozky.top/2020/04/07/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%887%E5%8F%B7%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E6%A0%91/">题解</a></p><h2 id="2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮"><a href="#2020年4月8日-NC13249-黑白树-美团2017年CodeM大赛-初赛B轮" class="headerlink" title="2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮"></a>2020年4月8日 NC13249 黑白树 美团2017年CodeM大赛-初赛B轮</h2><p><a href="http://jozky.top/2020/04/09/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%888%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-%E9%BB%91%E7%99%BD%E6%A0%91/">题解</a></p><h2 id="2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05"><a href="#2020年4月9日-NC50940-Running-Median-《算法竞赛进阶指南》0x05" class="headerlink" title="2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05"></a>2020年4月9日 NC50940 Running Median 《算法竞赛进阶指南》0x05</h2><p><a href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/">题解</a></p><h2 id="2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮"><a href="#2020年4月10日-NC13229-二分图染色-美团2017年CodeM大赛-初赛A轮" class="headerlink" title="2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮"></a>2020年4月10日 NC13229 二分图染色 美团2017年CodeM大赛-初赛A轮</h2><p><a href="http://jozky.top/2020/04/16/牛客网-【每日一题】4月10日-二分图染色-弱化版/">题解</a></p><h2 id="2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54"><a href="#2020年4月13日-NC51180-Accumulation-Degree-《算法竞赛进阶指南》0x54" class="headerlink" title="2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54"></a>2020年4月13日 NC51180 Accumulation Degree 《算法竞赛进阶指南》0x54</h2><p><a href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/">题解</a></p><h2 id="2020年4月14日-NC14247-Xorto-Wannafly挑战赛1"><a href="#2020年4月14日-NC14247-Xorto-Wannafly挑战赛1" class="headerlink" title="2020年4月14日 NC14247 Xorto Wannafly挑战赛1"></a>2020年4月14日 NC14247 Xorto Wannafly挑战赛1</h2><h2 id="2020年4月15日-NC14248-Treepath-Wannafly挑战赛1"><a href="#2020年4月15日-NC14248-Treepath-Wannafly挑战赛1" class="headerlink" title="2020年4月15日 NC14248 Treepath Wannafly挑战赛1"></a>2020年4月15日 NC14248 Treepath Wannafly挑战赛1</h2><h2 id="2020年4月16日-NC14731-逆序对-Wannafly挑战赛6"><a href="#2020年4月16日-NC14731-逆序对-Wannafly挑战赛6" class="headerlink" title="2020年4月16日 NC14731 逆序对 Wannafly挑战赛6"></a>2020年4月16日 NC14731 逆序对 Wannafly挑战赛6</h2><h2 id="未完再续。。。"><a href="#未完再续。。。" class="headerlink" title="未完再续。。。"></a>未完再续。。。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C&quot;&gt;&lt;a href=&quot;#2020年3月25日-NC50439-tokitsukaze-and-Soldier-牛客练习赛50-C&quot; class=&quot;headerlink&quot; title=&quot;2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C&quot;&gt;&lt;/a&gt;2020年3月25日 NC50439 tokitsukaze and Soldier 牛客练习赛50-C&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8825%E6%97%A5-tokitsukaze-and-Soldier/&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮&quot;&gt;&lt;a href=&quot;#2020年3月26日-NC13230-合并回文子串-美团2017年CodeM大赛-初赛A轮&quot; class=&quot;headerlink&quot; title=&quot;2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮&quot;&gt;&lt;/a&gt;2020年3月26日 NC13230 合并回文子串 美团2017年CodeM大赛-初赛A轮&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/06/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%913%E6%9C%8826%E6%97%A5-%E5%90%88%E5%B9%B6%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客算法周周练2</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%AE%97%E6%B3%95%E5%91%A8%E5%91%A8%E7%BB%832/</id>
    <published>2020-04-15T11:53:10.000Z</published>
    <updated>2020-04-17T12:45:34.996Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="A-相反数"><a href="#A-相反数" class="headerlink" title="A 相反数"></a>A 相反数</h2><p><a href="http://jozky.top/2020/04/17/%E7%9B%B8%E5%8F%8D%E6%95%B0/">站内题解</a></p><h2 id="B-Music-Problem"><a href="#B-Music-Problem" class="headerlink" title="B Music Problem"></a>B Music Problem</h2><p><a href="http://jozky.top/2020/04/17/Music-Problem/">站内题解</a></p><h2 id="C-完全平方数"><a href="#C-完全平方数" class="headerlink" title="C 完全平方数"></a>C 完全平方数</h2><p><a href="http://jozky.top/2020/04/17/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/">站内题解</a></p><h2 id="D-小H和游戏"><a href="#D-小H和游戏" class="headerlink" title="D 小H和游戏"></a>D 小H和游戏</h2><p><a href="http://jozky.top/2020/04/17/%E5%B0%8FH%E5%92%8C%E6%B8%B8%E6%88%8F/">站内题解</a></p><h2 id="E-水题-water"><a href="#E-水题-water" class="headerlink" title="E 水题(water)"></a>E 水题(water)</h2><p><a href="http://jozky.top/2020/04/17/%E6%B0%B4%E9%A2%98-water-%EF%BC%88%E9%9D%9E%E8%AF%A6%E7%BB%86%E8%A7%A3%E7%AD%94%EF%BC%89/">站内题解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;A-相反数&quot;&gt;&lt;a href=&quot;#A-相反数&quot; class=&quot;headerlink&quot; title=&quot;A 相反数&quot;&gt;&lt;/a&gt;A 相反数&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://jozky.top/2020/04/17/%E7%9B%
      
    
    </summary>
    
    
      <category term="比赛" scheme="http://Jozky.top/categories/%E6%AF%94%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月13号 Accumulation Degree</title>
    <link href="http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/"/>
    <id>http://jozky.top/2020/04/15/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%8813%E5%8F%B7-Accumulation-Degree/</id>
    <published>2020-04-15T11:37:51.000Z</published>
    <updated>2020-04-15T11:39:34.471Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/51180" target="_blank" rel="noopener">本题目传送</a></p><p>题目树学是这个题的简易版，也涉及换根问题，可以先看看这个<br><a href="https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92" target="_blank" rel="noopener">树学</a></p><blockquote><p>时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit<br>IO Format:%lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><blockquote><p>Trees are an important component of the natural landscape because of<br>their prevention of erosion and the provision of a specific<br>ather-sheltered ecosystem in and under their foliage. Trees have also</p><a id="more"></a><p>been found to play an important role in producing oxygen and reducing<br>carbon dioxide in the atmosphere, as well as moderating ground<br>temperatures. They are also significant elements in landscaping and<br>agriculture, both for their aesthetic appeal and their orchard crops<br>(such as apples). Wood from trees is a common building material.</p><p>Trees also play an intimate role in many of the world’s mythologies.<br>Many scholars are interested in finding peculiar properties about<br>trees, such as the center of a tree, tree counting, tree coloring.<br>A(x) is one of such properties.</p></blockquote><p>A(x) (accumulation degree of node x) is defined as follows:</p><ol><li>Each edge of the tree has an positive capacity.</li><li>The nodes with degree of one in the tree are named terminals.</li><li>The flow of each edge can’t exceed its capacity.</li><li>A(x) is the maximal flow that node x can flow to other terminal nodes.</li></ol><p>Since it may be hard to understand the definition, an example is showed below:<br><img src="https://img-blog.csdnimg.cn/20200415184510424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="样例分析："><a href="#样例分析：" class="headerlink" title="样例分析："></a>样例分析：</h2><p>A(1)=11+5+8=24<br>Details:<br>1-&gt;2    11<br>1-&gt;4-&gt;3    5<br>1-&gt;4-&gt;5    8(since 1-&gt;4 has capacity of 13)</p><hr><p>A(2)=5+6=11<br>Details:<br>2-&gt;1-&gt;4-&gt;3    5<br>2-&gt;1-&gt;4-&gt;5    6</p><hr><p>A(3)=5<br>Details:    3-&gt;4-&gt;5    5</p><hr><p>A(4)=11+5+10=26<br>Details:    4-&gt;1-&gt;2    11<br>4-&gt;3    5<br>4-&gt;5    10</p><hr><p>A(5)=10<br>Details:    5-&gt;4-&gt;1-&gt;2    10</p><hr><p>The accumulation degree of a tree is the maximal accumulation degree among its nodes. Here your task is to find the accumulation degree of the given trees.</p><p>输入描述:<br>The first line of the input is an integer T which indicates the number of test cases. The first line of each test case is a positive integer n. Each of the following n - 1 lines contains three integers x, y, z separated by spaces, representing there is an edge between node x and node y, and the capacity of the edge is z. Nodes are numbered from 1 to n.<br>All the elements are nonnegative integers no more than 200000. You may assume that the test data are all tree metrics.<br>输出描述:<br>For each test case, output the result on a single line.<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">11</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">26</span></span><br></pre></td></tr></table></figure><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>看看样例分析应该就明白了<br>每个节点都有流量，求出最大流量是多少？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>flow【i】表示i点的流量：<br>一个点的流量是怎么来的？如果j（j是i的子节点）的流量小于i与j边的容量，flow【i】=flow[j]，如果大于两点之间的容量，flow[i]=i与j的流量<br>i与j的流量就是i与j的边权，我们用edge[i][j]表示。<br>可以得到公式：flow[i]=∑min(flow[j],edge[i][j])<br>因为i有可能有很多子节点，所以加在一起<br>考虑完i之后，我们来考虑换根<br>如图：<img src="https://img-blog.csdnimg.cn/20200415185955370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们将根从x换成y<br>题一中（以x为根）<br>x的流量来自于y，子树2，子树3<br>y的流量来自于子树1<br>图二中（以y为根）<br>x的流量来自子树2，子树3<br>y的流量来自子树1，x</p><p>我们发现换根后，x的流量就没有了y的部分，其他都还在，此时x的流量就是原本的减去从y流向x的部分，new[x]=flow[ x ] - min ( flow[ y ] , edge[ x ] [ y ] ),这个new表示x新的流量</p><p>我们再看y，y的流量多了从x流来的部分，y的流量就是flow[y]+min(new[x],edge[x][y])，，因为换根x的流量发生改变（上一段所讲），那流向y的是现在x的流量，而不是换跟前的flow[x].</p><p>换根前后，图二中绿色区域没有发生改变，也就是父节点改变影响不到子节点</p><p>还要注意叶子节点，如果x从根变成叶子节点（x的儿子只有y，当y成为根节点之后，x没有了儿子），x的流量不是上面的公式，而是变成了edge[x][y]，因为没有子节点的流量流向x，只有x与y的边权值，也就是上面讲的式子使用条件是min（x，y），x和y不能为0。</p><p>先求出x为根的流量，然后依次换根求出最大值</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x7f</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span> + <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[maxn], cnt = <span class="number">0</span>, d[maxn], deg[maxn], f[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">&#125;edge[maxn * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(deg));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].x = x;</span><br><span class="line">    edge[cnt].y = y;</span><br><span class="line">    edge[cnt].w = w;</span><br><span class="line">    edge[cnt].next = head[x];</span><br><span class="line">    head[x] = cnt++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[root]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(y == fa)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(deg[y] == <span class="number">1</span>)&#123;<span class="comment">//如果y只有一个子节点，y的流量只能是root与y的边权值 </span></span><br><span class="line">            ans += edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            dfs(y, root);</span><br><span class="line">            ans += min(d[y], edge[i].w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d[root] = ans </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="comment">//先求出节点x的流量 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[x]; i != <span class="number">-1</span>; i = edge[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> y = edge[i].y;</span><br><span class="line">        <span class="keyword">if</span>(edge[i].y == fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(deg[x] == <span class="number">1</span>)&#123;</span><br><span class="line">            f[y] = d[y] + edge[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            f[y] = d[y] + min(f[x] - min(d[y], edge[i].w), edge[i].w);<span class="comment">//核心公式 </span></span><br><span class="line">        &#125;</span><br><span class="line">        dp(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//从x不断换根 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">   <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">       <span class="keyword">int</span> x, y, w;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        init();<span class="comment">//初始化 </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">         </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;w);</span><br><span class="line">            addedge(x, y, w);<span class="comment">//添边 </span></span><br><span class="line">            addedge(y, x, w);<span class="comment">//添边 </span></span><br><span class="line">                deg[x]++;<span class="comment">//deg用于判断这个点有几个子节点 </span></span><br><span class="line">     deg[y]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">        dfs(s, <span class="number">0</span>);<span class="comment">//求x的流量 </span></span><br><span class="line">        f[s] = d[s];</span><br><span class="line">        dp(s, <span class="number">0</span>);<span class="comment">//不断换根 </span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            ans = max(ans, f[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51180&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本题目传送&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目树学是这个题的简易版，也涉及换根问题，可以先看看这个&lt;br&gt;&lt;a href=&quot;https://blog.nowcoder.net/n/47d83f32a1374ddaafd02662f21bec92&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;树学&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 1秒，其他语言2秒 空间限制：C/C++ 32768K，其他语言65536K 64bit&lt;br&gt;IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Trees are an important component of the natural landscape because of&lt;br&gt;their prevention of erosion and the provision of a specific&lt;br&gt;ather-sheltered ecosystem in and under their foliage. Trees have also&lt;/p&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="换根" scheme="http://Jozky.top/tags/%E6%8D%A2%E6%A0%B9/"/>
    
      <category term="二次扫描" scheme="http://Jozky.top/tags/%E4%BA%8C%E6%AC%A1%E6%89%AB%E6%8F%8F/"/>
    
  </entry>
  
  <entry>
    <title>树学</title>
    <link href="http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/"/>
    <id>http://jozky.top/2020/04/14/%E6%A0%91%E5%AD%A6/</id>
    <published>2020-04-14T14:35:39.000Z</published>
    <updated>2020-04-14T14:39:06.221Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]<br><a href="https://ac.nowcoder.com/acm/problem/201400" target="_blank" rel="noopener">传送</a></p><blockquote><p>时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K<br>64bit IO Format:&gt; %lld</p></blockquote><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep<del>root</del>为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep<del>i</del>=dep<del>fa</del> <del>i</del>+1,整棵树的价值W=<img src="https://img-blog.csdnimg.cn/20200414204932422.png" alt="在这里插入图片描述"> ，即所有点的深度和</p><a id="more"></a><p>牛妹希望这棵树的W最小，请你告诉她，选择哪个点可以使W最小<br>输入描述:<br>第一行，一个数，n<br>接下来n-1行，每行两个数x,y，代表x-y是树上的一条边<br>输出描述:<br>一行，一个数，最小的W<br>示例1<br>输入</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><p>备注:<br>对于30%30%的数据，1&lt;= n&lt;=1000<br>对于100%100%的数据，1&lt;=n &lt;=10^6^</p><h2 id="题解1："><a href="#题解1：" class="headerlink" title="题解1："></a>题解1：</h2><p>树形dp+换根<br>用到的几个函数：<br>dep[i]：节点i的深度<br>ant[i]：i的子树的个数（含本身）<br>f[x]：以x为根的每个节点深度的和<br><img src="https://img-blog.csdnimg.cn/20200414211409638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>图一为以u为根节点<br>图二为以v为根节点<br>从u转到v 之后，图二中黄色区域（u和子树1和子树2）根节点都加1（因为成为别人的子节点），绿色区域（v和根节点2）根节点减1（因为成为别人的根节点）<br>那转换成公式是什么样的？<br>f[v]=（f[u]-ant[v]）+(n-ant[v]);<br>怎么理解呢？<br>第一个括号里，是将图二的绿色区域根节点减一，因为黄色区域一共ant[v]个节点，这个区域内每个节点都减1，所以整个区域f[u]要减ant[v].<br>第二个括号就是黄色区域每个节点都加一，那整个区域就加这个区域的节点数，这个区域的节点数=整个区域-绿色区域，所以就是n-ant[v]<br>我们从1开始dfs，求出每个节点的深度，即dep[]<br>然后再dfs求出每个点子树数量,再dfs换成其他根，利用公式求出f来</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> forr(n) for(int i=1;i&lt;=n;i++)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//链式前项星 </span></span><br><span class="line">ll head[maxn&lt;&lt;<span class="number">1</span>];<span class="comment">//无向边，所以乘2</span></span><br><span class="line">ll dep[maxn];<span class="comment">//节点的深度 </span></span><br><span class="line">ll ant[maxn];<span class="comment">//节点x的子树数量（包含本身） </span></span><br><span class="line">ll f[maxn];<span class="comment">//以i为根的时候每个点深度的和 </span></span><br><span class="line">ll cnt=<span class="number">0</span>;</span><br><span class="line">ll minn=<span class="number">1e7</span>;</span><br><span class="line">ll n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll u,ll v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">edge[++cnt].v=v;</span><br><span class="line">edge[cnt].next=head[u];</span><br><span class="line">head[u]=cnt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">forr(n)f[<span class="number">1</span>]+=dep[i];<span class="comment">//在dfs1求完每个点深度后，接着求出以1为根的时候每个点深度的和  </span></span><br><span class="line">forr(n)ant[i]=<span class="number">1</span>;<span class="comment">//每个节点的子树一开始都是本身 </span></span><br><span class="line">&#125;</span><br><span class="line">ll v=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line">&#123;</span><br><span class="line">v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[now]+<span class="number">1</span>;</span><br><span class="line">dfs1(v,now);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="comment">//以1为根节点开始，计算出每个节点的深度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> dfs2(v,now);</span><br><span class="line"> ant[now]+=ant[v]; </span><br><span class="line"> &#125;</span><br><span class="line">&#125;<span class="comment">//求出x节点的子树数量 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs3</span><span class="params">(ll now,ll fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(ll i=head[now];i;i=edge[i].next)</span><br><span class="line"> &#123;</span><br><span class="line"> v=edge[i].v;</span><br><span class="line"> <span class="keyword">if</span>(v==fa)<span class="keyword">continue</span>;</span><br><span class="line"> f[v]=f[now]-ant[v]+(n-ant[v]); </span><br><span class="line"> dfs3(v,now);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从1开始换成其他根，并求出其他根的f值 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> u,v;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">add(u,v);</span><br><span class="line">add(v,u);</span><br><span class="line">&#125;</span><br><span class="line">dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">init(n);<span class="comment">//初始化 </span></span><br><span class="line">dfs2(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">dfs3(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">forr(n)</span><br><span class="line">&#123;</span><br><span class="line">minn=min(minn,f[i]);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;minn;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细看会发现dfs1与dfs2结构相似，完全可以和在一起写<br>或者用vector写更简洁</p><h2 id="题解2："><a href="#题解2：" class="headerlink" title="题解2："></a>题解2：</h2><p>我看有很多大佬都用重心的性质来做<br>树的重心有一个这样的性质：在树中所有点到某点的距离和 当中，到树的重心的距离和是最小的，如果有多个重心，那他们距离和一样。<br>树中所有点到重心的距离和最小，不就是我们要求的那个值吗。<br>先用dfs树形dp求出重心，再求出重心与每个点的距离进行累加求和</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e6</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ant[maxn],root[maxn];</span><br><span class="line"><span class="keyword">int</span> n,cnt;</span><br><span class="line">ll res;</span><br><span class="line">ll point=maxn;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;edge[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ant[v]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxx=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs1(u,v);</span><br><span class="line">            </span><br><span class="line">            ant[v]+=(ant[u]+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            maxx=max(ant[u],maxx);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxx=max(n-ant[v]<span class="number">-1</span>,maxx);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(maxx&lt;point)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">        point=maxx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(maxx==point)</span><br><span class="line">        root[++cnt]=v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> p,<span class="keyword">int</span> dep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    res+=dep;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;edge[v].size();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u=edge[v][i];</span><br><span class="line">        <span class="keyword">if</span>(u!=p)</span><br><span class="line">            dfs2(u,v,dep+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        edge[u].push_back(v);</span><br><span class="line">        edge[v].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dfs1(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dfs2(root[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关树的重心其他性质，有空专门讲讲</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;br&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/201400&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 2秒，其他语言4秒 空间限制：C/C++ 262144K，其他语言524288K&lt;br&gt;64bit IO Format:&amp;gt; %lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;牛妹有一张连通图，由n个点和n-1条边构成，也就是说这是一棵树，牛妹可以任意选择一个点为根，根的深度dep&lt;del&gt;root&lt;/del&gt;为0，对于任意一个非根的点，我们将他到根节点路径上的第一个点称作他的父节点，例如1为根，1-4的；路径为1-3-5-4时，4的父节点是5，并且满足对任意非根节点，dep&lt;del&gt;i&lt;/del&gt;=dep&lt;del&gt;fa&lt;/del&gt; &lt;del&gt;i&lt;/del&gt;+1,整棵树的价值W=&lt;img src=&quot;https://img-blog.csdnimg.cn/20200414204932422.png&quot; alt=&quot;在这里插入图片描述&quot;&gt; ，即所有点的深度和&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="题解" scheme="http://Jozky.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树上dp" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adp/"/>
    
      <category term="dp" scheme="http://Jozky.top/tags/dp/"/>
    
      <category term="换根" scheme="http://Jozky.top/tags/%E6%8D%A2%E6%A0%B9/"/>
    
      <category term="树的重心" scheme="http://Jozky.top/tags/%E6%A0%91%E7%9A%84%E9%87%8D%E5%BF%83/"/>
    
      <category term="树上dfs" scheme="http://Jozky.top/tags/%E6%A0%91%E4%B8%8Adfs/"/>
    
  </entry>
  
  <entry>
    <title>使用一段时间牛客网的心得</title>
    <link href="http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/"/>
    <id>http://jozky.top/2020/04/14/%E4%BD%BF%E7%94%A8%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%89%9B%E5%AE%A2%E7%BD%91%E7%9A%84%E5%BF%83%E5%BE%97/</id>
    <published>2020-04-13T16:06:43.000Z</published>
    <updated>2020-04-14T14:39:10.022Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（<del>心痛</del> ）<br>牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉<br>一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。<br>等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20200414000658411.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">)<img src="https://img-blog.csdnimg.cn/20200414000643124.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1OTc1MzY3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>背包等着我<del>~</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直在写牛客网的题解，来获牛币，终于换了在牛客网的第一个奖品，一个三合一数据线，斥资我250个币（&lt;del&gt;心痛&lt;/del&gt; ）&lt;br&gt;牛客网早就知道，但之前用的很少，最近才逐渐多起来，感觉牛客网的运营方式以及题目比赛质量都很不错，也有很多企业招聘的信息试题（在我心目中逐渐取代洛谷）。之前也有个华为云白嫖的活动，可以错过了ε=(´ο｀*)))唉&lt;br&gt;一直有想当牛客网的校园代理，不过这个学期任务时间都很紧，事情也很多，等一会抽出空来再申请。&lt;br&gt;等攒牛币到破千（估计要暑假了），换个背包T恤啥的，嘿嘿嘿，但愿早日实现&lt;/p&gt;
    
    </summary>
    
    
      <category term="文章" scheme="http://Jozky.top/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="随笔" scheme="http://Jozky.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>牛客网【每日一题】4月9日题目精讲 Running Median</title>
    <link href="http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/"/>
    <id>http://jozky.top/2020/04/13/%E7%89%9B%E5%AE%A2%E7%BD%91%E3%80%90%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98%E3%80%914%E6%9C%889%E6%97%A5%E9%A2%98%E7%9B%AE%E7%B2%BE%E8%AE%B2-Running-Median/</id>
    <published>2020-04-12T16:32:26.000Z</published>
    <updated>2020-04-12T16:33:31.012Z</updated>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://ac.nowcoder.com/acm/problem/50940" target="_blank" rel="noopener">–&gt;链接&lt;—</a></p><blockquote><p>时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit<br> IO Format:%lld</p></blockquote><p>题目描述 </p><blockquote><p>For this problem, you will write a program that reads in a sequence of<br>32-bit signed integers. After each odd-indexed value is read, output<br>the median (middle value) of the elements received so far.</p></blockquote><a id="more"></a><p>输入描述:</p><blockquote><p>The first line of input contains a single integerP(1≤P≤1000), which is the number of data sets that follow. The<br>first line of each data set contains the data set number, followed by<br>a space, followed by an odd decimal integer (1≤M≤9999), giving the total number of signed integers to be<br>processed. The remaining line(s) in the dataset consists of the<br>values, 10 per line, separated by a single space. The last line in the<br>dataset may contain less than 10 values.</p></blockquote><p>输出描述:</p><blockquote><p>For each data set the first line of output contains the data set<br>number, a single space and the number of medians output (which should<br>be one-half the number of input values plus one). The output medians<br>will be on the following lines, 10 per line separated by a single<br>space. The last line may have less than 10 elements, but at least 1<br>element. There should be no blank lines in the output.</p></blockquote><p>示例1<br>输入<br>3<br>1 9<br>1 2 3 4 5 6 7 8 9<br>2 9<br>9 8 7 6 5 4 3 2 1<br>3 23<br>23 41 13 22 -3 24 -31 -11 -8 -7<br>3 5 103 211 -311 -45 -67 -73 -81 -99<br>-33 24 56<br>输出<br>1 5<br>1 2 3 4 5<br>2 5<br>9 8 7 6 5<br>3 12<br>23 23 22 22 13 3 5 5 3 -3<br>-7 -3</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>给你m个数，一次输入，每当输入的个数为奇数时，输出按大小排列最中间的数<br>比如1 5 6 7 8<br>一开始输入1，输出1<br>然后输入1 5，不输出<br>输入1 5 6，输出5<br>输入1 5 6 7，不输出<br>输入1 5 6 7 8，输出6</p><h2 id="题解一："><a href="#题解一：" class="headerlink" title="题解一："></a>题解一：</h2><p>可以用堆来做<br>w1为大堆，w1用于存放小值<br>w2为小堆，w2存放大值<br>比如上面那个例子1 5 6 7 8<br>奇数位存在w1，偶数存在w2<br>如果w1.top()&gt;w2.top(),就是w1的最大比w2的最小值大，就将这两个值互换，始终保证，w1的值比w2的任意一个都小，这样无论数据怎么读入，w1的最大值始终都是最中间的数<br>看下面模拟：<br>第一轮：<br>w1:1<br>w2：0<br>二：<br>w1:1<br>w2:5<br>三：<br>w1:1 6<br>w2:5<br>6&gt;5<br>w1:1 5<br>w2:6<br>四<br>w1:1 5<br>w2: 7 6<br>五<br>w1:1 5 8<br>w2: 7 6<br>8&gt;6<br>w1:1 5 6<br>w2; 7 8<br>这样每奇数轮，w1的top位就是答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt;w1;<span class="comment">//默认为大堆，从大到小</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt;w2;<span class="comment">//默认为小堆</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// freopen("in.txt","r",stdin);</span></span><br><span class="line">  <span class="comment">//ios::sync_with_stdio(0);</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> case1=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p,m,x;</span><br><span class="line">    <span class="keyword">int</span> minn,maxx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;m;</span><br><span class="line">        case1=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,p,m/<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)w1.push(x);</span><br><span class="line">            <span class="keyword">else</span> w2.push(x);</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                minn=w1.top();</span><br><span class="line">                maxx=w2.top();</span><br><span class="line">                <span class="keyword">if</span>(minn&gt;maxx)</span><br><span class="line">                &#123;</span><br><span class="line">                    w1.pop();</span><br><span class="line">                    w2.pop();</span><br><span class="line">                    w1.push(maxx);</span><br><span class="line">                    w2.push(minn);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(case1!=<span class="number">0</span>&amp;&amp;case1%<span class="number">10</span>==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                case1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==m)<span class="built_in">cout</span>&lt;&lt;w1.top();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d "</span>,w1.top());</span><br><span class="line">                case1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span>(!w1.empty())w1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!w2.empty())w2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（这个题的格式我一开始一直没注意。。。）</p><h2 id="题解二："><a href="#题解二：" class="headerlink" title="题解二："></a>题解二：</h2><p>我看很多人都是这么做的，但是只能过50%的数据。。包括我自己<br>我看了清楚姐姐的代码稍微改一下：<br>我们在读入一个数后，直接与w1.top比较，小于就存进去，大了就存w2里<br>当w1的数量多了，就把堆顶拿出给w2（小根堆）<br>w2多了就给大根堆<br>这样维护出来其实和上面的方法差不多<br>因为总数是奇数，两个堆数量一定不一样，多的那方，堆顶就是答案<br>代码：<br>清楚阿姨（<del>狗头</del> ）代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q2; <span class="comment">//小根堆 ，存较大的一半的数</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q1;  <span class="comment">//大根堆 ，存较小的一半的数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(!q1.empty()) q1.pop();</span><br><span class="line">        <span class="keyword">while</span>(!q2.empty()) q2.pop();  <span class="comment">//优先队列没有clear函数，要一个一个弹出</span></span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m ,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, m, (n+<span class="number">1</span>)/ <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (x &lt;= q1.top()) q1.push(x); <span class="comment">//如果当前值比大根堆堆顶小，说明在小的这二分之一，塞进大根堆</span></span><br><span class="line">            <span class="keyword">else</span>  q2.push(x);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> num1= q1.size();</span><br><span class="line">            <span class="keyword">int</span> num2= q2.size();</span><br><span class="line">            <span class="keyword">if</span> (num1 - num2 &gt; <span class="number">1</span>)   <span class="comment">//大根堆里面元素多了，把堆顶拿出来塞近小根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q2.push(q1.top());</span><br><span class="line">                q1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="keyword">if</span>(num2 - num1 &gt;<span class="number">1</span>) <span class="comment">//小根堆里面元素多了，把堆顶拿出来塞近大根堆</span></span><br><span class="line">            &#123;</span><br><span class="line">                q1.push(q2.top());</span><br><span class="line">                q2.pop();</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//目前的元素个数是奇数</span></span><br><span class="line">            &#123;</span><br><span class="line">                num1 = q1.size();</span><br><span class="line">                num2 = q2.size();</span><br><span class="line">                <span class="keyword">if</span>(num1 &gt; num2) <span class="built_in">printf</span>(<span class="string">"%d "</span>, q1.top()); <span class="comment">//中位数在大根堆</span></span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d "</span>, q2.top());           <span class="comment">//中位数在小根堆</span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">20</span> == <span class="number">19</span> &amp;&amp; i!=n) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@[TOC]&lt;/p&gt;
&lt;h2 id=&quot;题目：&quot;&gt;&lt;a href=&quot;#题目：&quot; class=&quot;headerlink&quot; title=&quot;题目：&quot;&gt;&lt;/a&gt;题目：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/50940&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;–&amp;gt;链接&amp;lt;—&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;时间限制：C/C++ 5秒，其他语言10秒 空间限制：C/C++ 65536K，其他语言131072K 64bit&lt;br&gt; IO Format:%lld&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;题目描述 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this problem, you will write a program that reads in a sequence of&lt;br&gt;32-bit signed integers. After each odd-indexed value is read, output&lt;br&gt;the median (middle value) of the elements received so far.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="题解" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="牛客网每日一题" scheme="http://Jozky.top/categories/%E9%A2%98%E8%A7%A3/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="堆" scheme="http://Jozky.top/tags/%E5%A0%86/"/>
    
  </entry>
  
</feed>
